{
  "houses": [
    {
      "id": "roots",
      "name": "House of Roots",
      "themes": {
        "foundation": 3,
        "memory": 2,
        "stability": 3
      },
      "keywords": ["home", "tradition", "endurance", "belonging"]
    },
    {
      "id": "canopy",
      "name": "House of Canopy",
      "themes": {
        "growth": 3,
        "connection": 3,
        "hope": 2
      },
      "keywords": ["healing", "community", "relationships", "renewal"]
    },
    {
      "id": "ember",
      "name": "House of Ember",
      "themes": {
        "will": 3,
        "conflict": 2,
        "passion": 3
      },
      "keywords": ["drive", "courage", "ambition", "trial"]
    },
    {
      "id": "whisper",
      "name": "House of Whisper",
      "themes": {
        "secrets": 2,
        "change": 3,
        "curiosity": 3
      },
      "keywords": ["insight", "illusion", "trickery", "exploration"]
    },
    {
      "id": "crown",
      "name": "Crown of the Tree",
      "themes": {
        "fate": 3,
        "cycles": 3,
        "balance": 2
      },
      "keywords": ["destiny", "turning point", "world forces"]
    }
  ]
}

How to use the weights (mentally + algorithmically)

Keep this simple:

3 → dominant force

2 → supporting influence

1 → background flavor (unused for now, but you can add later)

Example logic:

Count themes across drawn cards (respecting weights)

Highest total = dominant reading theme

Crown themes get a global multiplier (e.g. ×1.5) so they always feel “important”

Quick live-reading shortcut (still dumb, still useful)

Roots → “What holds”

Canopy → “What grows”

Ember → “What pushes”

Whisper → “What shifts”

Crown → “What must happen”

---
back of the cards need some nice design.

1) Roles and session flow
Roles

Priestess (Reader): creates session, selects deck/spread, draws/reveals cards, adds narration.

Player (Querent): joins session, watches reveals, optionally responds to prompts.

Audience/Overlay: read-only view for stream.

High-level flow

Priestess: Create Session

Player: Join Session (join code / link)

Priestess: Start Reading

Priestess: Shuffle (cosmetic) → Draw cards into spread

Priestess: Reveal cards (one-by-one or all)

Priestess: Narrate (text prompts + custom meanings)

End: Finish session → results saved (optional)

Everything becomes events so all UIs stay in sync.

2) Web pages (what each looks like)
A) Priestess page (control + meanings)

Layout suggestion

Left: Control column

Session state, Start/End

Spread positions list (“Root / Trunk / Canopy” etc.)

Buttons: Shuffle / Draw / Reveal next / Reveal all / Undo

Center: Card table (private)

Shows drawn cards + orientation

Shows position meaning prompts

Right: Text meaning panel (private)

Your custom meaning blocks (upright/reversed, tags/themes, interactions)

“Narration builder”: click-to-insert lines into a narration feed

This page should NOT be what you stream.

B) Player page (“other end”)

Keep it simple and pretty

Big spread layout

Reveals as they happen

Minimal text: maybe only “position prompts” + the Priestess narration feed

Optional small interaction: “Does this resonate? (yes/no)” or “Pick left/right path” later

C) Overlay / Broadcast page (for OBS)

This is the “share via screen recording software” piece.

Two ways:

Option 1 — A dedicated overlay URL (best)

/overlay/session/{joinCode}

Shows only what you want the audience to see:

card animations

revealed cards

short captions

optional “theme chips” (Roots/Ember/etc.)

No private meanings, no controls.

Option 2 — Priestess page has a “Streamer View” panel

A resizable panel that mirrors the overlay UI.
This is convenient but easier to leak private info. I’d still recommend a dedicated overlay route.

3) Server model like Bingo (API + event stream)

Use the exact same platform idea as bingo: sessions + events + state.

Session state (core)

sessionId, joinCode

deckId, spreadId

status: created|live|finished

priestessId

participants[] (player + optional audience)

draw[]: per spread position:

positionId, cardId, reversed, revealed, revealedAt

Events (append-only)

SESSION_CREATED

PLAYER_JOINED

SESSION_STARTED

SHUFFLE_STARTED / SHUFFLE_ENDED (cosmetic)

CARD_DRAWN (positionId, cardId, reversed)

CARD_REVEALED (positionId)

NARRATION_ADDED (text, style)

UNDO (optional)

SESSION_FINISHED

Transport

SSE (GET /stream) is perfect for web overlays and is simpler than websockets.

Polling works too, but SSE will make the animations feel instant.

4) Endpoints (minimal, works for all 3 pages)
Create & Join

POST /api/tarot/sessions (priestess) → {sessionId, joinCode, priestessToken}

POST /api/tarot/sessions/{joinCode}/join (player/overlay) → {viewerToken}

State & stream

GET /api/tarot/sessions/{joinCode}/state (viewer) → full safe state

GET /api/tarot/sessions/{joinCode}/stream (viewer) → SSE events

Priestess controls (auth with priestessToken)

POST /api/tarot/sessions/{sessionId}/start

POST /api/tarot/sessions/{sessionId}/shuffle (cosmetic event)

POST /api/tarot/sessions/{sessionId}/draw (draw remaining positions or a specific one)

POST /api/tarot/sessions/{sessionId}/reveal (next|positionId|all)

POST /api/tarot/sessions/{sessionId}/narrate {text}

POST /api/tarot/sessions/{sessionId}/finish

5) Card graphics + “add them via Discord”

You can absolutely do a Discord-driven asset pipeline.

Recommended pipeline
Step 1: Discord channel = “deck uploads”

You (or staff) drop:

an image attachment (PNG/WebP)

message text containing metadata

Example message format:

!tarot-card
id: candlecap_sprite
name: Candlecap Sprite
house: whisper
upright: curiosity, harmless trickery, spark of change
reversed: misdirection, impulse, gossip
tags: mischief, curiosity, illusion

Step 2: Server ingests the message

Two options:

A) Discord bot (best)

Bot watches a specific channel

When it sees !tarot-card, it:

grabs attachment CDN URL

parses metadata

calls your internal API: POST /api/tarot/decks/{deckId}/cards

B) Webhook ingestion (lighter)

You post via webhook to your server (less “Discord native” though)

Step 3: Server stores card assets

You’ll want to cache Discord CDN URLs or re-host them:

Fast v1: store Discord CDN URL directly (works, but links can break if message deleted)

Better: server downloads and stores to your object storage (S3/MinIO/etc.), then serves stable URLs

Deck endpoints

POST /api/tarot/decks (create)

POST /api/tarot/decks/{deckId}/cards (add/update)

GET /api/tarot/decks/{deckId} (list cards)

PUT /api/tarot/decks/{deckId}/back (set card back image)

6) Card animations (“nice graphical motion”)

Do this entirely in the overlay/player front-end:

The server only sends events; the UI handles animation.

Practical animation plan

Have a “deck pile” on screen (card back visible)

On CARD_DRAWN:

animate a card flying from deck pile to its position face-down

On CARD_REVEALED:

flip animation (CSS 3D transform) to show face

This looks great in OBS and is easy to implement with CSS + a little JS.