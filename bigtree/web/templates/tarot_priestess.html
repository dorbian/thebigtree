<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tarot Priestess</title>
<style>
  :root{
    --bg:#0d1411;
    --panel:#121b17;
    --panel-2:#0f1713;
    --text:#e6f2ea;
    --muted:#9bb4a4;
    --accent:#6bd4a2;
    --accent-2:#d6b26e;
    --danger:#e07070;
    --line:rgba(255,255,255,.08);
    --header-h:64px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    height:100vh;
    overflow:hidden;
    font-family:"Cinzel", "Garamond", "Georgia", serif;
    color:var(--text);
    background:
      radial-gradient(1200px 700px at 10% -10%, rgba(107,212,162,.18), transparent 60%),
      radial-gradient(900px 600px at 90% 0%, rgba(214,178,110,.14), transparent 55%),
      linear-gradient(180deg, #0b120f, #0f1713 40%, #0b120f);
    background-repeat:no-repeat;
    background-size:cover;
    background-attachment:fixed;
  }
  header{
    padding:18px 22px;
    height:var(--header-h);
    border-bottom:1px solid var(--line);
    display:flex;
    align-items:center;
    gap:12px;
  }
  header .sigil{
    width:36px;height:36px;border-radius:8px;
    background:linear-gradient(135deg, #234236, #1b2f28);
    border:1px solid var(--line);
  }
  header h1{margin:0;font-size:20px;letter-spacing:.06em}
  .subhead{
    padding:8px 22px 0;
    font-size:12px;
    color:var(--muted);
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    align-items:center;
  }
  .status-dot{
    width:8px;height:8px;border-radius:50%;
    background:#6bd4a2;
    display:inline-block;
    margin-right:6px;
  }
  .status-dot.off{background:#d18b8b}
  .status-dot.warn{background:#d6b26e}
  .error-bar{
    padding:6px 10px;
    border-radius:10px;
    border:1px solid rgba(224,112,112,.6);
    background:rgba(36,12,12,.6);
    color:#ffdada;
    font-size:12px;
    display:none;
  }
  .wrap{
    display:grid;
    grid-template-columns: 260px 1fr 320px;
    gap:16px;
    padding:16px;
    height:calc(100vh - var(--header-h));
    min-height:0;
    overflow:hidden;
  }
  .panel{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:14px;
    padding:14px;
    min-height:0;
    overflow:hidden;
  }
  .analysis-panel{
    margin-top:12px;
    padding:10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:rgba(8,12,10,.6);
    max-height:200px;
    overflow:auto;
    font-size:12px;
    color:var(--muted);
  }
  .analysis-panel h3{
    margin:0 0 8px 0;
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--muted);
  }
  .analysis-card{
    padding:8px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.06);
    background:rgba(6,10,8,.5);
    margin-bottom:8px;
  }
  .analysis-card:last-child{margin-bottom:0}
  .analysis-card strong{color:var(--text)}
  .panel h2{
    margin:0 0 10px 0;
    font-size:14px;
    letter-spacing:.08em;
    color:var(--muted);
    text-transform:uppercase;
  }
  .btn{
    display:inline-block;
    margin:4px 0;
    padding:7px 10px;
    border-radius:10px;
    border:1px solid var(--line);
    background:var(--panel-2);
    color:var(--text);
    cursor:pointer;
    font-size:12px;
  }
  .btn.accent{border-color:rgba(107,212,162,.5); color:#dff7ea}
  .btn.warn{border-color:rgba(214,178,110,.6); color:#f4e3c0}
  .btn.danger{border-color:rgba(224,112,112,.6); color:#ffdada}
  .stack{display:flex;flex-direction:column;gap:6px}
  .row{display:flex;gap:6px;flex-wrap:wrap}
  .muted{color:var(--muted);font-size:12px}
  .card-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(160px, 1fr));
    gap:12px;
  }
  .card-slot{
    background:var(--panel-2);
    border:1px dashed var(--line);
    border-radius:14px;
    padding:10px;
    min-height:210px;
    position:relative;
  }
  .card-slot .label{
    font-size:12px;
    color:var(--muted);
    letter-spacing:.05em;
    margin-bottom:8px;
  }
  .card{
    width:100%;
    aspect-ratio:3/4.2;
    perspective:1000px;
  }
  .card .inner{
    position:relative;
    width:100%;height:100%;
    transform-style:preserve-3d;
    transition:transform .7s ease;
  }
  .card.revealed .inner{transform:rotateY(180deg)}
  .face{
    position:absolute;inset:0;
    backface-visibility:hidden;
    border-radius:12px;
    overflow:hidden;
    border:1px solid var(--line);
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .back{
    background:
      radial-gradient(circle at 20% 20%, rgba(214,178,110,.18), transparent 40%),
      linear-gradient(135deg, #1b2d26, #132018);
  }
  .front{
    transform:rotateY(180deg);
    background:#0d1411;
    position:relative;
    isolation:isolate;
  }
  .front::before{
    content:"";
    position:absolute;
    inset:0;
    background:var(--card-overlay, transparent);
    opacity:var(--card-overlay-opacity, .35);
    mix-blend-mode:screen;
    pointer-events:none;
    z-index:1;
  }
  .front::after{
    content:"";
    position:absolute;
    inset:10px;
    border-radius:10px;
    border:1px solid var(--card-frame, rgba(255,255,255,.16));
    box-shadow:var(--card-frame-shadow, none);
    pointer-events:none;
    z-index:1;
  }
  .front img{width:100%;height:100%;object-fit:cover;position:relative;z-index:0}
  .card-title{
    position:absolute;
    left:50%;
    right:auto;
    bottom:10px;
    transform:translateX(-50%);
    padding:6px 12px;
    font-size:var(--card-title-size, 12px);
    letter-spacing:var(--card-title-letter, .04em);
    text-transform:var(--card-title-transform, uppercase);
    color:var(--card-title-color, var(--text));
    background:var(--card-title-bg, rgba(6,10,8,.65));
    font-family:var(--card-title-font, inherit);
    text-shadow:var(--card-title-shadow, none);
    border:1px solid var(--card-title-border, rgba(255,255,255,.2));
    border-radius:999px;
    min-width:60%;
    text-align:center;
    z-index:2;
  }
  .card-number{
    position:absolute;
    top:8px;
    left:50%;
    transform:translateX(-50%);
    padding:4px 10px;
    border-radius:999px;
    font-size:var(--card-number-size, 11px);
    letter-spacing:var(--card-number-letter, .08em);
    text-transform:var(--card-number-transform, uppercase);
    color:var(--card-number-color, var(--text));
    background:var(--card-number-bg, rgba(6,10,8,.7));
    border:1px solid var(--card-number-border, rgba(255,255,255,.2));
    z-index:2;
  }
  body[data-card-theme="classic"]{
    --card-overlay:radial-gradient(circle at 20% 10%, rgba(214,178,110,.35), transparent 55%),
      linear-gradient(180deg, rgba(10,12,12,.2), rgba(8,8,8,.65));
    --card-overlay-opacity:.45;
    --card-frame:rgba(214,178,110,.65);
    --card-frame-shadow:0 0 0 1px rgba(214,178,110,.25), inset 0 0 12px rgba(0,0,0,.35);
    --card-title-bg:linear-gradient(180deg, rgba(10,10,10,0), rgba(10,10,10,.85));
    --card-title-font:"Cinzel","Garamond","Georgia",serif;
    --card-title-shadow:0 2px 6px rgba(0,0,0,.6);
    --card-title-letter:.12em;
    --card-title-transform:uppercase;
    --card-title-border:rgba(214,178,110,.6);
    --card-number-letter:.16em;
    --card-number-transform:uppercase;
    --card-number-bg:rgba(18,12,6,.78);
    --card-number-border:rgba(214,178,110,.6);
  }
  body[data-card-theme="wood"]{
    --card-overlay:repeating-linear-gradient(45deg, rgba(104,68,36,.28) 0 8px, rgba(74,49,27,.28) 8px 16px),
      radial-gradient(circle at 50% 20%, rgba(162,111,58,.25), transparent 60%);
    --card-overlay-opacity:.5;
    --card-frame:rgba(141,99,58,.9);
    --card-frame-shadow:inset 0 0 0 2px rgba(63,41,24,.5), inset 0 8px 18px rgba(0,0,0,.35);
    --card-title-bg:linear-gradient(180deg, rgba(40,26,16,0), rgba(40,26,16,.85));
    --card-title-font:"Cormorant Garamond","Garamond","Georgia",serif;
    --card-title-color:#f0e6d6;
    --card-title-letter:.04em;
    --card-title-transform:none;
    --card-title-border:rgba(141,99,58,.85);
    --card-number-letter:.08em;
    --card-number-transform:none;
    --card-number-bg:rgba(52,34,20,.85);
    --card-number-border:rgba(141,99,58,.85);
  }
  body[data-card-theme="wood"] .card-title{
    text-transform:none;
    letter-spacing:.02em;
  }
  body[data-card-theme="neon"]{
    --card-overlay:radial-gradient(circle at 20% 20%, rgba(55,226,255,.25), transparent 45%),
      radial-gradient(circle at 80% 0%, rgba(255,82,205,.18), transparent 45%);
    --card-overlay-opacity:.65;
    --card-frame:rgba(70,240,255,.9);
    --card-frame-shadow:0 0 14px rgba(70,240,255,.45), inset 0 0 12px rgba(255,82,205,.25);
    --card-title-bg:linear-gradient(90deg, rgba(7,7,18,.7), rgba(7,7,18,.2));
    --card-title-font:"Orbitron","Trebuchet MS",sans-serif;
    --card-title-color:#e6fbff;
    --card-title-shadow:0 0 10px rgba(70,240,255,.65);
    --card-title-letter:.22em;
    --card-title-transform:uppercase;
    --card-title-border:rgba(70,240,255,.8);
    --card-number-letter:.22em;
    --card-number-transform:uppercase;
    --card-number-bg:rgba(6,8,20,.85);
    --card-number-border:rgba(70,240,255,.8);
  }
  body[data-card-theme="neon"] .card-title{
    letter-spacing:.18em;
  }
  .meaning{
    font-family:"Spectral","Georgia",serif;
    font-size:13px;
    line-height:1.4;
  }
  .theme-bars{
    margin-top:8px;
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .theme-bar{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:11px;
    color:var(--muted);
  }
  .theme-bar .emph{
    font-weight:700;
    color:var(--text);
  }
  .theme-bar .label{
    min-width:90px;
    text-transform:capitalize;
  }
  .theme-bar .track{
    flex:1;
    height:6px;
    border-radius:999px;
    background:rgba(255,255,255,.08);
    overflow:hidden;
  }
  .theme-bar .fill{
    height:100%;
    background:linear-gradient(90deg, rgba(107,212,162,.8), rgba(214,178,110,.8));
    border-radius:999px;
  }
  textarea, input{
    width:100%;
    padding:6px 8px;
    border-radius:8px;
    border:1px solid var(--line);
    background:#0c1511;
    color:var(--text);
    font-family:inherit;
    font-size:12px;
  }
  .narration{
    max-height:220px;
    overflow:auto;
    border-top:1px solid var(--line);
    margin-top:10px;
    padding-top:8px;
  }
  .deck-preview{
    width:120px;
    aspect-ratio:3/4.2;
    border-radius:12px;
    border:1px solid var(--line);
    background:
      radial-gradient(circle at 20% 20%, rgba(214,178,110,.18), transparent 40%),
      linear-gradient(135deg, #1b2d26, #132018);
    background-size:cover;
    background-position:center;
    margin:10px 0;
  }
  .deck-pile-wrap{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:10px;
  }
  .deck-pile{
    width:64px;
    aspect-ratio:3/4.2;
    border-radius:10px;
    border:1px solid var(--line);
    background:
      radial-gradient(circle at 20% 20%, rgba(214,178,110,.18), transparent 40%),
      linear-gradient(135deg, #1b2d26, #132018);
    background-size:cover;
    background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.35);
  }
  .deck-label{
    font-size:11px;
    letter-spacing:.12em;
    text-transform:uppercase;
    color:var(--muted);
  }
  .fly-card{
    position:fixed;
    left:0;
    top:0;
    border-radius:10px;
    border:1px solid var(--line);
    background-size:cover;
    background-position:center;
    box-shadow:0 10px 24px rgba(0,0,0,.35);
    pointer-events:none;
    transition:transform .6s ease, opacity .6s ease;
    z-index:9999;
  }
  .narration .line{font-size:12px;margin-bottom:6px}
  .chip{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid var(--line);
    font-size:11px;
    color:var(--muted);
  }
  .help-toggle{
    cursor:pointer;
    color:var(--accent);
    margin-left:4px;
    font-size:11px;
  }
  .hidden{display:none}
  .modal{
    position:fixed;
    inset:0;
    background:rgba(6,10,8,.7);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:20;
  }
  .modal.show{display:flex}
  .modal-card{
    width:min(520px, 92vw);
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:16px;
    padding:16px;
  }
  .modal-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:10px;
  }
  .modal-title{
    font-size:14px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--muted);
  }
</style>

<header>
  <div class="sigil"></div>
  <h1>Tarot Priestess</h1>
  <span class="chip" id="sessionStatus">loading</span>
</header>
<div class="subhead">
  <span><span class="status-dot" id="connDot"></span><span id="connStatus">connecting</span></span>
  <span>Join: <strong id="joinCode">{JOIN}</strong></span>
  <span>Deck: <strong id="deckId">-</strong></span>
  <span>Spread: <strong id="spreadId">-</strong></span>
</div>

<div class="wrap">
  <div class="panel">
    <h2>Session</h2>
    <div class="stack">
      <div class="muted">Session ID: <span id="sessionId">-</span></div>
      <div class="muted">Spread help: <span class="help-toggle" id="spreadHelp">(?)</span></div>
    </div>
    <div class="muted hidden" id="spreadNote">
      Spread = the card layout for the reading. Single: one card. Tree: Root/Trunk/Canopy. Cross: Past/Present/Future.
    </div>
    <div style="height:10px"></div>
    <label class="muted">Priestess token</label>
    <input id="tokenInput" placeholder="paste priestess token" />
    <div class="deck-preview" id="deckPreview"></div>
    <div class="row" style="margin-top:8px">
      <button class="btn accent" id="btnStart">Start Reading</button>
      <button class="btn danger" id="btnFinish">Finish</button>
      <button class="btn" id="btnNewSession">New session</button>
    </div>
    <div class="row" style="margin-top:6px">
      <button class="btn" id="btnOpenPlayer">Open player view</button>
    </div>
    <div class="row">
      <button class="btn warn" id="btnShuffle">Shuffle</button>
      <button class="btn" id="btnDraw">Draw</button>
      <button class="btn" id="btnRevealNext">Reveal Next</button>
      <button class="btn" id="btnRevealAll">Reveal All</button>
    </div>
    <div class="error-bar" id="actionError"></div>
    <div style="height:12px"></div>
    <h2>Positions</h2>
    <div id="positionsList" class="stack"></div>
  </div>

  <div class="panel">
    <h2>Spread</h2>
    <div class="deck-pile-wrap">
      <div class="deck-pile" id="deckPile"></div>
      <div class="deck-label">Deck</div>
    </div>
    <div id="cardGrid" class="card-grid"></div>
    <div class="analysis-panel" id="analysisPanel">
      <h3>Visible Card Focus</h3>
      <div class="muted">Draw cards to see focused notes.</div>
    </div>
  </div>

  <div class="panel">
    <h2>Meaning</h2>
    <div id="meaningPanel" class="meaning muted">Select a card to see details.</div>
    <div style="height:10px"></div>
    <div class="row">
      <button class="btn" id="btnAddPrompt">Add position prompt</button>
      <button class="btn" id="btnAddUpright">Add upright meaning</button>
      <button class="btn" id="btnAddReversed">Add reversed meaning</button>
    </div>
    <div style="height:8px"></div>
    <label class="muted">Custom narration</label>
    <textarea id="narrationInput" rows="3" placeholder="Write your narration line..."></textarea>
    <button class="btn accent" id="btnNarrate">Send narration</button>
    <div class="narration" id="narrationFeed"></div>
  </div>
</div>

<div class="modal" id="newSessionModal">
  <div class="modal-card">
    <div class="modal-header">
      <div class="modal-title">New Session</div>
      <button class="btn" id="newSessionClose">Close</button>
    </div>
    <label class="muted">Deck</label>
    <select id="newSessionDeck"></select>
    <label class="muted" style="margin-top:8px">Spread</label>
    <select id="newSessionSpread"></select>
    <div style="height:8px"></div>
    <button class="btn accent" id="newSessionCreate">Create & Open</button>
    <div class="muted" id="newSessionStatus" style="margin-top:8px"></div>
  </div>
</div>

<script>
  const joinCode = "{JOIN}";
  const qs = new URLSearchParams(location.search);
  const themeParam = qs.get("card_theme");
  const themeLocked = qs.has("card_theme");
  document.body.dataset.cardTheme = themeParam || "classic";
  const tokenInput = document.getElementById("tokenInput");
  const storedTokenKey = "tarot_token_" + joinCode;
  tokenInput.value = qs.get("token") || localStorage.getItem(storedTokenKey) || "";
  tokenInput.addEventListener("change", () => localStorage.setItem(storedTokenKey, tokenInput.value.trim()));

  const stateEls = {
    status: document.getElementById("sessionStatus"),
    sessionId: document.getElementById("sessionId"),
    deckId: document.getElementById("deckId"),
    spreadId: document.getElementById("spreadId"),
    positions: document.getElementById("positionsList"),
    grid: document.getElementById("cardGrid"),
    meaning: document.getElementById("meaningPanel"),
    narration: document.getElementById("narrationFeed"),
  };

  const connDot = document.getElementById("connDot");
  const connStatus = document.getElementById("connStatus");
  const actionError = document.getElementById("actionError");
  const deckPreview = document.getElementById("deckPreview");
  const deckPile = document.getElementById("deckPile");
  const newSessionModal = document.getElementById("newSessionModal");
  const newSessionDeck = document.getElementById("newSessionDeck");
  const newSessionSpread = document.getElementById("newSessionSpread");
  const newSessionStatus = document.getElementById("newSessionStatus");

  let currentState = null;
  let selectedPosition = null;
  let sse = null;
  let lastDrawCount = 0;
  const pendingDraws = [];
  const pendingReveals = new Set();
  let houseThemes = {};
  let numberDefs = {};

  function parseRoman(value){
    const roman = String(value || "").trim().toUpperCase();
    if (!roman) return NaN;
    const map = {I:1, V:5, X:10, L:50, C:100, D:500, M:1000};
    let total = 0;
    let prev = 0;
    for (let i = roman.length - 1; i >= 0; i -= 1){
      const num = map[roman[i]];
      if (!num) return NaN;
      if (num < prev){
        total -= num;
      } else {
        total += num;
        prev = num;
      }
    }
    return total;
  }

  function parseCardNumber(value){
    const text = String(value).trim();
    if (!text) return NaN;
    if (/^\d+$/.test(text)) return parseInt(text, 10);
    return parseRoman(text);
  }

  function toRoman(num){
    const n = Number(num);
    if (!Number.isFinite(n) || n <= 0) return "";
    const map = [
      [1000, "M"], [900, "CM"], [500, "D"], [400, "CD"],
      [100, "C"], [90, "XC"], [50, "L"], [40, "XL"],
      [10, "X"], [9, "IX"], [5, "V"], [4, "IV"], [1, "I"]
    ];
    let out = "";
    let remaining = Math.floor(n);
    map.forEach(([val, sym]) => {
      while (remaining >= val){
        out += sym;
        remaining -= val;
      }
    });
    return out;
  }

  function formatCardNumber(value){
    if (String(value || "").trim() === "0") return "0";
    const num = parseCardNumber(value);
    if (num === 0) return "0";
    return num ? toRoman(num) || String(value || "") : "";
  }

  function renderNumberInfo(value){
    const num = parseCardNumber(value);
    if (!Number.isFinite(num)) return "";
    const digits = String(num).split("").map(d => parseInt(d, 10));
    let sum = digits.reduce((acc, d) => acc + d, 0);
    while (sum > 10){
      sum = String(sum).split("").reduce((acc, d) => acc + parseInt(d, 10), 0);
    }
    const picks = [];
    digits.forEach(d => { if (!picks.includes(d)) picks.push(d); });
    if (sum > 0 && !picks.includes(sum)) picks.push(sum);
    if (num === 0 && !picks.includes(0)) picks.push(0);
    const rows = picks.map(pick => {
      const entry = numberDefs[pick] || {};
      const label = entry.label ? ` - ${entry.label}` : "";
      const meaning = entry.meaning || "";
      return `<div><strong>${pick}${label}</strong><br>${meaning}</div>`;
    }).join("<div style=\"height:6px\"></div>");
    return rows ? `<div style="margin-top:8px">${rows}</div>` : "";
  }

  function authHeaders(){
    return {"Content-Type":"application/json", "X-Tarot-Token": tokenInput.value.trim()};
  }

  function getPlayerUrl(){
    const url = new URL(`/tarot/session/${encodeURIComponent(joinCode)}`, window.location.origin);
    url.searchParams.set("view", "player");
    return url.toString();
  }

  document.getElementById("btnOpenPlayer").addEventListener("click", () => {
    window.open(getPlayerUrl(), "_blank");
  });

  async function fetchState(){
    const res = await fetch(`/api/tarot/sessions/${joinCode}/state?view=priestess`);
    const data = await res.json();
    if (!data.ok) return;
    currentState = data.state;
    render();
  }

  function render(){
    if (!currentState) return;
    const s = currentState.session;
    if (!themeLocked){
      const deckTheme = currentState.deck ? currentState.deck.theme : "";
      document.body.dataset.cardTheme = deckTheme || "classic";
    }
    stateEls.status.textContent = s.status || "created";
    stateEls.sessionId.textContent = s.session_id;
    stateEls.deckId.textContent = s.deck_id;
    stateEls.spreadId.textContent = s.spread_id;
    const backUrl = currentState.deck && currentState.deck.back_image ? currentState.deck.back_image : "";
    if (backUrl){
      deckPreview.style.backgroundImage = `linear-gradient(135deg, rgba(12,18,32,.4), rgba(12,18,32,.6)), url('${backUrl}')`;
      if (deckPile){
        deckPile.style.backgroundImage = `linear-gradient(135deg, rgba(12,18,32,.4), rgba(12,18,32,.6)), url('${backUrl}')`;
      }
    } else {
      deckPreview.style.backgroundImage = "";
      if (deckPile){
        deckPile.style.backgroundImage = "";
      }
    }

    stateEls.positions.innerHTML = "";
    currentState.spread.positions.forEach(pos => {
      const draw = currentState.draw.find(d => d.position_id === pos.id);
      const el = document.createElement("div");
      el.className = "muted";
      let label = `${pos.label} - ${pos.prompt || ""}`;
      if (draw && draw.revealed) label += " (revealed)";
      else if (draw) label += " (drawn)";
      el.textContent = label;
      stateEls.positions.appendChild(el);
    });

    stateEls.grid.innerHTML = "";
    currentState.spread.positions.forEach(pos => {
      const draw = currentState.draw.find(d => d.position_id === pos.id);
      const slot = document.createElement("div");
      slot.className = "card-slot";
      const label = document.createElement("div");
      label.className = "label";
      label.textContent = `${pos.label} - ${pos.prompt || ""}`;
      slot.appendChild(label);

      const cardWrap = document.createElement("div");
      const shouldReveal = draw && draw.revealed;
      const animateReveal = shouldReveal && pendingReveals.has(pos.id);
      cardWrap.className = "card" + (shouldReveal && !animateReveal ? " revealed" : "");
      cardWrap.dataset.positionId = pos.id;
      const inner = document.createElement("div");
      inner.className = "inner";
      const back = document.createElement("div");
      back.className = "face back";
      if (backUrl){
        back.style.backgroundImage = `linear-gradient(135deg, rgba(12,18,32,.4), rgba(12,18,32,.6)), url('${backUrl}')`;
        back.style.backgroundSize = "cover";
        back.style.backgroundPosition = "center";
      }
      const front = document.createElement("div");
      front.className = "face front";
      if (draw && draw.card && draw.card.image){
        const img = document.createElement("img");
        img.src = draw.card.image;
        front.appendChild(img);
      }
      if (draw && draw.card && draw.card.number !== undefined && draw.card.number !== null){
        const number = document.createElement("div");
        number.className = "card-number";
        number.textContent = formatCardNumber(draw.card.number);
        front.appendChild(number);
      }
      if (draw && draw.card && draw.card.name){
        const title = document.createElement("div");
        title.className = "card-title";
        title.textContent = draw.card.name;
        front.appendChild(title);
      }
      inner.appendChild(back);
      inner.appendChild(front);
      cardWrap.appendChild(inner);
      cardWrap.addEventListener("click", async () => {
        if (draw && !draw.revealed){
          await postControl(
            `/api/tarot/sessions/${currentState.session.session_id}/reveal`,
            {token: tokenInput.value, position_id: pos.id}
          );
        }
        selectCard(pos.id);
      });
      slot.appendChild(cardWrap);
      stateEls.grid.appendChild(slot);
      if (animateReveal){
        requestAnimationFrame(() => {
          cardWrap.classList.add("revealed");
        });
        pendingReveals.delete(pos.id);
      }
    });

    const newDrawCount = (currentState.draw || []).length;
    if (newDrawCount > lastDrawCount){
      const lastDraw = currentState.draw[newDrawCount - 1];
      if (lastDraw && lastDraw.position_id){
        selectedPosition = lastDraw.position_id;
      }
    }
    lastDrawCount = newDrawCount;

    renderNarration();
    if (selectedPosition) updateMeaning(selectedPosition);
    renderAnalysis();
    if (pendingDraws.length){
      pendingDraws.splice(0).forEach(positionId => animateDraw(positionId));
    }
  }

  function animateDraw(positionId){
    if (!deckPile) return;
    const target = stateEls.grid.querySelector(`[data-position-id="${positionId}"]`);
    if (!target) return;
    const from = deckPile.getBoundingClientRect();
    const to = target.getBoundingClientRect();
    const fly = document.createElement("div");
    fly.className = "fly-card";
    fly.style.width = `${from.width}px`;
    fly.style.height = `${from.height}px`;
    fly.style.left = `${from.left}px`;
    fly.style.top = `${from.top}px`;
    fly.style.backgroundImage = deckPile.style.backgroundImage || "";
    document.body.appendChild(fly);
    const dx = to.left - from.left;
    const dy = to.top - from.top;
    const scaleX = to.width / from.width;
    const scaleY = to.height / from.height;
    requestAnimationFrame(() => {
      fly.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
      fly.style.opacity = "0";
    });
    fly.addEventListener("transitionend", () => fly.remove(), {once:true});
  }

  function renderNarration(){
    stateEls.narration.innerHTML = "";
    (currentState.narration || []).slice().reverse().forEach(n => {
      const line = document.createElement("div");
      line.className = "line";
      line.textContent = n.text;
      stateEls.narration.appendChild(line);
    });
  }

  function selectCard(positionId){
    selectedPosition = positionId;
    updateMeaning(positionId);
  }

  function renderThemeBars(themes, highlightSet){
    const items = Object.entries(themes || {}).filter(([, value]) => Number(value) > 0);
    if (!items.length){
      return "";
    }
    items.sort((a, b) => Number(b[1]) - Number(a[1]));
    const top = items.slice(0, 3);
    const max = Math.max(...top.map(([, value]) => Number(value)));
    const rows = top.map(([name, value]) => {
      const width = Math.max(6, Math.round((Number(value) / max) * 100));
      const label = (name || "").replace(/_/g, " ");
      const highlight = highlightSet && highlightSet.has(name);
      return `
        <div class="theme-bar">
          <div class="label ${highlight ? "emph" : ""}">${label}</div>
          <div class="track"><div class="fill" style="width:${width}%"></div></div>
          <div class="${highlight ? "emph" : ""}">${value}</div>
        </div>
      `;
    }).join("");
    return `<div class="theme-bars">${rows}</div>`;
  }

  function updateMeaning(positionId){
    const draw = currentState.draw.find(d => d.position_id === positionId);
    const pos = currentState.spread.positions.find(p => p.id === positionId);
    if (!draw || !draw.card){
      stateEls.meaning.innerHTML = `<div class="muted">${pos ? pos.label : "Card"}: not drawn.</div>`;
      return;
    }
    const card = draw.card;
    const title = `${card.name}${draw.reversed ? " (reversed)" : ""}`;
    const upright = card.upright || "";
    const reversed = card.reversed || "";
    const house = card.house ? `<div class="muted">House: ${card.house}</div>` : "";
    const prompt = pos ? `<div class="muted">${pos.label} â€” ${pos.prompt || ""}</div>` : "";
    const highlight = card.house && houseThemes[card.house] ? new Set(Object.keys(houseThemes[card.house])) : null;
    const themes = renderThemeBars(card.themes, highlight);
    const numbers = renderNumberInfo(card.number);
    stateEls.meaning.innerHTML = `
      <div><strong>${title}</strong></div>
      ${prompt}
      ${house}
      ${themes}
      ${numbers}
      <div style="margin-top:6px">${draw.reversed ? reversed : upright}</div>
    `;
  }

  function renderAnalysis(){
    const panel = document.getElementById("analysisPanel");
    if (!panel || !currentState){
      return;
    }
    const draws = (currentState.draw || []).filter(d => d.revealed);
    if (!draws.length){
      panel.innerHTML = `<h3>Visible Card Focus</h3><div class="muted">Reveal cards to see focused notes.</div>`;
      return;
    }
    const rows = draws.map(draw => {
      const card = draw.card || {};
      const name = card.name || "Card";
      const house = card.house ? `House: ${card.house}` : "House: -";
      const number = (card.number !== undefined && card.number !== null) ? `Number: ${formatCardNumber(card.number)}` : "Number: -";
      const highlight = card.house && houseThemes[card.house] ? new Set(Object.keys(houseThemes[card.house])) : null;
      const themeItems = Object.entries(card.themes || {}).filter(([, v]) => Number(v) > 0);
      const themeList = themeItems.map(([k, v]) => {
        const label = (k || "").replace(/_/g, " ");
        if (highlight && highlight.has(k)){
          return `<strong>${label} (${v})</strong>`;
        }
        return `${label} (${v})`;
      }).join(", ");
      const numbers = renderNumberInfo(card.number);
      return `
        <div class="analysis-card">
          <div><strong>${name}</strong> ${draw.reversed ? "(reversed)" : ""}</div>
          <div class="muted">${house} - ${number}</div>
          ${themeList ? `<div class="muted">Focus: ${themeList}</div>` : ""}
          ${numbers}
        </div>
      `;
    }).join("");
    panel.innerHTML = `<h3>Visible Card Focus</h3>${rows}`;
  }

  async function postControl(path, body){
    const res = await fetch(path, {method:"POST", headers:authHeaders(), body:JSON.stringify(body || {})});
    if (!res.ok){
      const data = await res.json().catch(() => ({}));
      actionError.textContent = data.error || "Request failed.";
      actionError.style.display = "block";
      return false;
    }
    actionError.style.display = "none";
    await fetchState();
    return true;
  }

  document.getElementById("btnStart").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/start`, {token: tokenInput.value});
  };
  document.getElementById("btnFinish").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/finish`, {token: tokenInput.value});
  };
  document.getElementById("btnShuffle").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/shuffle`, {token: tokenInput.value});
  };
  document.getElementById("btnDraw").onclick = async () => {
    if (!currentState){
      await fetchState();
    }
    const positions = (currentState && currentState.spread && currentState.spread.positions) || [];
    const drawn = (currentState && currentState.draw) || [];
    const drawnIds = new Set(drawn.map(d => d.position_id));
    const remaining = positions.filter(p => !drawnIds.has(p.id)).length;
    if (remaining > 0){
      await postControl(
        `/api/tarot/sessions/${currentState.session.session_id}/draw`,
        {token: tokenInput.value, count: remaining}
      );
    }
    await postControl(
      `/api/tarot/sessions/${currentState.session.session_id}/reveal`,
      {token: tokenInput.value, mode:"next"}
    );
  };
  document.getElementById("btnRevealNext").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/reveal`, {token: tokenInput.value, mode:"next"});
  };
  document.getElementById("btnRevealAll").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/reveal`, {token: tokenInput.value, mode:"all"});
  };

  document.getElementById("btnNarrate").onclick = async () => {
    const text = document.getElementById("narrationInput").value.trim();
    if (!text) return;
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/narrate`, {token: tokenInput.value, text});
    document.getElementById("narrationInput").value = "";
  };

  document.getElementById("btnAddPrompt").onclick = () => {
    const pos = currentState.spread.positions.find(p => p.id === selectedPosition);
    if (!pos) return;
    document.getElementById("narrationInput").value = pos.prompt || pos.label;
  };
  document.getElementById("btnAddUpright").onclick = () => {
    const draw = currentState.draw.find(d => d.position_id === selectedPosition);
    if (!draw || !draw.card) return;
    document.getElementById("narrationInput").value = draw.card.upright || "";
  };
  document.getElementById("btnAddReversed").onclick = () => {
    const draw = currentState.draw.find(d => d.position_id === selectedPosition);
    if (!draw || !draw.card) return;
    document.getElementById("narrationInput").value = draw.card.reversed || "";
  };

  function connectSSE(){
    if (sse){
      sse.close();
    }
    const src = new EventSource(`/api/tarot/sessions/${joinCode}/stream?view=priestess`);
    sse = src;
    src.onopen = () => {
      connDot.className = "status-dot";
      connStatus.textContent = "connected";
    };
    src.onerror = () => {
      connDot.className = "status-dot warn";
      connStatus.textContent = "reconnecting";
    };
    src.onmessage = (ev) => {
      try{
        const payload = JSON.parse(ev.data);
        if (payload.type === "CARD_DRAWN" && payload.data && payload.data.position_id){
          pendingDraws.push(payload.data.position_id);
        }
        if (payload.type === "CARD_REVEALED" && payload.data && payload.data.position_id){
          pendingReveals.add(payload.data.position_id);
        }
      }catch(err){}
      fetchState();
    };
  }

  document.getElementById("spreadHelp").addEventListener("click", () => {
    document.getElementById("spreadNote").classList.toggle("hidden");
  });

  async function loadNumbers(){
    try{
      const res = await fetch("/api/tarot/numbers");
      const data = await res.json();
      numberDefs = {};
      (data.numbers || []).forEach(n => {
        numberDefs[n.number] = {label: n.label || "", meaning: n.meaning || ""};
      });
    }catch(err){
      numberDefs = {};
    }
  }

  async function loadHouses(){
    try{
      const res = await fetch("/api/tarot/houses");
      const data = await res.json();
      houseThemes = {};
      (data.houses || []).forEach(h => {
        houseThemes[h.id] = h.themes || {};
      });
    }catch(err){
      houseThemes = {};
    }
  }

  async function loadSessionOptions(){
    try{
      const decksRes = await fetch("/api/tarot/decks/public");
      const decksData = await decksRes.json();
      const decks = decksData.decks || [];
      newSessionDeck.innerHTML = "";
      decks.forEach(d => {
        const opt = document.createElement("option");
        opt.value = d.deck_id;
        opt.textContent = d.name || d.deck_id;
        newSessionDeck.appendChild(opt);
      });
      if (!decks.length){
        const opt = document.createElement("option");
        opt.value = "elf-classic";
        opt.textContent = "elf-classic";
        newSessionDeck.appendChild(opt);
      }
      const spreadsRes = await fetch("/api/tarot/spreads");
      const spreadsData = await spreadsRes.json();
      const spreads = spreadsData.spreads || [];
      newSessionSpread.innerHTML = "";
      spreads.forEach(s => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.label || s.id;
        newSessionSpread.appendChild(opt);
      });
      if (!spreads.length){
        const opt = document.createElement("option");
        opt.value = "single";
        opt.textContent = "single";
        newSessionSpread.appendChild(opt);
      }
    }catch(err){
      newSessionStatus.textContent = "Failed to load decks/spreads.";
    }
  }

  document.getElementById("btnNewSession").addEventListener("click", async () => {
    newSessionStatus.textContent = "";
    newSessionModal.classList.add("show");
    await loadSessionOptions();
  });
  document.getElementById("newSessionClose").addEventListener("click", () => {
    newSessionModal.classList.remove("show");
  });
  newSessionModal.addEventListener("click", (event) => {
    if (event.target === newSessionModal){
      newSessionModal.classList.remove("show");
    }
  });
  document.getElementById("newSessionCreate").addEventListener("click", async () => {
    const deck = newSessionDeck.value || "elf-classic";
    const spread = newSessionSpread.value || "single";
    const token = tokenInput.value.trim();
    if (!token){
      newSessionStatus.textContent = "Priestess token required.";
      return;
    }
    newSessionStatus.textContent = "Creating...";
    try{
      const res = await fetch("/api/tarot/sessions/from-priestess", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({
          join_code: joinCode,
          token: token,
          deck_id: deck,
          spread_id: spread,
        })
      });
      const data = await res.json();
      if (!data.ok){
        newSessionStatus.textContent = data.error || "Failed to create.";
        return;
      }
      const url = new URL(`/tarot/session/${encodeURIComponent(data.join_code)}`, window.location.origin);
      url.searchParams.set("view", "priestess");
      url.searchParams.set("token", data.priestess_token);
      window.location.assign(url.toString());
    }catch(err){
      newSessionStatus.textContent = "Failed to create.";
    }
  });

  fetchState();
  connectSSE();
  loadNumbers();
  loadHouses();
</script>


