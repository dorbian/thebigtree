<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tarot Priestess</title>
<link rel="icon" href="/icon.png" type="image/png">
<style>
  :root{
    --bg:#0d1411;
    --panel:#121b17;
    --panel-2:#0f1713;
    --text:#e6f2ea;
    --muted:#9bb4a4;
    --accent:#6bd4a2;
    --accent-2:#d6b26e;
    --neutral:#e7ddc7;
    --neutral-2:#c8bfae;
    --danger:#e07070;
    --line:rgba(255,255,255,.08);
    --header-h:64px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    height:100vh;
    overflow:hidden;
    font-family:"Cinzel", "Garamond", "Georgia", serif;
    color:var(--text);
    background:
      radial-gradient(1200px 700px at 10% -10%, rgba(107,212,162,.18), transparent 60%),
      radial-gradient(900px 600px at 90% 0%, rgba(214,178,110,.14), transparent 55%),
      linear-gradient(180deg, #0b120f, #0f1713 40%, #0b120f);
    background-repeat:no-repeat;
    background-size:cover;
    background-attachment:fixed;
  }
  body::before{
    content:"";
    position:fixed;
    inset:0;
    background:radial-gradient(circle at 50% 30%, rgba(214,178,110,.12), transparent 55%);
    opacity:.5;
    pointer-events:none;
    animation:breath 16s ease-in-out infinite;
    z-index:0;
  }
  body::after{
    content:"";
    position:fixed;
    inset:0;
    background:linear-gradient(120deg, rgba(255,255,255,.04), transparent 60%);
    opacity:.18;
    pointer-events:none;
    z-index:0;
  }
  @keyframes breath{
    0%, 100%{opacity:.4}
    50%{opacity:.7}
  }
  header{
    padding:18px 22px;
    height:var(--header-h);
    border-bottom:1px solid var(--line);
    display:flex;
    align-items:center;
    gap:12px;
    position:relative;
    z-index:1;
  }
  header .sigil{
    width:36px;height:36px;border-radius:8px;
    background:linear-gradient(135deg, #234236, #1b2f28);
    border:1px solid var(--line);
  }
  header h1{margin:0;font-size:20px;letter-spacing:.06em}
  .subhead{
    padding:8px 22px 0;
    font-size:12px;
    color:var(--muted);
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    align-items:center;
    position:relative;
    z-index:1;
  }
  .status-dot{
    width:8px;height:8px;border-radius:50%;
    background:#6bd4a2;
    display:inline-block;
    margin-right:6px;
  }
  .status-dot.off{background:#d18b8b}
  .status-dot.warn{background:#d6b26e}
  .error-bar{
    padding:6px 10px;
    border-radius:10px;
    border:1px solid rgba(224,112,112,.6);
    background:rgba(36,12,12,.6);
    color:#ffdada;
    font-size:12px;
    display:none;
  }
  .wrap{
    display:grid;
    grid-template-columns:minmax(220px, 0.9fr) minmax(320px, 2fr) minmax(260px, 1.1fr);
    gap:22px;
    padding:16px;
    height:calc(100vh - var(--header-h) - 40px);
    min-height:0;
    overflow:hidden;
    position:relative;
    z-index:1;
  }
  .panel{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:14px;
    padding:14px;
    min-height:0;
    overflow:hidden;
    box-shadow:0 12px 24px rgba(0,0,0,.28);
  }
  .panel.session{
    border-color:rgba(214,178,110,.18);
  }
  .panel.spread{
    border-color:rgba(107,212,162,.18);
  }
  .panel.meaning{
    border-color:rgba(214,178,110,.18);
  }
  .panel.scroll{
    overflow:auto;
  }
  .analysis-panel{
    margin-top:12px;
    padding:10px;
    border-radius:12px;
    border:1px solid var(--line);
    background:rgba(8,12,10,.6);
    max-height:200px;
    overflow:auto;
    font-size:12px;
    color:var(--muted);
  }
  .meaning-text{
    white-space:pre-wrap;
  }
  .analysis-panel h3{
    margin:0 0 8px 0;
    font-size:12px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--muted);
  }
  .analysis-card{
    padding:8px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.06);
    background:rgba(6,10,8,.5);
    margin-bottom:8px;
  }
  .analysis-card:last-child{margin-bottom:0}
  .analysis-card strong{color:var(--text)}
  .term-hit{
    font-weight:700;
    text-decoration:underline;
  }
  .panel h2{
    margin:0 0 10px 0;
    font-size:14px;
    letter-spacing:.08em;
    color:var(--muted);
    text-transform:uppercase;
  }
  .panel h3{
    margin:12px 0 8px 0;
    font-size:11px;
    letter-spacing:.12em;
    text-transform:uppercase;
    color:var(--neutral-2);
  }
  .btn{
    display:inline-block;
    margin:4px 0;
    padding:7px 10px;
    border-radius:10px;
    border:1px solid var(--line);
    background:var(--panel-2);
    color:var(--text);
    cursor:pointer;
    font-size:12px;
  }
  .btn.primary{
    background:linear-gradient(135deg, rgba(107,212,162,.95), rgba(107,212,162,.6));
    border-color:rgba(107,212,162,.6);
    color:#0e1813;
    font-weight:700;
  }
  .btn[disabled]{
    opacity:.45;
    cursor:not-allowed;
  }
  .btn.icon{
    display:inline-flex;
    align-items:center;
    gap:6px;
  }
  .btn.accent{border-color:rgba(107,212,162,.5); color:#dff7ea}
  .btn.warn{border-color:rgba(214,178,110,.6); color:#f4e3c0}
  .btn.danger{border-color:rgba(224,112,112,.6); color:#ffdada}
  .stack{display:flex;flex-direction:column;gap:6px}
  .row{display:flex;gap:6px;flex-wrap:wrap}
  .muted{color:var(--muted);font-size:12px}
  .card-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(190px, 1fr));
    gap:16px;
    justify-items:center;
  }
  .card-slot{
    background:var(--panel-2);
    border:1px dashed var(--line);
    border-radius:14px;
    padding:10px;
    min-height:240px;
    position:relative;
    width:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
  }
  .card-slot.revealed{
    box-shadow:0 0 18px rgba(214,178,110,.25), inset 0 0 12px rgba(0,0,0,.3);
  }
  .position-tag{
    position:absolute;
    top:10px;
    left:10px;
    padding:4px 10px;
    border-radius:999px;
    font-size:10px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--neutral);
    background:rgba(8,12,10,.7);
    border:1px solid rgba(255,255,255,.14);
    z-index:3;
  }
  .card-slot:fullscreen{
    background:rgba(5,10,8,.95);
    border:none;
    padding:24px;
    align-items:center;
    justify-content:center;
  }
  .card-slot:fullscreen .label{
    display:none;
  }
  .card-slot:fullscreen .card{
    max-width:none;
    width:min(80vw, calc(80vh * 3 / 4.2));
  }
  .card-slot .label{
    font-size:12px;
    color:var(--muted);
    letter-spacing:.05em;
    margin-bottom:8px;
  }
  .card{
    width:100%;
    aspect-ratio:3/4.2;
    perspective:1000px;
    max-width:260px;
  }
  .card.dealt-hidden{
    visibility:hidden;
  }
  .card .inner{
    position:relative;
    width:100%;height:100%;
    transform-style:preserve-3d;
    transition:transform 1.1s ease;
  }
  .card.revealed .inner.reversed{
    transform:rotateY(180deg) rotateZ(180deg);
  }
  .card.revealed .inner{transform:rotateY(180deg)}
  .face{
    position:absolute;inset:0;
    backface-visibility:hidden;
    border-radius:12px;
    overflow:hidden;
    border:1px solid var(--line);
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .back{
    background:
      radial-gradient(circle at 20% 20%, rgba(214,178,110,.18), transparent 40%),
      linear-gradient(135deg, #1b2d26, #132018);
  }
  .front{
    transform:rotateY(180deg);
    background:#0d1411;
    position:relative;
    isolation:isolate;
  }
  .front::before{
    content:"";
    position:absolute;
    inset:0;
    background:var(--card-overlay, transparent);
    opacity:var(--card-overlay-opacity, .35);
    mix-blend-mode:screen;
    pointer-events:none;
    z-index:1;
  }
  .front::after{
    content:"";
    position:absolute;
    inset:10px;
    border-radius:10px;
    border:1px solid var(--card-frame, rgba(255,255,255,.16));
    box-shadow:var(--card-frame-shadow, none);
    pointer-events:none;
    z-index:1;
  }
  .front img{width:100%;height:100%;object-fit:cover;position:relative;z-index:0}
  .card-title{
    position:absolute;
    left:50%;
    right:auto;
    bottom:10px;
    transform:translateX(-50%);
    padding:6px 12px;
    font-size:var(--card-title-size, 12px);
    letter-spacing:var(--card-title-letter, .04em);
    text-transform:var(--card-title-transform, uppercase);
    color:var(--card-title-color, var(--text));
    background:var(--card-title-bg, rgba(6,10,8,.65));
    font-family:var(--card-title-font, inherit);
    text-shadow:var(--card-title-shadow, none);
    border:1px solid var(--card-title-border, rgba(255,255,255,.2));
    border-radius:999px;
    min-width:60%;
    text-align:center;
    z-index:2;
  }
  .card-number{
    position:absolute;
    top:8px;
    left:50%;
    transform:translateX(-50%);
    padding:4px 10px;
    border-radius:999px;
    font-size:var(--card-number-size, 11px);
    letter-spacing:var(--card-number-letter, .08em);
    text-transform:var(--card-number-transform, uppercase);
    color:var(--card-number-color, var(--text));
    background:var(--card-number-bg, rgba(6,10,8,.7));
    border:1px solid var(--card-number-border, rgba(255,255,255,.2));
    z-index:2;
  }
  body[data-card-theme="classic"]{
    --card-overlay:radial-gradient(circle at 20% 10%, rgba(214,178,110,.35), transparent 55%),
      linear-gradient(180deg, rgba(10,12,12,.2), rgba(8,8,8,.65));
    --card-overlay-opacity:.45;
    --card-frame:rgba(214,178,110,.65);
    --card-frame-shadow:0 0 0 1px rgba(214,178,110,.25), inset 0 0 12px rgba(0,0,0,.35);
    --card-title-bg:linear-gradient(180deg, rgba(10,10,10,0), rgba(10,10,10,.85));
    --card-title-font:"Cinzel","Garamond","Georgia",serif;
    --card-title-shadow:0 2px 6px rgba(0,0,0,.6);
    --card-title-letter:.12em;
    --card-title-transform:uppercase;
    --card-title-border:rgba(214,178,110,.6);
    --card-number-letter:.16em;
    --card-number-transform:uppercase;
    --card-number-bg:rgba(18,12,6,.78);
    --card-number-border:rgba(214,178,110,.6);
  }
  body[data-card-theme="wood"]{
    --card-overlay:repeating-linear-gradient(45deg, rgba(104,68,36,.28) 0 8px, rgba(74,49,27,.28) 8px 16px),
      radial-gradient(circle at 50% 20%, rgba(162,111,58,.25), transparent 60%);
    --card-overlay-opacity:.5;
    --card-frame:rgba(141,99,58,.9);
    --card-frame-shadow:inset 0 0 0 2px rgba(63,41,24,.5), inset 0 8px 18px rgba(0,0,0,.35);
    --card-title-bg:linear-gradient(180deg, rgba(40,26,16,0), rgba(40,26,16,.85));
    --card-title-font:"Cormorant Garamond","Garamond","Georgia",serif;
    --card-title-color:#f0e6d6;
    --card-title-letter:.04em;
    --card-title-transform:none;
    --card-title-border:rgba(141,99,58,.85);
    --card-number-letter:.08em;
    --card-number-transform:none;
    --card-number-bg:rgba(52,34,20,.85);
    --card-number-border:rgba(141,99,58,.85);
  }
  body[data-card-theme="wood"] .card-title{
    text-transform:none;
    letter-spacing:.02em;
  }
  body[data-card-theme="neon"]{
    --card-overlay:radial-gradient(circle at 20% 20%, rgba(55,226,255,.25), transparent 45%),
      radial-gradient(circle at 80% 0%, rgba(255,82,205,.18), transparent 45%);
    --card-overlay-opacity:.65;
    --card-frame:rgba(70,240,255,.9);
    --card-frame-shadow:0 0 14px rgba(70,240,255,.45), inset 0 0 12px rgba(255,82,205,.25);
    --card-title-bg:linear-gradient(90deg, rgba(7,7,18,.7), rgba(7,7,18,.2));
    --card-title-font:"Orbitron","Trebuchet MS",sans-serif;
    --card-title-color:#e6fbff;
    --card-title-shadow:0 0 10px rgba(70,240,255,.65);
    --card-title-letter:.22em;
    --card-title-transform:uppercase;
    --card-title-border:rgba(70,240,255,.8);
    --card-number-letter:.22em;
    --card-number-transform:uppercase;
    --card-number-bg:rgba(6,8,20,.85);
    --card-number-border:rgba(70,240,255,.8);
  }
  body[data-card-theme="neon"] .card-title{
    letter-spacing:.18em;
  }
  .meaning{
    font-family:"Spectral","Georgia",serif;
    font-size:13px;
    line-height:1.4;
  }
  .meaning-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
    margin-bottom:8px;
  }
  .meaning-title{
    font-size:16px;
    letter-spacing:.04em;
  }
  .meaning-pill{
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.15);
    font-size:11px;
    text-transform:uppercase;
    letter-spacing:.08em;
    color:var(--neutral);
    background:rgba(10,12,10,.6);
  }
  .meaning-meta{
    margin-top:6px;
    font-size:12px;
    color:var(--muted);
  }
  .meaning-block{
    padding:8px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.08);
    background:rgba(8,12,10,.55);
    margin-top:8px;
  }
  .theme-bars{
    margin-top:8px;
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .theme-bar{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:11px;
    color:var(--muted);
  }
  .theme-bar .emph{
    font-weight:700;
    color:var(--text);
  }
  .theme-bar .label{
    min-width:90px;
    text-transform:capitalize;
  }
  .theme-bar .icon{
    width:16px;
    text-align:center;
    color:var(--neutral-2);
    font-weight:700;
  }
  .theme-bar .track{
    flex:1;
    height:6px;
    border-radius:999px;
    background:rgba(255,255,255,.08);
    overflow:hidden;
  }
  .theme-bar .fill{
    height:100%;
    background:linear-gradient(90deg, rgba(107,212,162,.8), rgba(214,178,110,.8));
    border-radius:999px;
  }
  textarea, input{
    width:100%;
    padding:6px 8px;
    border-radius:8px;
    border:1px solid var(--line);
    background:#0c1511;
    color:var(--text);
    font-family:inherit;
    font-size:12px;
  }
  .narration-input{
    min-height:110px;
    border-radius:12px;
    background:rgba(8,12,10,.6);
    border:1px solid rgba(214,178,110,.25);
  }
  .narration-presets{
    display:flex;
    gap:6px;
    flex-wrap:wrap;
    margin-bottom:6px;
  }
  .narration-presets .btn{
    padding:4px 10px;
    font-size:11px;
  }
  .narration-status{
    font-size:12px;
    color:var(--muted);
    margin-top:6px;
  }
  .narration{
    max-height:220px;
    overflow:auto;
    border-top:1px solid var(--line);
    margin-top:10px;
    padding-top:8px;
  }
  .deck-pile-wrap{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:10px;
  }
  .deck-pile{
    width:64px;
    aspect-ratio:3/4.2;
    border-radius:10px;
    border:1px solid var(--line);
    background:
      radial-gradient(circle at 20% 20%, rgba(214,178,110,.18), transparent 40%),
      linear-gradient(135deg, #1b2d26, #132018);
    background-size:cover;
    background-position:center;
    box-shadow:0 6px 16px rgba(0,0,0,.35);
  }
  .deck-label{
    font-size:11px;
    letter-spacing:.12em;
    text-transform:uppercase;
    color:var(--muted);
  }
  .fly-card{
    position:fixed;
    left:0;
    top:0;
    border-radius:10px;
    border:1px solid var(--line);
    background-size:cover;
    background-position:center;
    box-shadow:0 10px 24px rgba(0,0,0,.35);
    pointer-events:none;
    transition:transform .6s ease, opacity .6s ease;
    z-index:9999;
  }
  .narration .line{font-size:12px;margin-bottom:6px}
  .chip{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid var(--line);
    font-size:11px;
    color:var(--muted);
  }
  .help-toggle{
    cursor:pointer;
    color:var(--accent);
    margin-left:4px;
    font-size:11px;
  }
  .hidden{display:none}
  .modal{
    position:fixed;
    inset:0;
    background:rgba(6,10,8,.7);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:20;
  }
  .modal.show{display:flex}
  .modal-card{
    width:min(520px, 92vw);
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:16px;
    padding:16px;
  }
  @media (max-width: 1200px){
    .wrap{
      grid-template-columns:minmax(240px, 1fr) minmax(300px, 2fr);
    }
    .panel:nth-child(3){
      grid-column:1 / -1;
      max-height:40vh;
    }
  }
  @media (max-width: 900px){
    .wrap{
      grid-template-columns:1fr;
      height:auto;
      overflow:auto;
    }
    body{
      overflow:auto;
    }
  }
  .modal-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:10px;
  }
  .modal-title{
    font-size:14px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--muted);
  }
</style>

<header>
  <div class="sigil"></div>
  <h1>Tarot Priestess</h1>
  <span class="chip" id="sessionStatus">loading</span>
</header>
<div class="subhead">
  <span><span class="status-dot" id="connDot"></span><span id="connStatus">connecting</span></span>
  <span>Join: <strong id="joinCode">{JOIN}</strong></span>
  <span>Session: <strong id="sessionId">-</strong></span>
  <span>Deck: <strong id="deckId">-</strong></span>
  <span>Spread: <strong id="spreadId">-</strong></span>
</div>

<div class="wrap">
  <div class="panel session">
    <h2>Session</h2>
    <div class="stack">
    <div class="muted">Spread help: <span class="help-toggle" id="spreadHelp">(?)</span></div>
    </div>
    <div class="muted hidden" id="spreadNote">
      Spread = the card layout for the reading. Single: one card. Tree: Root/Trunk/Canopy. Cross: Past/Present/Future.
    </div>
    <div style="height:10px"></div>
    <input id="tokenInput" class="hidden" />
    <h3>Session lifecycle</h3>
    <div class="row" style="margin-top:6px">
      <button class="btn icon" id="btnNewSession">+ New session</button>
      <button class="btn danger" id="btnFinish">Finish</button>
    </div>
    <div class="row">
      <button class="btn icon" id="btnOpenPlayer">Open player view</button>
    </div>
    <h3>Ritual flow</h3>
    <div class="row" style="margin-top:6px">
      <button class="btn primary" id="btnStart">Start Reading</button>
      <button class="btn warn" id="btnShuffle">Shuffle</button>
    </div>
    <div class="row">
      <button class="btn icon" id="btnDraw">Draw</button>
      <button class="btn icon" id="btnRevealNext">Reveal Next</button>
    </div>
    <div class="error-bar" id="actionError"></div>
    <div style="height:12px"></div>
    <h2>Positions</h2>
    <div id="positionsList" class="stack"></div>
  </div>

  <div class="panel spread">
    <h2>Spread</h2>
    <div class="deck-pile-wrap">
      <div class="deck-pile" id="deckPile"></div>
      <div class="deck-label">Deck</div>
    </div>
    <div id="cardGrid" class="card-grid"></div>
    <div class="analysis-panel" id="analysisPanel">
      <h3>Visible Card Focus</h3>
      <div class="muted">Draw cards to see focused notes.</div>
    </div>
  </div>

  <div class="panel meaning">
    <h2>Meaning</h2>
    <div id="meaningPanel" class="meaning muted">Select a card to see details.</div>
    <div style="height:10px"></div>
    <label class="muted">Custom narration</label>
    <div class="narration-presets">
      <button class="btn" data-narration="Whispered:">Whispered</button>
      <button class="btn" data-narration="Formal:">Formal</button>
      <button class="btn" data-narration="Poetic:">Poetic</button>
    </div>
    <textarea id="narrationInput" class="narration-input" rows="4" placeholder="Write your narration line..."></textarea>
    <button class="btn accent" id="btnNarrate">Send narration</button>
    <div class="narration-status" id="narrationStatus"></div>
    <div class="narration" id="narrationFeed"></div>
  </div>
</div>

<div class="modal" id="newSessionModal">
  <div class="modal-card">
    <div class="modal-header">
      <div class="modal-title">New Session</div>
      <button class="btn" id="newSessionClose">Close</button>
    </div>
    <label class="muted">Deck</label>
    <select id="newSessionDeck"></select>
    <label class="muted" style="margin-top:8px">Spread</label>
    <select id="newSessionSpread"></select>
    <div style="height:8px"></div>
    <button class="btn accent" id="newSessionCreate">Create & Open</button>
    <div class="muted" id="newSessionStatus" style="margin-top:8px"></div>
  </div>
</div>

<script>
  const joinCode = "{JOIN}";
  const qs = new URLSearchParams(location.search);
  const themeParam = qs.get("card_theme");
  const themeLocked = qs.has("card_theme");
  document.body.dataset.cardTheme = themeParam || "classic";

  function toggleFullscreen(target){
    if (!target || !target.requestFullscreen){
      return;
    }
    if (document.fullscreenElement){
      if (document.fullscreenElement === target){
        document.exitFullscreen();
      }
      return;
    }
    target.requestFullscreen().catch(() => {});
  }
  const tokenInput = document.getElementById("tokenInput");
  const storedTokenKey = "tarot_token_" + joinCode;
  tokenInput.value = qs.get("token") || localStorage.getItem(storedTokenKey) || "";
  tokenInput.addEventListener("change", () => localStorage.setItem(storedTokenKey, tokenInput.value.trim()));

  const stateEls = {
    status: document.getElementById("sessionStatus"),
    sessionId: document.getElementById("sessionId"),
    deckId: document.getElementById("deckId"),
    spreadId: document.getElementById("spreadId"),
    positions: document.getElementById("positionsList"),
    grid: document.getElementById("cardGrid"),
    meaning: document.getElementById("meaningPanel"),
    narration: document.getElementById("narrationFeed"),
  };

  const connDot = document.getElementById("connDot");
  const connStatus = document.getElementById("connStatus");
  const actionError = document.getElementById("actionError");
  const deckPile = document.getElementById("deckPile");
  const newSessionModal = document.getElementById("newSessionModal");
  const newSessionDeck = document.getElementById("newSessionDeck");
  const newSessionSpread = document.getElementById("newSessionSpread");
  const newSessionStatus = document.getElementById("newSessionStatus");
  const narrationStatus = document.getElementById("narrationStatus");
  const btnStart = document.getElementById("btnStart");
  const btnFinish = document.getElementById("btnFinish");
  const btnShuffle = document.getElementById("btnShuffle");
  const btnDraw = document.getElementById("btnDraw");
  const btnRevealNext = document.getElementById("btnRevealNext");

  let currentState = null;
  let selectedPosition = null;
  let sse = null;
  let lastDrawCount = 0;
  const pendingDraws = [];
  const pendingReveals = new Set();
  let houseThemes = {};
  let numberDefs = {};

  function parseRoman(value){
    const roman = String(value || "").trim().toUpperCase();
    if (!roman) return NaN;
    const map = {I:1, V:5, X:10, L:50, C:100, D:500, M:1000};
    let total = 0;
    let prev = 0;
    for (let i = roman.length - 1; i >= 0; i -= 1){
      const num = map[roman[i]];
      if (!num) return NaN;
      if (num < prev){
        total -= num;
      } else {
        total += num;
        prev = num;
      }
    }
    return total;
  }

  function parseCardNumber(value){
    const text = String(value).trim();
    if (!text) return NaN;
    if (/^\d+$/.test(text)) return parseInt(text, 10);
    return parseRoman(text);
  }

  function positionIcon(pos){
    const key = `${pos.id || ""} ${pos.label || ""}`.toLowerCase();
    if (key.includes("root")) return "o";
    if (key.includes("crown")) return "^";
    if (key.includes("trunk")) return "|";
    if (key.includes("branch")) return ">";
    if (key.includes("leaf")) return "*";
    if (key.includes("seed")) return "+";
    if (key.includes("past")) return "<";
    if (key.includes("present")) return "o";
    if (key.includes("future")) return ">";
    return "~";
  }

  function positionIcon(pos){
    const key = `${pos.id || ""} ${pos.label || ""}`.toLowerCase();
    if (key.includes("root")) return "o";
    if (key.includes("crown")) return "^";
    if (key.includes("trunk")) return "|";
    if (key.includes("branch")) return ">";
    if (key.includes("leaf")) return "*";
    if (key.includes("seed")) return "+";
    if (key.includes("past")) return "<";
    if (key.includes("present")) return "o";
    if (key.includes("future")) return ">";
    return "~";
  }

  function toRoman(num){
    const n = Number(num);
    if (!Number.isFinite(n) || n <= 0) return "";
    const map = [
      [1000, "M"], [900, "CM"], [500, "D"], [400, "CD"],
      [100, "C"], [90, "XC"], [50, "L"], [40, "XL"],
      [10, "X"], [9, "IX"], [5, "V"], [4, "IV"], [1, "I"]
    ];
    let out = "";
    let remaining = Math.floor(n);
    map.forEach(([val, sym]) => {
      while (remaining >= val){
        out += sym;
        remaining -= val;
      }
    });
    return out;
  }

  function formatCardNumber(value){
    if (String(value || "").trim() === "0") return "0";
    const num = parseCardNumber(value);
    if (num === 0) return "0";
    return num ? toRoman(num) || String(value || "") : "";
  }

  function renderNumberInfo(value){
    const num = parseCardNumber(value);
    if (!Number.isFinite(num)) return "";
    const digits = String(num).split("").map(d => parseInt(d, 10));
    let sum = digits.reduce((acc, d) => acc + d, 0);
    while (sum > 10){
      sum = String(sum).split("").reduce((acc, d) => acc + parseInt(d, 10), 0);
    }
    const picks = [];
    digits.forEach(d => { if (!picks.includes(d)) picks.push(d); });
    if (sum > 0 && !picks.includes(sum)) picks.push(sum);
    if (num === 0 && !picks.includes(0)) picks.push(0);
    const rows = picks.map(pick => {
      const entry = numberDefs[pick] || {};
      const label = entry.label ? ` - ${entry.label}` : "";
      const meaning = entry.meaning || "";
      return `<div><strong>${pick}${label}</strong><br>${meaning}</div>`;
    }).join("<div style=\"height:6px\"></div>");
    return rows ? `<div style="margin-top:8px">${rows}</div>` : "";
  }

  function authHeaders(){
    return {"Content-Type":"application/json", "X-Tarot-Token": tokenInput.value.trim()};
  }

  function getPlayerUrl(){
    const url = new URL(`/tarot/session/${encodeURIComponent(joinCode)}`, window.location.origin);
    url.searchParams.set("view", "player");
    return url.toString();
  }

  document.getElementById("btnOpenPlayer").addEventListener("click", () => {
    window.open(getPlayerUrl(), "_blank");
  });

  async function fetchState(){
    const res = await fetch(`/api/tarot/sessions/${joinCode}/state?view=priestess`);
    const data = await res.json();
    if (!data.ok) return;
    currentState = data.state;
    render();
  }

  function render(){
    if (!currentState) return;
    const s = currentState.session;
    if (!themeLocked){
      const deckTheme = currentState.deck ? currentState.deck.theme : "";
      document.body.dataset.cardTheme = deckTheme || "classic";
    }
    stateEls.status.textContent = s.status || "created";
    stateEls.sessionId.textContent = s.session_id;
    stateEls.deckId.textContent = s.deck_id;
    stateEls.spreadId.textContent = s.spread_id;
    const backUrl = currentState.deck && currentState.deck.back_image ? currentState.deck.back_image : "";
    if (deckPile){
      if (backUrl){
        deckPile.style.backgroundImage = `linear-gradient(135deg, rgba(12,18,32,.4), rgba(12,18,32,.6)), url('${backUrl}')`;
      } else {
        deckPile.style.backgroundImage = "";
      }
    }

    stateEls.positions.innerHTML = "";
    currentState.spread.positions.forEach(pos => {
      const draw = currentState.draw.find(d => d.position_id === pos.id);
      const el = document.createElement("div");
      el.className = "analysis-card";
      const icon = positionIcon(pos);
      const name = document.createElement("div");
      name.innerHTML = `<strong>${icon} ${pos.label}</strong>`;
      const prompt = document.createElement("div");
      prompt.className = "muted";
      prompt.textContent = pos.prompt || "Waiting for meaning.";
      const status = document.createElement("div");
      status.className = "muted";
      if (draw && draw.revealed){
        status.textContent = "Revealed";
        el.style.opacity = "1";
      } else if (draw){
        status.textContent = "Drawn";
        el.style.opacity = "0.7";
      } else {
        status.textContent = "Unrevealed";
        el.style.opacity = "0.5";
      }
      if (selectedPosition === pos.id){
        el.style.borderColor = "rgba(107,212,162,.5)";
      }
      el.style.cursor = "pointer";
      el.addEventListener("click", () => selectCard(pos.id));
      el.appendChild(name);
      el.appendChild(prompt);
      el.appendChild(status);
      stateEls.positions.appendChild(el);
    });

    stateEls.grid.innerHTML = "";
    currentState.spread.positions.forEach(pos => {
      const draw = currentState.draw.find(d => d.position_id === pos.id);
      const slot = document.createElement("div");
      slot.className = "card-slot";
      const label = document.createElement("div");
      label.className = "label";
      label.textContent = `${pos.label} - ${pos.prompt || ""}`;
      slot.appendChild(label);
      const tag = document.createElement("div");
      tag.className = "position-tag";
      tag.textContent = `${pos.label}${pos.prompt ? " - " + pos.prompt : ""}`;
      slot.appendChild(tag);

      if (draw){
        const cardWrap = document.createElement("div");
        const shouldReveal = draw && draw.revealed;
        const animateReveal = shouldReveal && pendingReveals.has(pos.id);
        const animateDraw = pendingDraws.includes(pos.id);
        cardWrap.className = "card" + (shouldReveal && !animateReveal ? " revealed" : "");
        if (animateDraw){
          cardWrap.classList.add("dealt-hidden");
        }
        cardWrap.dataset.positionId = pos.id;
      const inner = document.createElement("div");
      inner.className = "inner";
      if (draw && draw.reversed){
        inner.classList.add("reversed");
      }
        const back = document.createElement("div");
        back.className = "face back";
        if (backUrl){
          back.style.backgroundImage = `linear-gradient(135deg, rgba(12,18,32,.4), rgba(12,18,32,.6)), url('${backUrl}')`;
          back.style.backgroundSize = "cover";
          back.style.backgroundPosition = "center";
        }
        const front = document.createElement("div");
        front.className = "face front";
        if (draw && draw.card && draw.card.image){
          const img = document.createElement("img");
          img.src = draw.card.image;
          front.appendChild(img);
        }
        if (draw && draw.card && draw.card.number !== undefined && draw.card.number !== null){
          const number = document.createElement("div");
          number.className = "card-number";
          number.textContent = formatCardNumber(draw.card.number);
          front.appendChild(number);
        }
        if (draw && draw.card && draw.card.name){
          const title = document.createElement("div");
          title.className = "card-title";
          title.textContent = draw.card.name;
          front.appendChild(title);
        }
        inner.appendChild(back);
        inner.appendChild(front);
        cardWrap.appendChild(inner);
        if (draw && draw.revealed){
          slot.classList.add("revealed");
        }
        cardWrap.addEventListener("click", async (event) => {
          event.stopPropagation();
          if (draw && !draw.revealed){
            await postControl(
              `/api/tarot/sessions/${currentState.session.session_id}/reveal`,
              {token: tokenInput.value, position_id: pos.id}
            );
          }
          const fullscreenTarget = cardWrap.closest(".card-slot") || cardWrap;
          toggleFullscreen(fullscreenTarget);
          selectCard(pos.id);
        });
        slot.appendChild(cardWrap);
        if (animateReveal){
          requestAnimationFrame(() => {
            cardWrap.classList.add("revealed");
          });
          pendingReveals.delete(pos.id);
        }
      }
      stateEls.grid.appendChild(slot);
    });

    const newDrawCount = (currentState.draw || []).length;
    if (newDrawCount > lastDrawCount){
      const lastDraw = currentState.draw[newDrawCount - 1];
      if (lastDraw && lastDraw.position_id){
        selectedPosition = lastDraw.position_id;
      }
    }
    lastDrawCount = newDrawCount;

    renderNarration();
    if (selectedPosition) updateMeaning(selectedPosition);
    renderAnalysis();
    if (pendingDraws.length){
      pendingDraws.splice(0).forEach(positionId => animateDraw(positionId));
    }
    updateControlAvailability();
  }

  function updateControlAvailability(){
    if (!currentState || !currentState.session){
      [btnStart, btnFinish, btnShuffle, btnDraw, btnRevealNext].forEach(btn => {
        if (btn) btn.disabled = true;
      });
      return;
    }
    const status = currentState.session.status || "created";
    const positions = currentState.spread ? currentState.spread.positions || [] : [];
    const draws = currentState.draw || [];
    const drawnIds = new Set(draws.map(d => d.position_id));
    const remainingDraws = positions.filter(p => !drawnIds.has(p.id)).length;
    const remainingReveals = draws.filter(d => !d.revealed).length;
    if (btnStart) btnStart.disabled = !(status === "created" || status === "ready");
    if (btnFinish) btnFinish.disabled = ["finished", "ended", "closed"].includes(status);
    if (btnShuffle) btnShuffle.disabled = !(status === "created" || status === "ready");
    if (btnDraw) btnDraw.disabled = remainingDraws === 0;
    if (btnRevealNext) btnRevealNext.disabled = remainingReveals === 0;
  }

  function animateDraw(positionId){
    if (!deckPile) return;
    const target = stateEls.grid.querySelector(`[data-position-id="${positionId}"]`);
    if (!target) return;
    const from = deckPile.getBoundingClientRect();
    const to = target.getBoundingClientRect();
    const fly = document.createElement("div");
    fly.className = "fly-card";
    fly.style.width = `${from.width}px`;
    fly.style.height = `${from.height}px`;
    fly.style.left = `${from.left}px`;
    fly.style.top = `${from.top}px`;
    fly.style.backgroundImage = deckPile.style.backgroundImage || "";
    document.body.appendChild(fly);
    const dx = to.left - from.left;
    const dy = to.top - from.top;
    const scaleX = to.width / from.width;
    const scaleY = to.height / from.height;
    requestAnimationFrame(() => {
      fly.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
      fly.style.opacity = "0";
    });
    fly.addEventListener("transitionend", () => {
      const card = stateEls.grid.querySelector(`[data-position-id="${positionId}"]`);
      if (card){
        card.classList.remove("dealt-hidden");
      }
      fly.remove();
    }, {once:true});
  }

  function renderNarration(){
    stateEls.narration.innerHTML = "";
    (currentState.narration || []).slice().reverse().forEach(n => {
      const line = document.createElement("div");
      line.className = "line";
      line.textContent = n.text;
      stateEls.narration.appendChild(line);
    });
  }

  function selectCard(positionId){
    selectedPosition = positionId;
    updateMeaning(positionId);
  }

  function renderThemeBars(themes, highlightSet){
    const items = Object.entries(themes || {}).filter(([, value]) => Number(value) > 0);
    if (!items.length){
      return "";
    }
    items.sort((a, b) => Number(b[1]) - Number(a[1]));
    const top = items.slice(0, 3);
    const max = Math.max(...top.map(([, value]) => Number(value)));
    const rows = top.map(([name, value]) => {
      const width = Math.max(6, Math.round((Number(value) / max) * 100));
      const label = (name || "").replace(/_/g, " ");
      const highlight = highlightSet && highlightSet.has(name);
      const icon = themeIcon(name);
      return `
        <div class="theme-bar">
          <div class="icon">${icon}</div>
          <div class="label ${highlight ? "emph" : ""}">${label}</div>
          <div class="track"><div class="fill" style="width:${width}%"></div></div>
          <div class="${highlight ? "emph" : ""}">${value}</div>
        </div>
      `;
    }).join("");
    return `<div class="theme-bars">${rows}</div>`;
  }

  function themeIcon(name){
    const key = String(name || "").toLowerCase();
    if (key.includes("balance")) return "=";
    if (key.includes("fate")) return "*";
    if (key.includes("cycle")) return "~";
    if (key.includes("shadow")) return "o";
    if (key.includes("light")) return "^";
    if (key.includes("will")) return ">";
    if (key.includes("growth")) return "+";
    return ".";
  }

  function sumThemes(cardThemes, suitThemes){
    const out = {};
    [cardThemes, suitThemes].forEach(src => {
      if (!src) return;
      Object.entries(src).forEach(([key, value]) => {
        const num = Number(value) || 0;
        if (!num) return;
        out[key] = (out[key] || 0) + num;
      });
    });
    return out;
  }

  function updateMeaning(positionId){
    const draw = currentState.draw.find(d => d.position_id === positionId);
    const pos = currentState.spread.positions.find(p => p.id === positionId);
    if (!draw || !draw.card){
      stateEls.meaning.innerHTML = `<div class="muted">${pos ? pos.label : "Card"}: not drawn.</div>`;
      return;
    }
    const card = draw.card;
    const title = card.name || "Unknown card";
    const orientation = draw.reversed ? "Reversed" : "Upright";
    const upright = card.upright || "";
    const reversed = card.reversed || "";
    const house = card.house ? `<div class="muted">Suit: ${card.house}</div>` : "<div class=\"muted\">Suit: -</div>";
    const prompt = pos ? `<div class="muted">${pos.label} - ${pos.prompt || "No prompt."}</div>` : "";
    const suitThemes = card.house && houseThemes[card.house] ? houseThemes[card.house] : {};
    const highlight = card.house && suitThemes ? new Set(Object.keys(suitThemes)) : null;
    const combinedThemes = sumThemes(card.themes, suitThemes);
    const themes = renderThemeBars(combinedThemes, highlight);
    const numbers = renderNumberInfo(card.number);
    const meaningBlock = `
      <div class="meaning-block">
        <div><strong>Upright</strong></div>
        <div class="meaning-text">${upright || "-"}</div>
      </div>
      <div class="meaning-block">
        <div><strong>Reversed</strong></div>
        <div class="meaning-text">${reversed || "-"}</div>
      </div>
    `;
    stateEls.meaning.innerHTML = `
      <div class="meaning-header">
        <div class="meaning-title">${title}</div>
        <div class="meaning-pill">${orientation}</div>
      </div>
      ${prompt}
      <div class="meaning-meta">${house}</div>
      ${themes}
      ${numbers}
      <div style="margin-top:6px">${meaningBlock}</div>
    `;
  }

  function renderAnalysis(){
    const panel = document.getElementById("analysisPanel");
    if (!panel || !currentState){
      return;
    }
    const draws = (currentState.draw || []).filter(d => d.revealed);
    if (!draws.length){
      panel.innerHTML = `<h3>Visible Card Focus</h3><div class="muted">Reveal cards to see focused notes.</div>`;
      return;
    }
    const repeatTerms = collectRepeatTerms(draws);
    const rows = draws.map(draw => {
      const card = draw.card || {};
      const name = card.name || "Card";
      const flavor = card.flavor_text ? `<div class="muted meaning-text">${card.flavor_text}</div>` : "";
      const house = card.house ? `Suit: ${card.house}` : "Suit: -";
      const number = (card.number !== undefined && card.number !== null) ? `Number: ${formatCardNumber(card.number)}` : "Number: -";
      const suitThemes = card.house && houseThemes[card.house] ? houseThemes[card.house] : {};
      const highlight = card.house && suitThemes ? new Set(Object.keys(suitThemes)) : null;
      const combinedThemes = sumThemes(card.themes, suitThemes);
      const themeItems = Object.entries(combinedThemes || {}).filter(([, v]) => Number(v) > 0);
      const themeList = themeItems.map(([k, v]) => {
        const label = (k || "").replace(/_/g, " ");
        if (highlight && highlight.has(k)){
          return `<strong>${label} (${v})</strong>`;
        }
        return `${label} (${v})`;
      }).join(", ");
      const numbers = renderNumberInfo(card.number);
      const activeMeaning = draw.reversed ? (card.reversed || "") : (card.upright || "");
      const highlightedMeaning = highlightRepeatedTerms(activeMeaning, repeatTerms);
      const meaningLine = draw.reversed
        ? `<div class="muted meaning-text"><strong>Reversed:</strong> ${highlightedMeaning || "-"}</div>`
        : (activeMeaning ? `<div class="muted meaning-text">${highlightedMeaning}</div>` : "");
      return `
        <div class="analysis-card">
          <div><strong>${name}</strong> ${draw.reversed ? "(reversed)" : ""}</div>
          ${flavor}
          <div class="muted">${house} - ${number}</div>
          ${themeList ? `<div class="muted">Focus: ${themeList}</div>` : ""}
          ${numbers}
          ${meaningLine}
        </div>
      `;
    }).join("");
    panel.innerHTML = `<h3>Visible Card Focus</h3>${rows}`;
  }

  const STOP_WORDS = new Set([
    "a","an","the","and","or","but","so","to","of","in","on","for","with","from","by","as","at","be","is","are","was","were",
    "it","its","this","that","these","those","your","you","we","our","us","i","me","my","they","their","them"
  ]);

  function normalizeTerms(text){
    const raw = (text || "").toLowerCase();
    return raw.split(/[^a-z0-9]+/).filter(word => word.length > 3 && !STOP_WORDS.has(word));
  }

  function collectRepeatTerms(draws){
    const counts = {};
    draws.forEach(draw => {
      const card = draw.card || {};
      const active = draw.reversed ? (card.reversed || "") : (card.upright || "");
      const seen = new Set(normalizeTerms(active));
      seen.forEach(term => {
        counts[term] = (counts[term] || 0) + 1;
      });
    });
    return new Set(Object.keys(counts).filter(term => counts[term] >= 2));
  }

  function highlightRepeatedTerms(text, repeats){
    if (!text || !repeats || !repeats.size){
      return text || "";
    }
    return text.replace(/\b([A-Za-z0-9]+)\b/g, (match) => {
      const key = match.toLowerCase();
      if (repeats.has(key)){
        return `<span class="term-hit">${match}</span>`;
      }
      return match;
    });
  }

  async function postControl(path, body){
    const res = await fetch(path, {method:"POST", headers:authHeaders(), body:JSON.stringify(body || {})});
    if (!res.ok){
      const data = await res.json().catch(() => ({}));
      actionError.textContent = data.error || "Request failed.";
      actionError.style.display = "block";
      return false;
    }
    actionError.style.display = "none";
    await fetchState();
    return true;
  }

  document.getElementById("btnStart").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/start`, {token: tokenInput.value});
  };
  document.getElementById("btnFinish").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/finish`, {token: tokenInput.value});
  };
  document.getElementById("btnShuffle").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/shuffle`, {token: tokenInput.value});
  };
  document.getElementById("btnDraw").onclick = async () => {
    if (!currentState){
      await fetchState();
    }
    const positions = (currentState && currentState.spread && currentState.spread.positions) || [];
    const drawn = (currentState && currentState.draw) || [];
    const drawnIds = new Set(drawn.map(d => d.position_id));
    const remaining = positions.filter(p => !drawnIds.has(p.id)).length;
    const remainingPositions = positions.filter(p => !drawnIds.has(p.id));
    if (remainingPositions.length){
      remainingPositions.forEach(p => pendingDraws.push(p.id));
    }
    if (remaining > 0){
      await postControl(
        `/api/tarot/sessions/${currentState.session.session_id}/draw`,
        {token: tokenInput.value, count: remaining}
      );
    }
  };
  document.getElementById("btnRevealNext").onclick = async () => {
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/reveal`, {token: tokenInput.value, mode:"next"});
  };
  document.getElementById("btnNarrate").onclick = async () => {
    const text = document.getElementById("narrationInput").value.trim();
    if (!text) return;
    await postControl(`/api/tarot/sessions/${currentState.session.session_id}/narrate`, {token: tokenInput.value, text});
    document.getElementById("narrationInput").value = "";
    if (narrationStatus){
      narrationStatus.textContent = "Narration shared.";
      setTimeout(() => {
        narrationStatus.textContent = "";
      }, 1800);
    }
  };

  document.querySelectorAll("[data-narration]").forEach(btn => {
    btn.addEventListener("click", () => {
      const preset = btn.getAttribute("data-narration") || "";
      const input = document.getElementById("narrationInput");
      if (!input) return;
      const text = input.value.trim();
      input.value = text ? `${preset} ${text}` : `${preset} `;
      input.focus();
    });
  });

  function connectSSE(){
    if (sse){
      sse.close();
    }
    const src = new EventSource(`/api/tarot/sessions/${joinCode}/stream?view=priestess`);
    sse = src;
    src.onopen = () => {
      connDot.className = "status-dot";
      connStatus.textContent = "connected";
    };
    src.onerror = () => {
      connDot.className = "status-dot warn";
      connStatus.textContent = "reconnecting";
    };
    src.onmessage = (ev) => {
      try{
        const payload = JSON.parse(ev.data);
        if (payload.type === "CARD_DRAWN" && payload.data && payload.data.position_id){
          pendingDraws.push(payload.data.position_id);
        }
        if (payload.type === "CARD_REVEALED" && payload.data && payload.data.position_id){
          pendingReveals.add(payload.data.position_id);
        }
      }catch(err){}
      fetchState();
    };
  }

  document.getElementById("spreadHelp").addEventListener("click", () => {
    document.getElementById("spreadNote").classList.toggle("hidden");
  });

  async function loadNumbers(){
    try{
      const res = await fetch("/api/tarot/numbers");
      const data = await res.json();
      numberDefs = {};
      (data.numbers || []).forEach(n => {
        numberDefs[n.number] = {label: n.label || "", meaning: n.meaning || ""};
      });
    }catch(err){
      numberDefs = {};
    }
  }

  async function loadHouses(){
    try{
      const res = await fetch("/api/tarot/houses");
      const data = await res.json();
      houseThemes = {};
      (data.houses || []).forEach(h => {
        houseThemes[h.id] = h.themes || {};
      });
    }catch(err){
      houseThemes = {};
    }
  }

  async function loadSessionOptions(){
    try{
      const decksRes = await fetch("/api/tarot/decks/public");
      const decksData = await decksRes.json();
      const decks = decksData.decks || [];
      newSessionDeck.innerHTML = "";
      decks.forEach(d => {
        const opt = document.createElement("option");
        opt.value = d.deck_id;
        opt.textContent = d.name || d.deck_id;
        newSessionDeck.appendChild(opt);
      });
      if (!decks.length){
        const opt = document.createElement("option");
        opt.value = "elf-classic";
        opt.textContent = "elf-classic";
        newSessionDeck.appendChild(opt);
      }
      const spreadsRes = await fetch("/api/tarot/spreads");
      const spreadsData = await spreadsRes.json();
      const spreads = spreadsData.spreads || [];
      newSessionSpread.innerHTML = "";
      spreads.forEach(s => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.label || s.id;
        newSessionSpread.appendChild(opt);
      });
      if (!spreads.length){
        const opt = document.createElement("option");
        opt.value = "single";
        opt.textContent = "single";
        newSessionSpread.appendChild(opt);
      }
    }catch(err){
      newSessionStatus.textContent = "Failed to load decks/spreads.";
    }
  }

  document.getElementById("btnNewSession").addEventListener("click", async () => {
    newSessionStatus.textContent = "";
    try{
      if (currentState && currentState.session && currentState.session.session_id){
        await postControl(`/api/tarot/sessions/${currentState.session.session_id}/finish`, {token: tokenInput.value});
      }
    }catch(err){}
    newSessionModal.classList.add("show");
    await loadSessionOptions();
  });
  document.getElementById("newSessionClose").addEventListener("click", () => {
    newSessionModal.classList.remove("show");
  });
  newSessionModal.addEventListener("click", (event) => {
    if (event.target === newSessionModal){
      newSessionModal.classList.remove("show");
    }
  });
  document.getElementById("newSessionCreate").addEventListener("click", async () => {
    const deck = newSessionDeck.value || "elf-classic";
    const spread = newSessionSpread.value || "single";
    const token = tokenInput.value.trim();
    if (!token){
      newSessionStatus.textContent = "Priestess token required.";
      return;
    }
    newSessionStatus.textContent = "Creating...";
    try{
      const res = await fetch("/api/tarot/sessions/from-priestess", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({
          join_code: joinCode,
          token: token,
          deck_id: deck,
          spread_id: spread,
        })
      });
      const data = await res.json();
      if (!data.ok){
        newSessionStatus.textContent = data.error || "Failed to create.";
        return;
      }
      const url = new URL(`/tarot/session/${encodeURIComponent(data.join_code)}`, window.location.origin);
      url.searchParams.set("view", "priestess");
      url.searchParams.set("token", data.priestess_token);
      window.location.assign(url.toString());
    }catch(err){
      newSessionStatus.textContent = "Failed to create.";
    }
  });

  fetchState();
  connectSSE();
  loadNumbers();
  loadHouses();
</script>




