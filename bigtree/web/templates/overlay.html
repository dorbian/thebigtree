<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Forest Management</title>
    <link rel="icon" href="/icon.png" type="image/png">
    <style>
      :root{
        --bg-1:#0b1611;
        --bg-2:#0e2419;
        --bg-3:#102c1d;
        --panel:#0f1e16;
        --panel-2:#0a1510;
        --ink:#e8f7ef;
        --muted:#9bb6a7;
        --accent:#9de07d;
        --accent-2:#3ccf8e;
        --neutral:#e9e2d2;
        --neutral-2:#c7bfae;
        --line:#1f3a2b;
        --shadow:0 18px 40px rgba(0,0,0,.35);
        --radius:18px;
      }
      *{box-sizing:border-box}
      body{
        margin:0;
        min-height:100vh;
        font-family:"Palatino Linotype","Book Antiqua",serif;
        color:var(--ink);
        background:
          radial-gradient(1200px 600px at 15% -10%, rgba(157,224,125,.18), transparent 60%),
          radial-gradient(900px 700px at 120% 20%, rgba(60,207,142,.18), transparent 60%),
          linear-gradient(160deg, var(--bg-1), var(--bg-2) 55%, var(--bg-3));
        background-repeat:no-repeat;
        background-size:cover;
        background-attachment:fixed;
      }
      body.overlay{
        background:transparent;
      }
      body.overlay .sidebar{
        display:none;
      }
      body.overlay .top{
        display:none;
      }
      body.overlay .app-shell{
        grid-template-columns:1fr;
      }
      body.overlay .content{
        padding:12px;
      }
      .overlay-exit{
        position:fixed;
        top:12px;
        right:12px;
        z-index:9999;
        padding:6px 10px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,.2);
        background:rgba(10,20,16,.8);
        color:var(--ink);
        cursor:pointer;
        display:none;
      }
      body.overlay .overlay-exit{
        display:inline-flex;
        align-items:center;
        gap:6px;
      }
      .hidden{display:none !important}
      .login-screen{
        min-height:100vh;
        display:flex;
        align-items:center;
        justify-content:center;
        padding:24px;
      }
      .login-card{
        width:min(480px,92vw);
        background:rgba(10,16,28,.86);
        border:1px solid var(--line);
        border-radius:var(--radius);
        padding:24px;
        box-shadow:var(--shadow);
        text-align:center;
      }
      .login-title{
        font-family:"Copperplate Gothic","Palatino Linotype",serif;
        font-size:22px;
        letter-spacing:.1em;
        text-transform:uppercase;
        color:var(--accent);
        margin-bottom:6px;
      }
      .login-sub{color:var(--muted);margin-bottom:16px}
      .login-card input{margin:8px 0 16px}
      .app-shell{
        display:grid;
        grid-template-columns:260px 1fr;
        min-height:100vh;
      }
      .sidebar{
        background:rgba(9,14,20,.9);
        border-right:1px solid var(--line);
        padding:20px 16px;
      }
      .sidebar .status{
        margin-top:12px;
      }
      .nav-block{
        padding:10px 0;
      }
      .nav-block + .nav-block{
        margin-top:6px;
        border-top:1px solid rgba(255,255,255,.05);
      }
      .nav-title{
        margin:0 0 6px;
        font-size:11px;
        text-transform:uppercase;
        letter-spacing:.18em;
        color:rgba(155,182,167,.8);
      }
      .menu-item{
        position:relative;
        padding:10px 12px;
        border-radius:12px;
        cursor:pointer;
        color:var(--ink);
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .menu-item:focus-visible{
        outline:2px solid rgba(157,224,125,.5);
        outline-offset:2px;
      }
      .menu-item:hover{
        background:rgba(255,255,255,.04);
      }
      .menu-item.active,
      .menu-item.has-active{
        background:rgba(60,207,142,.18);
        border:1px solid rgba(60,207,142,.4);
      }
      .menu-item.active::before,
      .menu-item.has-active::before{
        content:"";
        position:absolute;
        left:0;
        top:6px;
        bottom:6px;
        width:3px;
        border-radius:8px;
        background:var(--accent);
      }
      .menu-label{
        font-weight:600;
      }
      .menu-actions{
        display:flex;
        gap:8px;
        align-items:center;
      }
      .sidebar{
        display:flex;
        flex-direction:column;
        gap:12px;
      }
      .sidebar-body{
        display:flex;
        flex-direction:column;
        gap:10px;
        flex:1;
      }
      .menu-icons{
        display:grid;
        grid-template-columns:repeat(auto-fit, minmax(40px, 1fr));
        gap:8px;
        align-items:stretch;
        margin-top:6px;
      }
      .menu-icon{
        width:100%;
        aspect-ratio:1;
        height:auto;
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(15,30,22,.9);
        color:var(--ink);
        display:inline-flex;
        align-items:center;
        justify-content:center;
        cursor:pointer;
      }
      .menu-icon.active{
        border-color:rgba(157,224,125,.6);
        background:rgba(60,207,142,.18);
        color:var(--accent);
      }
      .menu-icon svg{
        width:18px;
        height:18px;
        fill:currentColor;
      }
      .icon-group{
        display:inline-flex;
        align-items:center;
        gap:6px;
        padding:6px;
        border-radius:12px;
        border:1px solid rgba(255,255,255,.12);
        background:rgba(15,30,22,.85);
      }
      .icon-group .icon-btn{
        width:38px;
        height:38px;
        padding:6px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,.12);
        background:rgba(8,12,10,.45);
      }
      .icon-btn{
        width:44px;
        height:44px;
        padding:6px;
        border-radius:12px;
        display:inline-flex;
        align-items:center;
        justify-content:center;
      }
      .icon-btn svg{
        width:20px;
        height:20px;
        fill:currentColor;
      }
      .menu-sub{
        margin-left:12px;
        border-left:1px dashed rgba(255,255,255,.08);
        padding-left:10px;
        display:flex;
        flex-direction:column;
        gap:4px;
      }
      .menu-refresh{
        width:auto;
        padding:4px 8px;
        font-size:12px;
        background:transparent;
        border:1px solid rgba(255,255,255,.12);
        color:var(--muted);
        border-radius:8px;
      }
      .menu-refresh svg{
        width:14px;
        height:14px;
        display:block;
        fill:currentColor;
      }
      .menu-refresh:hover{
        border-color:rgba(255,255,255,.25);
        color:var(--ink);
      }
      .menu-selected{
        margin:8px 0 12px 12px;
        font-size:12px;
        color:var(--muted);
      }
      .menu-game{
        font-size:12px;
        color:var(--muted);
        padding:6px 8px 6px 16px;
        border-radius:8px;
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        position:relative;
      }
      .menu-game::before{
        content:"•";
        position:absolute;
        left:6px;
        color:rgba(155,182,167,.7);
      }
      .menu-game:hover{background:rgba(255,255,255,.04)}
      .menu-game:focus-visible{
        outline:2px solid rgba(157,224,125,.5);
        outline-offset:2px;
      }
      .menu-game.active{
        background:rgba(157,224,125,.14);
        color:var(--accent);
      }
      .menu-game-title{
        font-size:12px;
      }
      .menu-game-meta{
        font-size:10px;
        color:rgba(155,182,167,.7);
        white-space:nowrap;
      }
      .menu-icon-grid{
        display:grid;
        grid-template-columns:repeat(3, minmax(0,1fr));
        gap:10px;
      }
      .menu-icon-group{
        display:flex;
        flex-direction:column;
        gap:8px;
        align-items:flex-start;
      }
      .menu-icon-label{
        font-size:10px;
        text-transform:uppercase;
        letter-spacing:.12em;
        color:rgba(155,182,167,.75);
      }
      .status-bar{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        padding:8px 10px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,.08);
        background:rgba(8,12,16,.55);
        font-size:12px;
        color:var(--muted);
      }
      .status-dot{
        width:8px;
        height:8px;
        border-radius:50%;
        background:#7bd2a2;
        box-shadow:0 0 6px rgba(123,210,162,.6);
      }
      .status.ok .status-dot{
        background:#7bd2a2;
        box-shadow:0 0 6px rgba(123,210,162,.6);
      }
      .status.err .status-dot{
        background:#e07070;
        box-shadow:0 0 6px rgba(224,112,112,.6);
      }
      .status.alert .status-dot{
        background:#e0b07d;
        box-shadow:0 0 6px rgba(224,176,125,.6);
      }
      .status-time{
        font-size:10px;
        color:rgba(155,182,167,.7);
      }
      .content{
        padding:24px;
        display:flex;
        flex-direction:column;
        gap:24px;
        animation:fadeup .6s ease both;
      }
      .top{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:16px;
      }
      .brand{
        font-family:"Copperplate Gothic","Palatino Linotype",serif;
        font-size:20px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--accent);
      }
      .brand-user{
        display:flex;
        align-items:center;
        gap:6px;
        font-size:12px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--muted);
        margin-top:-6px;
      }
      .brand-user svg{
        width:20px;
        height:20px;
        fill:currentColor;
      }
      .brand-user img{
        width:20px;
        height:20px;
        border-radius:50%;
        object-fit:cover;
        border:1px solid var(--line);
      }
      .toggle{
        display:flex;
        align-items:center;
        gap:8px;
        font-size:14px;
        color:var(--muted);
      }
      .grid{
        display:grid;
        grid-template-columns:repeat(auto-fit,minmax(320px,1fr));
        gap:18px;
      }
      .panel{
        background:rgba(10,16,28,.86);
        border:1px solid var(--line);
        border-radius:var(--radius);
        padding:18px 18px 16px;
        box-shadow:var(--shadow);
        position:relative;
        overflow:hidden;
        animation:rise .6s ease both;
      }
      .panel.dashboard{
        padding:24px;
      }
      .dashboard-readme{
        max-width:880px;
        line-height:1.5;
      }
      .dashboard-readme h3{
        margin:16px 0 6px;
        font-size:14px;
        text-transform:uppercase;
        letter-spacing:.08em;
        color:var(--accent-2);
      }
      .dashboard-readme p{
        margin:0 0 8px;
        color:var(--muted);
      }
      .dashboard-readme strong{
        color:var(--ink);
      }
      .dash-toc{
        padding:12px;
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(8,12,16,.55);
        margin-bottom:16px;
      }
      .dash-toc ul{
        margin:6px 0 0;
        padding-left:18px;
        color:var(--muted);
        font-size:13px;
      }
      .dash-toc a{
        color:var(--accent);
        text-decoration:none;
      }
      .dash-toc a:hover{text-decoration:underline}
      .dash-section{
        border:1px solid var(--line);
        border-radius:12px;
        background:rgba(8,12,16,.55);
        padding:10px 12px;
        margin-bottom:12px;
      }
      .dash-section summary{
        cursor:pointer;
        font-size:14px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--accent-2);
      }
      .dash-section-body{
        padding-top:10px;
        color:var(--muted);
      }
      .dash-blocks{
        display:grid;
        grid-template-columns:repeat(auto-fit, minmax(220px, 1fr));
        gap:12px;
        margin-bottom:12px;
      }
      .dash-block{
        border:1px solid rgba(255,255,255,.08);
        border-radius:10px;
        padding:10px;
        background:rgba(6,10,18,.4);
      }
      .dash-label{
        font-size:10px;
        letter-spacing:.12em;
        text-transform:uppercase;
        color:rgba(155,182,167,.8);
        margin-bottom:6px;
      }
      .dash-links a{
        display:inline-block;
        margin:2px 8px 2px 0;
        color:var(--accent);
        text-decoration:none;
        font-size:12px;
      }
      .dash-links a:hover{text-decoration:underline}
      .cmd{
        font-family:Consolas, "Courier New", monospace;
        font-size:12px;
        padding:2px 6px;
        border-radius:6px;
        border:1px solid rgba(255,255,255,.12);
        background:rgba(8,12,16,.6);
        color:#d6ffe9;
      }
      .dash-note{
        border-left:3px solid rgba(224,176,125,.6);
        padding:8px 10px;
        background:rgba(30,18,14,.5);
        border-radius:8px;
        color:#f3d7c4;
        margin:8px 0;
      }
      .dash-list{
        margin:6px 0 10px 18px;
        color:var(--muted);
      }
      .dash-tool{
        margin-bottom:10px;
        padding:8px 10px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,.08);
        background:rgba(6,10,18,.35);
      }
      .dash-tool-title{
        font-weight:700;
        color:var(--ink);
        margin-bottom:4px;
      }
      .dash-issue{
        border:1px solid rgba(255,255,255,.08);
        border-radius:10px;
        padding:8px 10px;
        margin-bottom:8px;
        background:rgba(6,10,18,.35);
      }
      .dashboard-grid{
        display:grid;
        grid-template-columns:repeat(auto-fit, minmax(240px, 1fr));
        gap:16px;
      }
      .credit-card{
        border:1px solid var(--line);
        border-radius:14px;
        padding:14px;
        background:rgba(6,10,18,.6);
      }
      .credit-person{
        display:flex;
        align-items:center;
        gap:8px;
        margin:6px 0;
      }
      .credit-avatar{
        width:28px;
        height:28px;
        border-radius:50%;
        border:1px solid rgba(255,255,255,.18);
        object-fit:cover;
        flex:0 0 auto;
      }
      .credit-card h4{
        margin:0 0 6px 0;
        font-size:14px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--accent-2);
      }
      .credit-card p{
        margin:0;
        color:var(--muted);
        font-size:13px;
        line-height:1.4;
      }
      .panel:before{
        content:"";
        position:absolute;
        inset:0;
        background:linear-gradient(120deg, rgba(157,224,125,.12), transparent 45%);
        pointer-events:none;
      }
      .panel h2{
        margin:0 0 10px;
        font-size:18px;
        text-transform:uppercase;
        letter-spacing:.12em;
        color:var(--accent);
      }
      .panel h3{
        margin:16px 0 10px;
        font-size:13px;
        text-transform:uppercase;
        letter-spacing:.14em;
        color:var(--neutral-2);
      }
      #tarotDecksPanel{
        padding:16px;
        font-size:12px;
      }
      #tarotDecksPanel h2{
        font-size:17px;
        margin-bottom:10px;
      }
      #tarotDecksPanel h3{
        font-size:12px;
        margin:12px 0 8px;
      }
      #tarotDecksPanel .row{
        gap:8px;
        margin-bottom:8px;
      }
      #tarotDecksPanel input,
      #tarotDecksPanel select,
      #tarotDecksPanel textarea,
      #tarotDecksPanel button{
        padding:6px 8px;
        font-size:12px;
      }
      #tarotDecksPanel textarea{
        min-height:52px;
      }
      #tarotDecksPanel .theme-grid{
        display:grid;
        gap:8px 12px;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        margin-top:8px;
      }
      #tarotDecksPanel .theme-weight{
        padding:8px;
        background:rgba(8,12,16,.55);
        border:1px solid rgba(93,187,127,.25);
        border-radius:10px;
      }
      #tarotDecksPanel .theme-weight label{
        font-size:11px;
        text-transform:capitalize;
      }
      #tarotDecksPanel .list{
        max-height:140px;
      }
      #tarotDecksPanel .preview-card{
        max-height:180px;
      }
      .muted{color:var(--muted)}
      .owner-meta{
        display:flex;
        align-items:center;
        gap:10px;
        font-size:12px;
        color:var(--muted);
        flex-wrap:nowrap;
        white-space:nowrap;
      }
      .owner-meta .owner-cards{font-weight:500}
      .owner-meta .owner-link{
        color:var(--accent);
        text-decoration:none;
        font-weight:500;
      }
      .owner-meta .owner-link:hover{text-decoration:underline}
      .owner-meta .owner-copy{
        max-width:110px;
        padding:4px 8px;
        font-size:12px;
        font-weight:500;
      }
      .owner-meta .owner-copy-icon{
        width:28px;
        height:28px;
        padding:4px;
        border-radius:8px;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        background:transparent;
        border:1px solid rgba(255,255,255,.18);
        color:var(--muted);
      }
      .owner-meta .owner-copy-icon:hover{
        color:var(--ink);
        border-color:rgba(255,255,255,.3);
      }
      .owner-meta .owner-copy-icon svg{
        width:14px;
        height:14px;
        fill:currentColor;
      }
      #bOwners{
        max-height:220px;
        padding:6px;
      }
      .empty-state{
        padding:12px;
        border-radius:12px;
        border:1px dashed rgba(233,226,210,.25);
        background:rgba(6,10,18,.45);
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:12px;
        margin-bottom:8px;
      }
      .bingo-section{
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .bingo-section h3{
        margin:0;
      }
      .bingo-state-card{
        padding:12px;
        border-radius:14px;
        border:1px solid rgba(31,58,43,.6);
        background:rgba(6,10,18,.6);
      }
      .status-badge{
        display:inline-flex;
        align-items:center;
        gap:6px;
        padding:6px 10px;
        border-radius:999px;
        border:1px solid rgba(233,226,210,.2);
        background:rgba(10,16,22,.6);
        color:var(--neutral);
        font-size:11px;
        text-transform:uppercase;
        letter-spacing:.08em;
      }
      .status-badge.good{
        border-color:rgba(157,224,125,.4);
        color:var(--accent);
      }
      .status-badge.warn{
        border-color:rgba(224,176,125,.45);
        color:#f2d7b3;
      }
      .status-badge.bad{
        border-color:rgba(210,92,92,.55);
        color:#f1b1b1;
      }
      .danger-btn{
        border-color:rgba(210,92,92,.45);
        color:#f1b1b1;
      }
      .bingo-announce{
        display:flex;
        align-items:center;
        gap:10px;
      }
      .owner-row{
        padding:2px 6px;
        border-bottom:1px solid rgba(255,255,255,0.06);
      }
      .owner-row strong{
        font-size:11px;
        font-weight:600;
        line-height:1.1;
      }
      .owner-row .owner-meta{
        gap:4px;
        font-size:10px;
        line-height:1.1;
      }
      .owner-card-list{
        flex:1;
        min-height:0;
        overflow:auto;
        padding:12px;
        border-radius:14px;
        border:1px solid var(--line);
        background:rgba(6,10,18,.6);
        display:flex;
        flex-direction:column;
        gap:12px;
      }
      .owner-card{
        border:1px solid rgba(233,226,210,.16);
        border-radius:14px;
        background:rgba(8,12,18,.55);
        overflow:hidden;
      }
      .owner-card-header{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        padding:8px 12px;
        background:linear-gradient(120deg, rgba(157,224,125,.12), rgba(10,16,22,.8));
        border-bottom:1px solid rgba(233,226,210,.12);
        cursor:pointer;
      }
      .owner-card-header:hover{
        background:linear-gradient(120deg, rgba(157,224,125,.2), rgba(10,16,22,.9));
      }
      .owner-card-title{
        font-size:11px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--neutral-2);
      }
      .owner-card-id{
        font-size:11px;
        color:var(--muted);
      }
      .owner-card-summary{
        display:flex;
        align-items:center;
        gap:10px;
        font-size:12px;
        color:var(--neutral-2);
      }
      .owner-card-count{
        font-weight:700;
        color:var(--accent);
      }
      .owner-card-progress{
        width:84px;
        height:6px;
        border-radius:999px;
        background:rgba(255,255,255,.08);
        overflow:hidden;
      }
      .owner-card-progress-fill{
        height:100%;
        background:rgba(157,224,125,.7);
        border-radius:999px;
      }
      .owner-card-flag{
        font-size:10px;
        text-transform:uppercase;
        letter-spacing:.08em;
        padding:2px 6px;
        border-radius:999px;
        border:1px solid rgba(255,255,255,.16);
        color:var(--neutral-2);
      }
      .owner-card-flag.near{
        border-color:rgba(224,176,125,.5);
        color:#f2d7b3;
      }
      .owner-card-flag.complete{
        border-color:rgba(60,207,142,.6);
        color:#c6f7da;
      }
      .owner-card-toggle{
        width:32px;
        height:32px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,.16);
        background:rgba(8,12,16,.5);
        color:var(--ink);
        display:inline-flex;
        align-items:center;
        justify-content:center;
        cursor:pointer;
      }
      .owner-card-toggle svg{
        width:14px;
        height:14px;
        fill:currentColor;
        transition:transform .2s ease;
      }
      .owner-card:not(.collapsed) .owner-card-toggle svg{
        transform:rotate(180deg);
      }
      .owner-card-body{
        padding:10px 12px 12px;
      }
      .owner-card.collapsed .owner-card-body{
        display:none;
      }
      .owner-card-list[data-filter="called"] .bingo-cell.filtered-out,
      .owner-card-list[data-filter="uncalled"] .bingo-cell.filtered-out{
        display:none;
      }
      .owner-filter{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .owner-filter-btn{
        border-radius:999px;
        border:1px solid rgba(255,255,255,.2);
        padding:4px 10px;
        font-size:11px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--muted);
        background:rgba(8,12,16,.4);
        cursor:pointer;
      }
      .owner-filter-btn.active{
        border-color:rgba(157,224,125,.6);
        color:#d6ffe9;
        background:rgba(60,207,142,.12);
      }
      .role-table-wrap{
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(6,10,18,.6);
        max-height:320px;
        overflow:auto;
      }
      .role-table-wrap .list{
        padding:0;
        border:none;
        background:transparent;
        max-height:none;
      }
      .role-table{
        width:100%;
        border-collapse:collapse;
        font-size:12px;
        color:var(--muted);
      }
      .role-table thead th{
        position:sticky;
        top:0;
        z-index:2;
        background:rgba(8,12,20,.95);
        color:var(--accent-2);
        text-transform:uppercase;
        letter-spacing:.08em;
        font-size:11px;
        border-bottom:1px solid rgba(255,255,255,.08);
        padding:8px 10px;
        text-align:left;
      }
      .role-table td{
        padding:8px 10px;
        border-bottom:1px solid rgba(255,255,255,.06);
        color:var(--ink);
      }
      .role-table tbody tr:hover{
        background:rgba(60,207,142,.08);
      }
      .gallery-admin-list{
        max-height:320px;
        overflow:auto;
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(6,10,18,.6);
        padding:8px;
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .gallery-admin-row{
        display:flex;
        align-items:center;
        gap:10px;
        padding:8px;
        border-radius:10px;
        border:1px solid rgba(255,255,255,.08);
        background:rgba(8,12,18,.45);
      }
      .gallery-thumb{
        width:46px;
        height:62px;
        border-radius:8px;
        background:rgba(12,18,16,.7);
        border:1px solid rgba(255,255,255,.08);
        object-fit:cover;
        flex:0 0 auto;
      }
      .gallery-meta{
        flex:1;
        min-width:0;
      }
      .gallery-title{
        font-size:12px;
        font-weight:600;
        color:var(--ink);
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }
      .gallery-sub{
        font-size:11px;
        color:var(--muted);
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }
      .gallery-actions{
        display:flex;
        gap:6px;
        flex:0 0 auto;
      }
      .gallery-actions .btn-ghost{
        padding:4px 8px;
        font-size:11px;
      }
      .role-name{
        font-weight:600;
        color:var(--ink);
        white-space:nowrap;
      }
      .token-code{
        display:block;
        font-size:10px;
        word-break:break-all;
        color:var(--muted);
        margin-bottom:4px;
      }
      .token-actions{
        display:flex;
        gap:6px;
        flex-wrap:wrap;
      }
      .role-scope-cell{
        text-align:center;
      }
      .row{
        display:grid;
        grid-template-columns:repeat(auto-fit,minmax(140px,1fr));
        gap:8px;
        margin-bottom:8px;
      }
      label{
        display:block;
        font-size:12px;
        text-transform:uppercase;
        letter-spacing:.1em;
        color:var(--neutral-2);
        margin-bottom:4px;
      }
      input, select, textarea, button{
        width:100%;
        border-radius:10px;
        border:1px solid var(--line);
        background:var(--panel-2);
        color:var(--ink);
        padding:8px 10px;
        font-family:"Palatino Linotype","Book Antiqua",serif;
        font-size:14px;
      }
      textarea{min-height:70px;resize:vertical}
      button{
        cursor:pointer;
        background:linear-gradient(135deg, rgba(157,224,125,.9), rgba(60,207,142,.75));
        color:#0a1510;
        border:none;
        font-weight:700;
        letter-spacing:.04em;
        transition:transform .12s ease, box-shadow .12s ease;
      }
      button:hover{transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.25)}
      .btn-ghost{
        background:transparent;
        border:1px solid var(--line);
        color:var(--ink);
      }
      #bingoPanel input,
      #bingoPanel select,
      #bingoPanel button{
        font-size:12px;
        padding:6px 8px;
      }
      #bingoPanel .btn-ghost{
        font-weight:600;
      }
      .pill{
        display:inline-block;
        padding:4px 10px;
        border-radius:999px;
        background:rgba(60,207,142,.18);
        color:var(--accent-2);
        font-size:12px;
        letter-spacing:.06em;
        text-transform:uppercase;
      }
      .status{
        font-size:13px;
        color:var(--muted);
        padding:10px 12px;
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(6,10,18,.6);
      }
      .status.alert{
        background:rgba(30,18,14,.65);
        border-color:rgba(210,152,122,.35);
        color:#f3d7c4;
      }
      .status.ok{color:#b8ffce;border-color:rgba(160,255,196,.3)}
      .status.err{color:#ff9f9f;border-color:rgba(255,159,159,.3)}
      .list{
        max-height:180px;
        overflow:auto;
        border-radius:12px;
        border:1px solid var(--line);
        padding:10px;
        background:rgba(6,10,18,.6);
        font-size:13px;
        color:var(--muted);
        white-space:pre-wrap;
      }
      .list-header{
        font-size:12px;
        text-transform:uppercase;
        letter-spacing:.08em;
        color:var(--accent-2);
        margin-bottom:8px;
      }
      .list-card{
        padding:8px 6px;
        border-bottom:1px solid rgba(255,255,255,0.06);
      }
      .list-card:last-child{border-bottom:none}
      .list-card.clickable{cursor:pointer}
      .list-card.active{
        background:rgba(60,207,142,.12);
        border-radius:10px;
      }
      .section-divider{
        height:1px;
        background:linear-gradient(90deg, transparent, rgba(157,224,125,.25), transparent);
        margin:18px 0;
      }
      .context-header{
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:12px;
        padding:12px 14px;
        border-radius:14px;
        border:1px solid rgba(233,226,210,.18);
        background:rgba(6,10,18,.55);
        margin-bottom:12px;
      }
      .context-path{
        font-size:12px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--neutral);
      }
      .context-meta{
        font-size:12px;
        color:var(--muted);
      }
      .deck-editor-grid{
        display:grid;
        grid-template-columns:repeat(auto-fit, minmax(240px, 1fr));
        gap:14px;
      }
      .deck-editor-column{
        background:rgba(7,12,16,.5);
        border:1px solid rgba(31,58,43,.6);
        border-radius:14px;
        padding:12px;
      }
      .deck-editor-column h4{
        margin:0 0 10px;
        font-size:12px;
        text-transform:uppercase;
        letter-spacing:.12em;
        color:var(--neutral);
      }
      .btn-primary{
        height:42px;
        background:var(--accent);
        color:#0a1510;
        font-weight:700;
        letter-spacing:.08em;
        border:none;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        gap:8px;
      }
      .btn-primary svg{
        width:18px;
        height:18px;
        fill:currentColor;
      }
      .btn-ghost{
        background:rgba(8,12,10,.25);
        border:1px solid rgba(255,255,255,.12);
        color:var(--muted);
      }
      .danger-action{
        opacity:0;
        transition:opacity .2s ease;
        border-color:rgba(210,92,92,.45);
        color:#e7b1b1;
      }
      .icon-group:hover .danger-action{
        opacity:1;
      }
      .theme-weight{
        display:grid;
        gap:6px;
        grid-template-columns:1fr;
      }
      .theme-weight .theme-bar{
        position:relative;
        height:8px;
        border-radius:999px;
        background:rgba(15,30,22,.6);
        overflow:hidden;
        border:1px solid rgba(93,187,127,.2);
      }
      .theme-weight .theme-fill{
        position:absolute;
        inset:0;
        width:0%;
        background:linear-gradient(90deg, rgba(157,224,125,.35), rgba(60,207,142,.85));
      }
      .theme-weight .theme-value{
        font-size:11px;
        color:var(--neutral-2);
        text-align:right;
      }
      .theme-weight input[type="range"]{
        width:100%;
        accent-color:var(--accent-2);
      }
      .preview-card.card-object{
        box-shadow:0 12px 25px rgba(0,0,0,.35), inset 0 0 28px rgba(0,0,0,.35);
      }
      .preview-card.card-object::before{
        opacity:.55;
      }
      .preview-card.hover-flip .card-meaning{
        position:absolute;
        left:10px;
        right:10px;
        bottom:12px;
        z-index:2;
        font-size:11px;
        line-height:1.3;
        color:var(--neutral);
        background:rgba(5,8,10,.5);
        border:1px solid rgba(233,226,210,.15);
        border-radius:10px;
        padding:6px 8px;
      }
      .preview-card.hover-flip .meaning-line{
        opacity:.9;
        transition:opacity .2s ease;
      }
      .preview-card.hover-flip .meaning-line.reversed{
        opacity:.15;
      }
      .preview-card.hover-flip:hover .meaning-line.upright{
        opacity:.15;
      }
      .preview-card.hover-flip:hover .meaning-line.reversed{
        opacity:.9;
      }
      .contest-grid{
        display:grid;
        grid-template-columns:repeat(auto-fit, minmax(240px, 1fr));
        gap:12px;
      }
      .contest-actions{
        display:flex;
        gap:8px;
        margin-top:6px;
      }
      .list-warn{
        color:#ff9f9f;
      }
      .preview-grid{
        display:grid;
        grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
        gap:12px;
      }
      .preview-card{
        aspect-ratio:3/4.2;
        border-radius:12px;
        border:1px solid var(--line);
        background:rgba(10,16,28,.6);
        overflow:hidden;
        display:flex;
        align-items:center;
        justify-content:center;
        position:relative;
      }
      .preview-card::before{
        content:"";
        position:absolute;
        inset:0;
        background:var(--card-overlay, transparent);
        opacity:var(--card-overlay-opacity, .35);
        mix-blend-mode:screen;
        pointer-events:none;
        z-index:1;
      }
      .preview-card::after{
        content:"";
        position:absolute;
        inset:10px;
        border-radius:10px;
        border:1px solid var(--card-frame, rgba(255,255,255,.16));
        box-shadow:var(--card-frame-shadow, none);
        pointer-events:none;
        z-index:1;
      }
      .preview-card[data-card-theme="classic"]{
        --card-overlay:radial-gradient(circle at 20% 10%, rgba(214,178,110,.35), transparent 55%),
          linear-gradient(180deg, rgba(10,12,12,.2), rgba(8,8,8,.65));
        --card-overlay-opacity:.45;
        --card-frame:rgba(214,178,110,.65);
        --card-frame-shadow:0 0 0 1px rgba(214,178,110,.25), inset 0 0 12px rgba(0,0,0,.35);
        --card-title-letter:.12em;
        --card-title-transform:uppercase;
        --card-number-letter:.16em;
        --card-number-transform:uppercase;
        --card-title-border:rgba(214,178,110,.6);
      }
      .preview-card[data-card-theme="wood"]{
        --card-overlay:repeating-linear-gradient(45deg, rgba(104,68,36,.28) 0 8px, rgba(74,49,27,.28) 8px 16px),
          radial-gradient(circle at 50% 20%, rgba(162,111,58,.25), transparent 60%);
        --card-overlay-opacity:.5;
        --card-frame:rgba(141,99,58,.9);
        --card-frame-shadow:inset 0 0 0 2px rgba(63,41,24,.5), inset 0 8px 18px rgba(0,0,0,.35);
        --card-title-letter:.04em;
        --card-title-transform:none;
        --card-number-letter:.08em;
        --card-number-transform:none;
        --card-title-border:rgba(141,99,58,.85);
      }
      .preview-card[data-card-theme="neon"]{
        --card-overlay:radial-gradient(circle at 20% 20%, rgba(55,226,255,.25), transparent 45%),
          radial-gradient(circle at 80% 0%, rgba(255,82,205,.18), transparent 45%);
        --card-overlay-opacity:.65;
        --card-frame:rgba(70,240,255,.9);
        --card-frame-shadow:0 0 14px rgba(70,240,255,.45), inset 0 0 12px rgba(255,82,205,.25);
        --card-title-letter:.22em;
        --card-title-transform:uppercase;
        --card-number-letter:.22em;
        --card-number-transform:uppercase;
        --card-title-border:rgba(70,240,255,.8);
      }
      .preview-card .card-title{
        position:absolute;
        left:50%;
        right:auto;
        bottom:10px;
        transform:translateX(-50%);
        padding:6px 10px;
        font-size:11px;
        letter-spacing:var(--card-title-letter, .04em);
        text-transform:var(--card-title-transform, uppercase);
        color:var(--ink);
        background:rgba(6,10,8,.65);
        border:1px solid var(--card-title-border, rgba(255,255,255,.2));
        border-radius:999px;
        min-width:60%;
        text-align:center;
        z-index:2;
      }
      .preview-card .card-number{
        position:absolute;
        top:8px;
        left:50%;
        transform:translateX(-50%);
        padding:3px 8px;
        border-radius:999px;
        font-size:11px;
        letter-spacing:var(--card-number-letter, .08em);
        text-transform:var(--card-number-transform, uppercase);
        color:var(--ink);
        background:rgba(6,10,8,.7);
        border:1px solid rgba(255,255,255,.2);
        z-index:2;
      }
      .preview-card.library-card{
        aspect-ratio:auto;
        align-items:stretch;
        justify-content:flex-start;
        padding:8px 0;
        gap:4px;
        flex-direction:column;
      }
      .preview-card.library-card .preview-label{
        font-size:12px;
        text-transform:uppercase;
        letter-spacing:.06em;
        color:var(--accent);
      }
      .preview-card.library-card .muted{
        font-size:11px;
      }
      .preview-card.library-card img{
        width:calc(100% - 16px);
        height:180px;
        object-fit:cover;
        border-radius:10px;
        margin:0 8px;
      }
      #mediaPanel .preview-card.library-card img{
        height:120px;
      }
      .preview-card.library-card .btn-ghost{
        margin:0 8px 8px;
      }
      .library-layout{
        display:grid;
        grid-template-columns:minmax(240px, 320px) 1fr;
        gap:16px;
        align-items:start;
      }
      .library-section-title{
        font-size:12px;
        letter-spacing:.14em;
        text-transform:uppercase;
        color:var(--neutral-2);
        margin-bottom:8px;
      }
      .library-upload{
        padding:12px;
        border-radius:14px;
        border:1px solid var(--line);
        background:rgba(6,10,18,.45);
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .library-browser{
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .library-grid-scroll{
        max-height:520px;
        overflow:auto;
        padding-right:6px;
      }
      .library-toolbar{
        display:flex;
        justify-content:flex-end;
      }
      .upload-drop{
        border:1px dashed rgba(255,255,255,.2);
        border-radius:14px;
        padding:14px;
        text-align:center;
        background:rgba(8,12,16,.45);
        cursor:pointer;
        transition:border-color .15s ease, background .15s ease;
      }
      .upload-drop.dragover{
        border-color:rgba(157,224,125,.7);
        background:rgba(60,207,142,.12);
      }
      .upload-drop-title{
        font-size:13px;
        color:var(--ink);
      }
      .upload-drop-meta{
        font-size:11px;
        color:var(--muted);
        margin-top:4px;
      }
      .upload-drop-cta{
        font-size:11px;
        color:var(--accent);
        margin-top:6px;
        letter-spacing:.06em;
        text-transform:uppercase;
      }
      .library-card-title{
        font-size:13px;
        font-weight:700;
        color:var(--ink);
        padding:6px 10px 0;
      }
      .library-card-artist{
        font-size:11px;
        color:var(--muted);
        padding:0 10px 4px;
      }
      .library-card-artist button{
        background:none;
        border:none;
        padding:0;
        font-size:11px;
        color:var(--accent);
        cursor:pointer;
      }
      .library-badges{
        display:flex;
        flex-wrap:wrap;
        gap:6px;
        padding:0 10px 4px;
      }
      .library-badge{
        font-size:10px;
        letter-spacing:.06em;
        text-transform:uppercase;
        padding:3px 8px;
        border-radius:999px;
        border:1px solid rgba(255,255,255,.12);
        color:var(--neutral-2);
        background:rgba(8,12,16,.4);
      }
      .library-actions{
        display:flex;
        gap:8px;
        padding:6px 10px 10px;
      }
      .library-actions button{
        width:auto;
        flex:1;
      }
      .btn-danger{
        border:1px solid rgba(210,92,92,.45);
        color:#f1b1b1;
        background:transparent;
      }
      .btn-danger:hover{
        border-color:rgba(210,92,92,.75);
        color:#ffd6d6;
      }
      @media (max-width: 920px){
        .library-layout{
          grid-template-columns:1fr;
        }
      }
      .preview-card img{
        width:100%;
        height:100%;
        object-fit:cover;
        position:relative;
        z-index:0;
      }
      .preview-label{
        position:absolute;
        bottom:8px;
        left:8px;
        padding:2px 8px;
        border-radius:999px;
        background:rgba(0,0,0,.5);
        font-size:11px;
        letter-spacing:.06em;
        text-transform:uppercase;
      }
      .subgrid{
        display:grid;
        grid-template-columns:repeat(auto-fit,minmax(180px,1fr));
        gap:10px;
      }
      .links a{
        color:var(--accent);
        text-decoration:none;
      }
      .links a:hover{text-decoration:underline}
      .modal{
        position:fixed;
        inset:0;
        background:rgba(6,12,9,.7);
        display:none;
        align-items:center;
        justify-content:center;
        z-index:20;
      }
      #uploadLibraryModal{
        z-index:30;
      }
      .modal.show{display:flex}
      .modal-card{
        width:min(720px,92vw);
        background:var(--panel);
        border:1px solid var(--line);
        border-radius:20px;
        padding:18px;
        box-shadow:var(--shadow);
      }
      .modal-card--wide{
        width:min(1400px,92vw);
        height:90vh;
        display:flex;
        flex-direction:column;
      }
      .modal-card--wide .list{
        flex:1;
        max-height:none;
        overflow:auto;
      }
      .modal-header{
        display:flex;
        justify-content:space-between;
        align-items:center;
        margin-bottom:10px;
      }
      .modal-title{
        font-size:16px;
        letter-spacing:.08em;
        text-transform:uppercase;
        color:var(--accent-2);
      }
      .bingo-summary{
        display:grid;
        grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
        gap:12px;
        font-size:13px;
        color:var(--neutral-2);
      }
      .bingo-card{
        margin-top:12px;
        border:1px solid var(--line);
        border-radius:14px;
        background:rgba(9,13,22,.7);
        padding:10px;
      }
      .bingo-header, .bingo-grid{
        display:grid;
        grid-template-columns:repeat(4,1fr);
        gap:6px;
        text-align:center;
      }
      .bingo-header div{
        font-weight:700;
        text-transform:uppercase;
        letter-spacing:.08em;
        color:var(--accent);
        padding:6px 0;
      }
      .bingo-cell{
        position:relative;
        padding:10px 0;
        min-height:34px;
        border-radius:8px;
        background:rgba(12,18,32,.9);
        border:1px solid rgba(255,255,255,.05);
        color:var(--ink);
        font-weight:600;
        font-size:12px;
      }
      .bingo-cell.marked{
        background:rgba(60,207,142,.2);
        border-color:rgba(60,207,142,.7);
        color:#d6ffe9;
      }
      .bingo-cell.called{
        background:rgba(157,224,125,.18);
        border-color:rgba(157,224,125,.55);
        color:#e9ffe9;
      }
      .bingo-cell .cell-mark{
        position:absolute;
        top:4px;
        right:6px;
        font-size:10px;
        color:var(--accent);
        opacity:.9;
      }
      .bingo-called{
        font-size:12px;
        color:var(--muted);
        border:1px dashed rgba(233,226,210,.18);
        border-radius:10px;
        padding:8px;
      }
      .bingo-called-grid{
        display:grid;
        grid-template-columns:repeat(10, minmax(30px, 1fr));
        gap:6px;
        margin-top:8px;
      }
      .bingo-call-btn{
        border-radius:8px;
        padding:6px 0;
        background:rgba(10,16,22,.85);
        border:1px solid rgba(233,226,210,.18);
        color:var(--neutral-2);
        font-size:12px;
        cursor:pointer;
      }
      .bingo-call-btn:disabled{
        opacity:.6;
        cursor:default;
      }
      .bingo-call-btn.active{
        background:rgba(157,224,125,.35);
        border-color:rgba(157,224,125,.7);
        color:#0a1510;
        box-shadow:0 0 0 1px rgba(157,224,125,.2), 0 6px 14px rgba(23,43,33,.45);
      }
      .bingo-called-empty{
        grid-column:1/-1;
        text-align:center;
        padding:8px;
        color:var(--muted);
        border:1px dashed rgba(233,226,210,.18);
        border-radius:10px;
      }
      .bingo-call-btn.recent{
        animation:callPulse .9s ease;
      }
      @keyframes callPulse{
        0%{box-shadow:0 0 0 0 rgba(157,224,125,.6)}
        100%{box-shadow:0 0 0 10px rgba(157,224,125,0)}
      }
      .bingo-callout{
        position:fixed;
        right:24px;
        bottom:24px;
        background:rgba(8,12,20,.9);
        border:1px solid rgba(157,224,125,.55);
        border-radius:14px;
        padding:12px 16px;
        font-weight:700;
        letter-spacing:.06em;
        color:#dcffcf;
        box-shadow:var(--shadow);
        opacity:0;
        transform:translateY(10px);
        transition:opacity .2s ease, transform .2s ease;
        pointer-events:none;
      }
      .bingo-callout.show{
        opacity:1;
        transform:translateY(0);
      }
      .bingo-card{
        background-size:cover;
        background-position:center;
      }
      @keyframes fadeup{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
      @keyframes rise{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
      @media (max-width:900px){
        .app-shell{grid-template-columns:1fr}
        .sidebar{border-right:none;border-bottom:1px solid var(--line)}
      }
    </style>
  </head>
  <body>
    <button class="overlay-exit" id="overlayExit">Exit overlay</button>
    <div class="login-screen" id="loginView">
      <div class="login-card">
        <div class="login-title">Forest Management</div>
        <div class="login-sub">Enter your API key to manage the forest.</div>
        <label for="apiKeyLogin">API key</label>
        <input id="apiKeyLogin" placeholder="Paste /auth token">
        <button id="loginBtn">Login</button>
        <div class="status" id="loginStatus">Ready.</div>
      </div>
    </div>

    <div class="app-shell hidden" id="appView">
      <aside class="sidebar">
        <div class="sidebar-body">
          <div class="nav-block">
            <div class="brand">Forest Management</div>
            <div class="brand-user hidden" id="brandUser">
              <img id="brandUserIcon" alt="" class="hidden">
              <svg viewBox="0 0 24 24" aria-hidden="true" id="brandUserFallback">
                <path d="M12 4a4 4 0 1 1-4 4 4 4 0 0 1 4-4zm0 10c3.31 0 6 1.34 6 3v3H6v-3c0-1.66 2.69-3 6-3z"/>
              </svg>
              <span id="brandUserName"></span>
            </div>
          </div>

          <div class="nav-block">
            <div class="nav-title">Home</div>
            <div class="menu-item" id="menuDashboard" tabindex="0">
              <span class="menu-label">Dashboard</span>
            </div>
          </div>

          <div class="nav-block">
            <div class="nav-title">Bingo</div>
            <div class="menu-item" id="menuBingo" tabindex="0">
              <span class="menu-label">Manager</span>
              <div class="menu-actions">
                <button class="menu-refresh" id="menuBingoRefresh" title="Refresh games" aria-label="Refresh games">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 5a7 7 0 1 1-6.65 9H3a9 9 0 1 0 2.64-6.36L3 6v6h6l-2.55-2.55A7 7 0 0 1 12 5z"/>
                  </svg>
                </button>
                <button class="menu-refresh" id="menuCreateGame" title="New game" aria-label="New game">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M11 5h2v14h-2zM5 11h14v2H5z"/>
                  </svg>
                </button>
              </div>
            </div>
            <div class="menu-sub" id="menuGames"></div>
            <div class="hidden" id="menuCreateGamePlaceholder"></div>
          </div>

          <div class="nav-block">
            <div class="nav-title">Tarot</div>
            <div class="menu-item" id="menuTarotLinks" tabindex="0"><span class="menu-label">Session Manager</span></div>
            <div class="menu-item" id="menuTarotDecks" tabindex="0"><span class="menu-label">Deck Editor</span></div>
          </div>

          <div class="nav-block">
            <div class="nav-title">Discord</div>
            <div class="menu-item" id="menuContests" tabindex="0"><span class="menu-label">Contests</span></div>
          </div>

          <div class="nav-block">
            <div class="nav-title">Administration</div>
            <div class="menu-icon-grid">
              <div class="menu-icon-group">
                <div class="menu-icon-label">Media</div>
                <button class="menu-icon" id="menuMedia" title="Media management" aria-label="Media management">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M4 5h16a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1zm0 2v10h15a0 0 0 0 0 0 0V7H4zm3 8 3-4 3 3 2-2 4 5H7z"/>
                  </svg>
                </button>
                <button class="menu-icon" id="menuGallery" title="Gallery admin" aria-label="Gallery admin">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M4 6h16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2zm0 2v8h16V8H4zm3 6 3-4 3 3 2-2 3 4H7z"/>
                  </svg>
                </button>
                <button class="menu-icon" id="menuCalendar" title="Gallery calendar" aria-label="Gallery calendar">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M7 2h2v2h6V2h2v2h3a1 1 0 0 1 1 1v15a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a1 1 0 0 1 1-1h4V2zm-3 6v12h16V8H4zm2 2h4v4H6v-4z"/>
                  </svg>
                </button>
              </div>
              <div class="menu-icon-group">
                <div class="menu-icon-label">Users</div>
                <button class="menu-icon" id="menuArtists" title="Artist index" aria-label="Artist index">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 4a4 4 0 1 1-4 4 4 4 0 0 1 4-4zm0 10c3.31 0 6 1.34 6 3v3H6v-3c0-1.66 2.69-3 6-3z"/>
                  </svg>
                </button>
                <button class="menu-icon" id="menuAuthRoles" title="Auth roles" aria-label="Auth roles">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 2a5 5 0 0 1 5 5v3h2a1 1 0 0 1 1 1v9a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-9a1 1 0 0 1 1-1h2V7a5 5 0 0 1 5-5zm-3 8h6V7a3 3 0 0 0-6 0v3z"/>
                  </svg>
                </button>
              </div>
              <div class="menu-icon-group">
                <div class="menu-icon-label">System</div>
                <button class="menu-icon" id="menuAuthKeys" title="Auth keys" aria-label="Auth keys">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 1a7 7 0 0 0-4.3 12.5l-2.2 2.2V19h3.3l1.2-1.2h1.4l1.2-1.2h1.5l1.6-1.6A7 7 0 1 0 12 1zm0 4a3 3 0 1 1-3 3 3 3 0 0 1 3-3z"/>
                  </svg>
                </button>
                <button class="menu-icon" id="menuOverlayToggle" title="Toggle overlay mode" aria-label="Toggle overlay mode">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h10v2H4z"/>
                  </svg>
                </button>
              </div>
            </div>
            <input type="checkbox" id="overlayMode" class="hidden">
          </div>

          <div class="nav-block">
            <div class="nav-title">Status</div>
            <div class="status-bar status" id="status">
              <span class="status-dot" id="statusDot" aria-hidden="true"></span>
              <span id="statusText">Idle</span>
              <span class="status-time" id="statusTime">--:--</span>
            </div>
          </div>
        </div>
      </aside>
      <main class="content">
      <div class="grid">
        <section class="panel dashboard hidden" style="animation-delay:.02s" id="dashboardPanel">
          <h2>Forest Dashboard</h2>
          <p class="muted">Welcome to the forest control room. This is a quick start and reference for the bot and site.</p>
          <div class="dashboard-readme" style="margin-top:12px">
            <div class="dash-toc">
              <strong>Table of contents</strong>
              <ul>
                <li><a href="#dash-overview">Welcome & System Overview</a></li>
                <li><a href="#dash-auth">Authentication & Access</a></li>
                <li><a href="#dash-downloads">Downloadable Software & Installations</a></li>
                <li><a href="#dash-commands">Discord Bot Commands</a></li>
                <li><a href="#dash-tools">Web Dashboard Tools</a></li>
                <li><a href="#dash-workflows">Workflows</a></li>
                <li><a href="#dash-gallery">Gallery & Archival Flow</a></li>
                <li><a href="#dash-troubleshoot">Troubleshooting</a></li>
                <li><a href="#dash-credits">Credits & Acknowledgements</a></li>
              </ul>
            </div>

            <details class="dash-section" id="dash-overview" open>
              <summary>Welcome & System Overview</summary>
              <div class="dash-section-body">
                <div class="dash-blocks">
                  <div class="dash-block">
                    <div class="dash-label">Overview</div>
                    <p>Forest is a coordinated system of Discord commands, web tools, and overlays used to run games, rituals, and archives.</p>
                    <ul class="dash-list">
                      <li>Discord Bot</li>
                      <li>Web Dashboard</li>
                      <li>OBS Overlay</li>
                      <li>Media & Gallery System</li>
                    </ul>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">When to use this</div>
                    <p>Use this page for onboarding, daily operations, and troubleshooting during live events.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">Links</div>
                    <div class="dash-links">
                      <a href="/overlay">Web Dashboard</a>
                      <a href="/tarot/gallery" target="_blank" rel="noreferrer">Forest Gallery</a>
                      <a href="/tarot/calendar" target="_blank" rel="noreferrer">Gallery Calendar</a>
                      <a href="/tarot/overlay" target="_blank" rel="noreferrer">Tarot Overlay</a>
                    </div>
                  </div>
                </div>
              </div>
            </details>

            <details class="dash-section" id="dash-auth" open>
              <summary>Authentication & Access</summary>
              <div class="dash-section-body">
                <div class="dash-blocks">
                  <div class="dash-block">
                    <div class="dash-label">Overview</div>
                    <p>Authentication protects admin tools. Tokens are short-lived and tied to your Discord role permissions.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">When to use this</div>
                    <p>Use this whenever tools are locked, permissions are missing, or a token expires.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">Links</div>
                    <div class="dash-links">
                      <a href="/overlay">Dashboard Login</a>
                    </div>
                  </div>
                </div>
                <h3>How authentication works</h3>
                <ul class="dash-list">
                  <li><span class="cmd">/auth</span> generates a 24-hour token.</li>
                  <li>Tokens unlock tools based on role permissions.</li>
                  <li>Expired tokens must be regenerated.</li>
                </ul>
                <h3>Step-by-step</h3>
                <ol class="dash-list">
                  <li>Run <span class="cmd">/auth</span> in Discord.</li>
                  <li>Copy the generated token.</li>
                  <li>Paste the token into the Dashboard auth field.</li>
                  <li>Tools unlock based on role permissions.</li>
                </ol>
                <div class="dash-note">Security warning: never share tokens. Treat them like passwords.</div>
                <p><strong>Who can generate tokens:</strong> only members with approved roles or permissions.</p>
                <p><strong>When a token expires:</strong> tools lock until a new token is generated.</p>
              </div>
            </details>

            <details class="dash-section" id="dash-downloads">
              <summary>Downloadable Software & Installations</summary>
              <div class="dash-section-body">
                <div class="dash-blocks">
                  <div class="dash-block">
                    <div class="dash-label">Overview</div>
                    <p>Use OBS to display overlays for live Tarot and Bingo sessions.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">When to use this</div>
                    <p>Required for streaming, screen capture, and in-scene overlays.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">Links</div>
                    <div class="dash-links">
                      <a href="{{OBS_DOWNLOAD_URL}}" target="_blank" rel="noreferrer">Download OBS Studio</a>
                    </div>
                  </div>
                </div>
                <h3>Overlay Mode (OBS)</h3>
                <ol class="dash-list">
                  <li>Install OBS Studio.</li>
                  <li>Add a Browser Source.</li>
                  <li>Paste the overlay URL.</li>
                  <li>Set resolution and FPS to match your stream.</li>
                  <li>Enable “Refresh browser when scene becomes active”.</li>
                </ol>
              </div>
            </details>

            <details class="dash-section" id="dash-commands">
              <summary>Discord Bot Commands (Task-Based)</summary>
              <div class="dash-section-body">
                <div class="dash-blocks">
                  <div class="dash-block">
                    <div class="dash-label">Overview</div>
                    <p>Commands are grouped by task to support live operations.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">When to use this</div>
                    <p>Use this during live events and when training new operators.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">Links</div>
                    <div class="dash-links">
                      <a href="#dash-workflows">Workflows</a>
                    </div>
                  </div>
                </div>
                <h3>Bingo Commands</h3>
                <p>Used to run live Bingo games.</p>
                <ul class="dash-list">
                  <li><span class="cmd">/bingo</span> — start a game</li>
                  <li><span class="cmd">/call</span> — call the next number</li>
                  <li><span class="cmd">/bingo-stage</span> — advance game stage</li>
                  <li><span class="cmd">/bingo-end</span> — end the game</li>
                  <li><span class="cmd">/buycard</span> or <span class="cmd">/buycards</span> — sell cards</li>
                </ul>
                <p><strong>Typical Bingo flow:</strong> start game → sell cards → call numbers → manage claims → end game.</p>

                <h3>Tarot Commands</h3>
                <p>Used during tarot readings and rituals.</p>
                <ul class="dash-list">
                  <li><span class="cmd">/tarot_start</span> — open a session</li>
                  <li><span class="cmd">/tarot_draw</span> — draw cards</li>
                  <li><span class="cmd">/tarot_flip</span> — reveal cards</li>
                  <li><span class="cmd">/tarot_end</span> — close session and archive</li>
                  <li><span class="cmd">/tarot_stream</span> — generate overlay link</li>
                </ul>
                <p><strong>Session vs overlay:</strong> session view is operator control, overlay view is for streaming.</p>

                <h3>Contest Commands</h3>
                <p>Use contests to collect entries that move into the Gallery.</p>
                <ul class="dash-list">
                  <li><span class="cmd">/contest</span> — start a contest</li>
                  <li><span class="cmd">/contest_stop</span> — end the contest</li>
                </ul>

                <h3>Permissions & Admin Commands</h3>
                <ul class="dash-list">
                  <li><span class="cmd">/permissions list</span> — inspect current access</li>
                  <li><span class="cmd">/permissions refresh</span> — sync permissions</li>
                </ul>
                <p>Roles define access. Users inherit from roles. Refresh after role updates.</p>
              </div>
            </details>

            <details class="dash-section" id="dash-tools">
              <summary>Web Dashboard Tools</summary>
              <div class="dash-section-body">
                <div class="dash-blocks">
                  <div class="dash-block">
                    <div class="dash-label">Overview</div>
                    <p>Each tool is purpose-built; use the right one to avoid unintended changes.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">When to use this</div>
                    <p>Use this when deciding where to make a change or troubleshoot behavior.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">Links</div>
                    <div class="dash-links">
                      <a href="/overlay">Dashboard</a>
                    </div>
                  </div>
                </div>
                <div class="dash-tool">
                  <div class="dash-tool-title">Dashboard</div>
                  <p>For onboarding, reference, and troubleshooting. Does not change data.</p>
                </div>
                <div class="dash-tool">
                  <div class="dash-tool-title">Session Manager</div>
                  <p>Run tarot sessions, open player/priestess views. Does not edit deck content.</p>
                </div>
                <div class="dash-tool">
                  <div class="dash-tool-title">Deck Editor</div>
                  <p>Create and maintain decks and cards. Changes are permanent. Does not alter active sessions until selected.</p>
                </div>
                <div class="dash-tool">
                  <div class="dash-tool-title">Bingo Manager</div>
                  <p>Run live Bingo games, manage claims and stage changes. Does not create Discord channels.</p>
                </div>
                <div class="dash-tool">
                  <div class="dash-tool-title">Overlay Mode</div>
                  <p>OBS-friendly layout for streaming. Does not change game state.</p>
                </div>
                <div class="dash-tool">
                  <div class="dash-tool-title">Admin Tools</div>
                  <p>Auth roles/keys, media library, artist index, gallery calendar. Use with care.</p>
                </div>
              </div>
            </details>

            <details class="dash-section" id="dash-workflows">
              <summary>Workflows</summary>
              <div class="dash-section-body">
                <h3>Tarot Workflow</h3>
                <ul class="dash-list">
                  <li><strong>Why:</strong> ensures sessions are structured and archived.</li>
                  <li><strong>Steps:</strong> create session → draw → reveal → narrate → finish.</li>
                  <li><strong>Expect:</strong> cards appear in the spread and meaning panel updates.</li>
                  <li><strong>Common mistakes:</strong> forgetting to reveal, using wrong deck.</li>
                </ul>

                <h3>Deck Editor Workflow</h3>
                <ul class="dash-list">
                  <li><strong>Why:</strong> maintain a clean, reusable deck library.</li>
                  <li><strong>Steps:</strong> pick deck → edit card → set art → save.</li>
                  <li><strong>Expect:</strong> previews update immediately; changes persist.</li>
                  <li><strong>Common mistakes:</strong> editing the wrong deck, missing back art.</li>
                </ul>

                <h3>Bingo Workflow</h3>
                <ul class="dash-list">
                  <li><strong>Why:</strong> run a fair, synchronized live game.</li>
                  <li><strong>Steps:</strong> create game → sell cards → call numbers → manage claims → close.</li>
                  <li><strong>Expect:</strong> called numbers update across views.</li>
                  <li><strong>Common mistakes:</strong> calling before game start, ignoring pending claims.</li>
                </ul>
              </div>
            </details>

            <details class="dash-section" id="dash-gallery">
              <summary>Gallery & Archival Flow</summary>
              <div class="dash-section-body">
                <div class="dash-blocks">
                  <div class="dash-block">
                    <div class="dash-label">Overview</div>
                    <p>When games end, their artwork is preserved in the Forest Gallery as a shrine to contributors.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">When to use this</div>
                    <p>Use this to verify artist attribution and manage visibility.</p>
                  </div>
                  <div class="dash-block">
                    <div class="dash-label">Links</div>
                    <div class="dash-links">
                      <a href="/tarot/gallery" target="_blank" rel="noreferrer">Forest Gallery</a>
                    </div>
                  </div>
                </div>
                <p>Artist names and links are preserved. The gallery exists to honor work, not rank it.</p>
              </div>
            </details>

            <details class="dash-section" id="dash-troubleshoot">
              <summary>Troubleshooting (Decision Guide)</summary>
              <div class="dash-section-body">
                <h3>Authentication Issues</h3>
                <div class="dash-issue">
                  <p><strong>Symptom:</strong> Tools locked or login fails.</p>
                  <p><strong>Likely cause:</strong> Token expired or missing permissions.</p>
                  <p><strong>Action:</strong> Run <span class="cmd">/auth</span> again and re-login.</p>
                </div>
                <div class="dash-issue">
                  <p><strong>Symptom:</strong> Overlay is blank.</p>
                  <p><strong>Likely cause:</strong> Missing token or wrong URL.</p>
                  <p><strong>Action:</strong> Re-open overlay link, ensure auth is valid.</p>
                </div>

                <h3>Sync Issues</h3>
                <div class="dash-issue">
                  <p><strong>Symptom:</strong> Cards not updating.</p>
                  <p><strong>Likely cause:</strong> Client stale state.</p>
                  <p><strong>Action:</strong> Refresh the view and re-open the session.</p>
                </div>
                <div class="dash-issue">
                  <p><strong>Symptom:</strong> Bingo numbers desynced.</p>
                  <p><strong>Likely cause:</strong> Calls not announced or stale game ID.</p>
                  <p><strong>Action:</strong> Refresh Bingo Manager and verify active game.</p>
                </div>

                <h3>Media Issues</h3>
                <div class="dash-issue">
                  <p><strong>Symptom:</strong> Images not loading.</p>
                  <p><strong>Likely cause:</strong> Missing media file or bad URL.</p>
                  <p><strong>Action:</strong> Re-open Media Library and re-select.</p>
                </div>
                <div class="dash-issue">
                  <p><strong>Symptom:</strong> Wrong image used.</p>
                  <p><strong>Likely cause:</strong> Incorrect selection.</p>
                  <p><strong>Action:</strong> Re-select image and save the deck/card.</p>
                </div>
              </div>
            </details>

            <details class="dash-section" id="dash-credits">
              <summary>Credits & Acknowledgements</summary>
              <div class="dash-section-body">
                <p>Credits recognize artists, moderators, maintainers, and contributors who sustain the Forest.</p>
                <ul class="dash-list">
                  <li>Yamaneko Chi</li>
                  <li>Asgorath White</li>
                  <li>Malady La'naiserie</li>
                  <li>Labreska Vaalkihar</li>
                  <li>Levi Anvunin/Cesare</li>
                </ul>
              </div>
            </details>
          </div>
        </section>
        <section class="panel" style="animation-delay:.05s" id="bingoPanel">
          <h2>Manager</h2>
          <div class="context-header">
            <div>
              <div class="context-path" id="bContextPath">Bingo / Manager / No game selected</div>
              <div class="context-meta" id="bContextMeta">Pick a game to manage.</div>
            </div>
            <div class="context-meta" id="bContextTitle"></div>
          </div>

          <div class="bingo-section">
            <h3>Players</h3>
            <div class="empty-state" id="bOwnersEmpty">
              <div class="muted">No players yet. Refresh to pull current owners.</div>
              <button class="btn-ghost" id="bOwnersRefresh">Refresh players</button>
            </div>
            <div class="list" id="bOwners"></div>
          </div>

          <div class="section-divider"></div>

          <div class="bingo-section">
            <h3>Stage Control</h3>
            <div class="row">
              <div>
                <label>&nbsp;</label>
                <button class="btn-primary" id="bAdvanceStage">Advance stage</button>
              </div>
              <div>
                <label>Announce calls</label>
                <div class="bingo-announce">
                  <input type="checkbox" id="bAnnounceToggle">
                  <span class="status-badge" id="bAnnounceBadge">Off</span>
                </div>
              </div>
            </div>
            <div class="list" id="bClaims">No claims yet.</div>
          </div>

          <div class="section-divider"></div>

          <div class="bingo-section">
            <h3>Active Game</h3>
            <div class="bingo-state-card">
              <div class="row">
                <div>
                  <label for="bGameId">Game ID</label>
                  <div id="bGameId" class="status">No game selected.</div>
                </div>
                <div>
                  <label>Status</label>
                  <div class="status-badge" id="bGameStatus">No game</div>
                </div>
              </div>
              <div class="row">
                <div>
                  <label>&nbsp;</label>
                  <button class="btn-ghost" id="bStart">Start game</button>
                </div>
                <div>
                  <label>&nbsp;</label>
                  <button id="bRoll" class="btn-primary">Pull random number</button>
                </div>
                <div>
                  <label>&nbsp;</label>
                  <button class="btn-ghost" id="bRefresh">Refresh</button>
                </div>
                <div>
                  <label>&nbsp;</label>
                  <button class="btn-ghost danger-btn danger-action" id="bCloseGame">Close game</button>
                </div>
                <div>
                  <label>&nbsp;</label>
                  <button class="btn-ghost" id="bViewOwner">View tickets</button>
                </div>
              </div>
              <div class="status" id="bingoStatus">No game selected.</div>
            </div>
          </div>

          <div class="section-divider"></div>

          <div class="bingo-section">
            <h3>Buy Cards</h3>
            <div class="row">
              <div>
                <label for="bOwner">Owner name</label>
                <input id="bOwner" placeholder="Player name">
              </div>
              <div>
                <label for="bOwnerId">Discord ID</label>
                <input id="bOwnerId" placeholder="optional">
              </div>
              <div>
                <label for="bQty">Quantity</label>
                <input id="bQty" type="number" value="1" min="1" max="10">
              </div>
              <div>
                <label>&nbsp;</label>
                <button id="bBuy" class="btn-primary">Buy</button>
              </div>
            </div>
          </div>

          <div class="section-divider"></div>

          <div class="bingo-section">
            <h3>Game State</h3>
            <div class="bingo-summary" id="bSummary">
              <div>Title: <span id="bTitleVal">No title</span></div>
              <div>Header: <span id="bHeaderVal">No header</span></div>
              <div>Stage: <span id="bStageVal">No stage</span></div>
              <div>Pot: <span id="bPotVal">No pot</span></div>
            </div>
            <div class="bingo-called" id="bCalled">No numbers called yet.</div>
            <div class="bingo-called-grid" id="bCalledGrid"></div>
            <div class="bingo-card" id="bCard">
              <div class="bingo-header" id="bCardHeader"></div>
              <div class="bingo-grid" id="bCardGrid"></div>
            </div>
          </div>
        </section>

        <section class="panel" style="animation-delay:.1s" id="tarotLinksPanel">
          <h2>Session Manager</h2>
          <p>Open the player, priestess, or overlay view.</p>
          <div class="row">
            <div>
              <label for="tSessionSelect">Existing sessions</label>
              <select id="tSessionSelect"></select>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="tSessionRefresh" class="menu-refresh" title="Refresh sessions" aria-label="Refresh sessions">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M12 5a7 7 0 1 1-6.65 9H3a9 9 0 1 0 2.64-6.36L3 6v6h6l-2.55-2.55A7 7 0 0 1 12 5z"/>
                </svg>
              </button>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="tCreateSession">New session</button>
            </div>
          </div>
          <div class="row">
            <div>
              <label for="tJoinCode">Join code</label>
              <input id="tJoinCode" placeholder="e.g. AB12CD">
            </div>
            <div>
              <label for="tPriestessToken">Priestess token</label>
              <input id="tPriestessToken" placeholder="token (for priestess)">
            </div>
          </div>
          <div class="row">
            <div>
              <label>&nbsp;</label>
              <button id="tOpenPlayer">Open player</button>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="tOpenPriestess">Open priestess</button>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="tOpenOverlay">Open overlay</button>
            </div>
            <div>
              <label>&nbsp;</label>
              <button class="btn-ghost" id="tCloseSession">Close session</button>
            </div>
          </div>
          <div class="row links">
            <div>
              <span class="pill">Links</span>
              <div id="tLink">No join code entered.</div>
            </div>
          </div>
          <h3>Tarot Games</h3>
          <p>Create and manage tarot sessions.</p>
          <div class="status hidden" id="tSpreadNote">
            Spread = the card layout for the reading. Single: one card. Tree: Root/Trunk/Canopy. Cross: Past/Present/Future.
          </div>
        </section>

        <section class="panel hidden" style="animation-delay:.1s" id="tarotDecksPanel">
          <h2>Deck Editor</h2>
          <div class="context-header">
            <div>
              <div class="context-path" id="taContextPath">Deck Editor / Forest / No card selected</div>
              <div class="context-meta" id="taContextMeta">Pick a card to edit.</div>
            </div>
            <div class="context-meta" id="taContextDeck"></div>
          </div>
          <div class="row">
            <div>
              <label for="taDeck">Deck</label>
              <select id="taDeck"></select>
            </div>
            <div>
              <label>&nbsp;</label>
              <div class="icon-group">
                <button class="btn-ghost icon-btn" id="taAddDeck" title="Add deck">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M11 5h2v14h-2zM5 11h14v2H5z"/>
                  </svg>
                </button>
                <button class="btn-ghost icon-btn" id="taEditDeck" title="Edit deck">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M4 15.5V20h4.5L19 9.5l-4.5-4.5L4 15.5zm16.4-9.9a1.5 1.5 0 0 0 0-2.1l-1.9-1.9a1.5 1.5 0 0 0-2.1 0l-1.5 1.5 4.5 4.5 1.5-1.5z"/>
                  </svg>
                </button>
                <button class="btn-ghost icon-btn danger-action" id="taDeleteDeck" title="Delete deck">
                  <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M6 7h12v2H6zM9 9h2v9H9zm4 0h2v9h-2zM8 5h8l-1-1h-6l-1 1z"/>
                  </svg>
                </button>
              </div>
            </div>
          </div>
          <div class="list" id="taDeckList">No deck loaded.</div>
          <div class="status" id="taDeckStatus">Pick a deck to begin.</div>

          <div class="section-divider"></div>
          <h3>Card Editor</h3>
          <div class="deck-editor-grid">
            <div class="deck-editor-column">
              <h4>Identity</h4>
              <div class="row">
                <div>
                  <label for="taCardId">Card ID</label>
                  <input id="taCardId" placeholder="candlecap_sprite">
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="taCardName">Name</label>
                  <input id="taCardName" placeholder="Candlecap Sprite">
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="taCardSuit">Suit</label>
                  <input id="taCardSuit" list="taSuitList" placeholder="Major">
                  <datalist id="taSuitList">
                    <option value="Major"></option>
                    <option value="Wands"></option>
                    <option value="Cups"></option>
                    <option value="Swords"></option>
                    <option value="Pentacles"></option>
                    <option value="Hearts"></option>
                    <option value="Spades"></option>
                    <option value="Clubs"></option>
                    <option value="Diamonds"></option>
                  </datalist>
                </div>
                <div>
                  <label for="taCardNumber">Number</label>
                  <input id="taCardNumber" list="taNumberList" placeholder="XIV or 14">
                  <datalist id="taNumberList"></datalist>
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="taCardTags">Tags</label>
                  <input id="taCardTags" placeholder="mischief,curiosity">
                </div>
              </div>
            </div>
            <div class="deck-editor-column">
              <h4>Meaning</h4>
              <div class="row">
                <div>
                  <label for="taCardFlavor">Flavor text</label>
                  <textarea id="taCardFlavor" rows="2" placeholder="Short flavor line for the card..."></textarea>
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="taCardUpright">Upright</label>
                  <textarea id="taCardUpright"></textarea>
                </div>
              </div>
              <div class="row">
                <div>
                  <label for="taCardReversed">Reversed</label>
                  <textarea id="taCardReversed"></textarea>
                </div>
              </div>
            </div>
            <div class="deck-editor-column">
              <h4>Meta</h4>
              <div class="row">
                <div>
                  <label>Theme weights</label>
                  <div class="theme-grid" id="taCardThemes"></div>
                  <div class="muted" id="taCardThemesHint">Select a suit to see theme weights.</div>
                </div>
              </div>
              <div class="row">
                <div>
                  <label>Suit info</label>
                  <div class="list" id="taSuitInfo">Pick a suit to see details.</div>
                </div>
              </div>
              <div class="row">
                <div>
                  <label>Number info</label>
                  <div class="list" id="taNumberInfo">Pick a number to see details.</div>
                </div>
              </div>
              <div class="row">
                <div>
                  <label>Card image</label>
                  <button class="btn-ghost icon-btn" id="taCardLibrary" title="Choose from library">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path d="M4 5h16a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1zm0 2v10h15a0 0 0 0 0 0 0V7H4zm3 8 3-4 3 3 2-2 4 5H7z"/>
                    </svg>
                  </button>
                </div>
              </div>
              <input id="taCardArtist" type="hidden">
              <div class="row">
                <div>
                  <label>Card preview</label>
                  <div class="preview-grid">
                    <div class="preview-card" id="taFrontPreview"><span class="preview-label">Front</span></div>
                    <div class="preview-card" id="taBackPreview"><span class="preview-label">Back</span></div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="row">
            <div>
              <label>&nbsp;</label>
              <button id="taSaveCard" class="btn-primary">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M17 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7l-4-4zM12 19a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm3-10H5V5h10v4z"/>
                </svg>
                Save card
              </button>
            </div>
          </div>
        </section>

        <section class="panel hidden" style="animation-delay:.1s" id="contestPanel">
          <h2>Discord</h2>
          <div class="row">
            <div>
              <label>&nbsp;</label>
              <button class="btn-ghost" id="contestRefresh">Refresh contests</button>
            </div>
            <div>
              <label>&nbsp;</label>
              <button class="btn-ghost" id="contestCreateChannelOpen">Create contest channel</button>
            </div>
          </div>
          <div class="muted" id="contestHelp">Create and run contests for a channel. Missing data will show an alert with a quick fix.</div>
          <div class="section-divider"></div>
          <h3>Create Contest</h3>
          <div class="row">
            <div>
              <label for="contestChannel">Channel</label>
              <select id="contestChannel"></select>
            </div>
            <div>
              <label>&nbsp;</label>
              <button class="menu-refresh" id="contestChannelRefresh" title="Refresh channels" aria-label="Refresh channels">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M12 5a7 7 0 1 1-6.65 9H3a9 9 0 1 0 2.64-6.36L3 6v6h6l-2.55-2.55A7 7 0 0 1 12 5z"/>
                </svg>
              </button>
            </div>
            <div>
              <label for="contestTitle">Title</label>
              <input id="contestTitle" placeholder="Elfoween Costume Contest">
            </div>
            <div>
              <label for="contestDeadline">Deadline</label>
              <input id="contestDeadline" placeholder="2025-10-31 23:59">
            </div>
          </div>
          <div class="row">
            <div>
              <label for="contestDescription">Description</label>
              <textarea id="contestDescription" placeholder="Post your entry as an attachment. Most :TreeCone: wins!"></textarea>
            </div>
            <div>
              <label for="contestRules">Rules</label>
              <textarea id="contestRules" placeholder="Leave empty for defaults."></textarea>
            </div>
          </div>
          <div class="row">
            <div>
              <label for="contestEmoji">Vote emoji</label>
              <input id="contestEmoji" placeholder=":TreeCone:">
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="contestCreate">Create contest</button>
            </div>
          </div>
          <div class="status" id="contestCreateStatus">Select a channel to create a contest.</div>
          <h3>Contest overview</h3>
          <div class="contest-grid">
            <div>
              <div class="list-header">Active</div>
              <div class="list" id="contestAllList">No contests loaded.</div>
            </div>
            <div>
              <div class="list-header">Ended</div>
              <div class="list" id="contestEndedList">No ended contests yet.</div>
            </div>
          </div>
          <div class="section-divider"></div>
          <h3>TarotCards</h3>
          <div class="row">
            <div>
              <label for="tarotClaimsDeck">Deck</label>
              <select id="tarotClaimsDeck"></select>
            </div>
            <div>
              <label for="tarotClaimsChannel">Channel</label>
              <select id="tarotClaimsChannel"></select>
            </div>
            <div>
              <label for="tarotClaimsLimit">Claim limit</label>
              <input id="tarotClaimsLimit" type="number" value="2" min="1" max="10">
            </div>
          </div>
          <div class="row">
            <div>
              <label>&nbsp;</label>
              <button class="btn-ghost" id="tarotClaimsRefresh">Refresh lists</button>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="tarotClaimsPost">Post TarotCards board</button>
            </div>
          </div>
          <div class="status" id="tarotClaimsStatus">Pick a deck and channel to post.</div>
        </section>
        <section class="panel hidden" style="animation-delay:.1s" id="mediaPanel">
          <h2>Media Library</h2>
          <p>Upload, review, and manage images used across the Forest.</p>
          <div class="library-layout">
            <div>
              <div class="library-section-title">Add new media</div>
              <div class="upload-drop" id="mediaUploadDrop" role="button" tabindex="0">
                <div class="upload-drop-title" id="mediaUploadDropTitle">Drag &amp; drop an image</div>
                <div class="upload-drop-meta" id="mediaUploadDropMeta">PNG, JPG, GIF, WEBP</div>
                <div class="upload-drop-cta" id="mediaUploadDropCta">or click to choose</div>
              </div>
              <input id="mediaUploadFile" type="file" accept="image/*" class="hidden">
              <div class="row">
                <div>
                  <label for="mediaUploadTitleInput">Title</label>
                  <input id="mediaUploadTitleInput" placeholder="Image title">
                </div>
                <div>
                  <label for="mediaUploadArtist">Artist</label>
                  <select id="mediaUploadArtist"></select>
                </div>
              </div>
              <div class="row">
                <div>
                  <label>&nbsp;</label>
                  <button id="mediaUploadUpload" disabled>Upload</button>
                </div>
              </div>
              <div class="status" id="mediaUploadStatus">Ready.</div>
            </div>
            <div>
              <div class="row" style="justify-content:space-between;align-items:center;">
                <div class="library-section-title">Existing media</div>
                <button class="btn-ghost" id="mediaLibraryRefresh">Refresh</button>
              </div>
              <div class="status" id="mediaLibraryStatus">Ready.</div>
              <div class="preview-grid" id="mediaLibraryGrid"></div>
            </div>
          </div>
        </section>
        <div class="modal" id="contestChannelModal">
          <div class="modal-card">
            <div class="modal-header">
              <div class="modal-title">Create Contest Channel</div>
              <button class="btn-ghost" id="contestChannelClose">Close</button>
            </div>
            <div class="row">
              <div>
                <label>Category</label>
                <div class="status" id="contestCategoryStatus">1239558949351460904</div>
              </div>
              <div>
                <label for="contestTemplateChannel">Template channel</label>
                <select id="contestTemplateChannel"></select>
              </div>
            </div>
            <div class="row">
              <div>
                <label for="contestEmojiSelect">Channel emoji</label>
                <select id="contestEmojiSelect">
                  <option value="ðŸŽƒ">ðŸŽƒ</option>
                  <option value="ðŸŒ²">ðŸŒ²</option>
                  <option value="ðŸ”®">ðŸ”®</option>
                  <option value="âœ¨">âœ¨</option>
                  <option value="ðŸ‚">ðŸ‚</option>
                </select>
              </div>
              <div>
                <label for="contestChannelName">Channel name</label>
                <input id="contestChannelName" placeholder="elfoween">
              </div>
            </div>
            <div class="row">
              <div>
                <label>Preview</label>
                <div class="status" id="contestChannelPreview">ðŸŽƒï¸±elfoween</div>
              </div>
              <div>
                <label>&nbsp;</label>
                <button id="contestChannelCreate">Create channel</button>
              </div>
            </div>
            <div class="status" id="contestChannelStatus">Ready.</div>
          </div>
        </div>

      </div>
      </main>
    </div>
    <div class="modal" id="bCreateModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Create Bingo Game</div>
          <button class="btn-ghost" id="bCloseCreate">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="bTitle">Title</label>
            <input id="bTitle" placeholder="Bingo Night">
          </div>
          <div>
            <label for="bHeader">Header</label>
            <input id="bHeader" placeholder="BING" maxlength="4">
          </div>
          <div>
            <label for="bPrice">Price</label>
            <input id="bPrice" type="number" value="10000">
          </div>
          <div>
            <label for="bCurrency">Currency</label>
            <input id="bCurrency" value="gil">
          </div>
          <div>
            <label for="bMaxCards">Max cards</label>
            <input id="bMaxCards" type="number" value="10">
          </div>
        </div>
        <div class="row">
          <div>
            <label for="bChannelSelect">Channel list</label>
            <select id="bChannelSelect"></select>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="menu-refresh" id="bChannelRefresh" title="Refresh channels" aria-label="Refresh channels">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 5a7 7 0 1 1-6.65 9H3a9 9 0 1 0 2.64-6.36L3 6v6h6l-2.55-2.55A7 7 0 0 1 12 5z"/>
              </svg>
            </button>
          </div>
        </div>
        <input id="bChannel" type="hidden">
        <input id="bCreatedBy" type="hidden">
        <div class="row">
          <div>
            <label for="bAnnounceCalls">
              <input type="checkbox" id="bAnnounceCalls">
              Announce calls in Discord
            </label>
          </div>
          <div>
            <label for="bTheme">Theme color</label>
            <input id="bTheme" type="color" value="#9de07d">
          </div>
          <div>
            <label>Background image</label>
            <button class="btn-ghost icon-btn" id="bCreateBgLibrary" title="Choose from library">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 5h16a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1zm0 2v10h15a0 0 0 0 0 0 0V7H4zm3 8 3-4 3 3 2-2 4 5H7z"/>
              </svg>
            </button>
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="bCreate">Create</button>
          </div>
        </div>
        <div class="status" id="bCreateBgStatus">No background selected.</div>
        <div class="status" id="bCreatePayload">Payload preview: channel_id=?, created_by=?</div>
      </div>
    </div>
    <div class="modal" id="bOwnerModal">
      <div class="modal-card modal-card--wide">
        <div class="modal-header">
          <div class="modal-title">Player Cards</div>
          <button class="btn-ghost" id="bOwnerClose">Close</button>
        </div>
        <div class="context-header" id="bOwnerSummary">
          <div>
            <div class="context-path">Viewing cards for: -</div>
            <div class="context-meta">Total cards: 0</div>
          </div>
          <div class="context-meta owner-filter" id="bOwnerLegend">
            <button class="owner-filter-btn" id="bOwnerFilterCalled" type="button">Called (0)</button>
            <button class="owner-filter-btn" id="bOwnerFilterUncalled" type="button">Uncalled (0)</button>
          </div>
        </div>
        <div class="owner-card-list" id="bOwnerCards">No tickets loaded.</div>
      </div>
    </div>
    <div class="modal" id="bPurchaseModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Player Link</div>
          <button class="btn-ghost" id="bPurchaseClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="bPurchaseLink">Player link</label>
            <input id="bPurchaseLink" readonly>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="bPurchaseCopy">Copy link</button>
          </div>
        </div>
        <div class="status" id="bPurchaseStatus">Ready.</div>
      </div>
    </div>
    <div class="modal" id="uploadLibraryModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title" id="uploadLibraryTitle">Image Library</div>
          <button class="btn-ghost" id="uploadLibraryClose">Close</button>
        </div>
        <div class="library-layout">
          <section class="library-upload">
            <div class="library-section-title">Add new media</div>
            <div class="upload-drop" id="uploadLibraryDrop" role="button" tabindex="0">
              <div class="upload-drop-title" id="uploadLibraryDropTitle">Drag &amp; drop an image</div>
              <div class="upload-drop-meta" id="uploadLibraryDropMeta">PNG, JPG, GIF, WEBP</div>
              <div class="upload-drop-cta" id="uploadLibraryDropCta">or click to choose</div>
            </div>
            <input id="uploadLibraryFile" type="file" accept="image/*" class="hidden">
            <div>
              <label for="uploadLibraryTitleInput">Title</label>
              <input id="uploadLibraryTitleInput" placeholder="Image title">
            </div>
            <div>
              <label for="uploadLibraryArtist">Artist</label>
              <select id="uploadLibraryArtist"></select>
            </div>
            <button id="uploadLibraryUpload" disabled>Upload</button>
            <div class="status" id="uploadLibraryStatus">Ready.</div>
          </section>
          <section class="library-browser">
            <div class="library-section-title">Existing media</div>
            <div class="library-toolbar">
              <button class="btn-ghost" id="uploadLibraryRefresh">Refresh</button>
            </div>
            <div class="library-grid-scroll">
              <div class="preview-grid" id="uploadLibraryGrid"></div>
            </div>
          </section>
        </div>
      </div>
    </div>
    <div class="modal" id="deckCreateModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Create Deck</div>
          <button class="btn-ghost" id="deckCreateClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="deckCreateId">Deck ID</label>
            <input id="deckCreateId" placeholder="elf-classic">
          </div>
          <div>
            <label for="deckCreateName">Name</label>
            <input id="deckCreateName" placeholder="Elf Classic">
          </div>
          <div>
            <label for="deckCreateTheme">Card theme</label>
            <select id="deckCreateTheme">
              <option value="classic">Classic</option>
              <option value="wood">Wood</option>
              <option value="neon">Neon</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Deck back</label>
            <button class="btn-ghost icon-btn" id="deckCreateBackPick" title="Choose back image">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 5h16a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1zm0 2v10h15a0 0 0 0 0 0 0V7H4zm3 8 3-4 3 3 2-2 4 5H7z"/>
              </svg>
            </button>
          </div>
          <div>
            <label>Back preview</label>
            <div class="preview-card" id="deckCreateBackPreview"><span class="preview-label">Back</span></div>
          </div>
          <div>
            <label for="deckCreateSeed">Seed cards</label>
            <select id="deckCreateSeed">
              <option value="none">None</option>
              <option value="dummy">Dummy per suit</option>
              <option value="default">Default seed</option>
            </select>
          </div>
          <div>
            <label for="deckCreatePerHouse">Per suit</label>
            <input id="deckCreatePerHouse" type="number" value="4" min="0">
          </div>
          <div>
            <label for="deckCreateCrown">Crown</label>
            <input id="deckCreateCrown" type="number" value="1" min="0">
          </div>
        </div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button id="deckCreateSubmit">Create deck</button>
          </div>
        </div>
        <div class="section-divider"></div>
        <h3>Suit Themes</h3>
        <div class="row">
          <div>
            <label for="deckCreateSuitPreset">Suit preset</label>
            <select id="deckCreateSuitPreset">
              <option value="forest">Forest (Roots/Canopy/Ember/Whisper/Crown)</option>
              <option value="tarot">Tarot (Major/Wands/Cups/Swords/Pentacles)</option>
              <option value="playing">Playing Cards (Hearts/Spades/Clubs/Diamonds)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="deckCreateSuitJson">Suit definitions (JSON)</label>
            <textarea id="deckCreateSuitJson" rows="6" placeholder='[{"id":"Roots","name":"Roots","themes":{"foundation":3,"memory":2,"stability":3},"keywords":["home","tradition","endurance","belonging"]}]'></textarea>
          </div>
        </div>
      </div>
    </div>
    <div class="modal" id="deckEditModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Edit Deck</div>
          <button class="btn-ghost" id="deckEditClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="deckEditName">Name</label>
            <input id="deckEditName" placeholder="Elf Classic">
          </div>
          <div>
            <label for="deckEditTheme">Card theme</label>
            <select id="deckEditTheme">
              <option value="classic">Classic</option>
              <option value="wood">Wood</option>
              <option value="neon">Neon</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Deck back</label>
            <button class="btn-ghost icon-btn" id="deckEditBackPick" title="Choose back image">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 5h16a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1zm0 2v10h15a0 0 0 0 0 0 0V7H4zm3 8 3-4 3 3 2-2 4 5H7z"/>
              </svg>
            </button>
          </div>
          <div>
            <label>Back preview</label>
            <div class="preview-card" id="deckEditBackPreview"><span class="preview-label">Back</span></div>
          </div>
        </div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button id="deckEditSubmit">Save changes</button>
          </div>
        </div>
        <div class="section-divider"></div>
        <h3>Suit Themes</h3>
        <div class="row">
          <div>
            <label for="deckEditSuitPreset">Suit preset</label>
            <select id="deckEditSuitPreset">
              <option value="forest">Forest (Roots/Canopy/Ember/Whisper/Crown)</option>
              <option value="tarot">Tarot (Major/Wands/Cups/Swords/Pentacles)</option>
              <option value="playing">Playing Cards (Hearts/Spades/Clubs/Diamonds)</option>
              <option value="custom">Custom</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="deckEditSuitJson">Suit definitions (JSON)</label>
            <textarea id="deckEditSuitJson" rows="6" placeholder='[{"id":"Roots","name":"Roots","themes":{"foundation":3,"memory":2,"stability":3},"keywords":["home","tradition","endurance","belonging"]}]'></textarea>
          </div>
        </div>
      </div>
    </div>
    <div class="modal" id="sessionCreateModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Create Session</div>
          <button class="btn-ghost" id="sessionCreateClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="sessionCreateDeck">Deck</label>
            <select id="sessionCreateDeck"></select>
          </div>
          <div>
            <label for="sessionCreateSpread">Spread</label>
            <select id="sessionCreateSpread">
              <option value="single">Single</option>
              <option value="tree">Tree</option>
              <option value="cross">Cross</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button id="sessionCreateSubmit">Create session</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal" id="mediaModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Media Management</div>
          <button class="btn-ghost" id="mediaClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost icon-btn" id="mediaLibraryOpen" title="Open library">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 5h16a1 1 0 0 1 1 1v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a1 1 0 0 1 1-1zm0 2v10h15a0 0 0 0 0 0 0V7H4zm3 8 3-4 3 3 2-2 4 5H7z"/>
              </svg>
            </button>
          </div>
          <div class="muted" style="align-self:center">Upload and select images from the library.</div>
        </div>
      </div>
    </div>
    <div class="modal" id="artistModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Artist Index</div>
          <button class="btn-ghost" id="artistClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="artistIndexSelect">Artist list</label>
            <select id="artistIndexSelect"></select>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="artistIndexRefresh">Refresh</button>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="artistIndexId">Artist ID (optional)</label>
            <input id="artistIndexId" placeholder="artist_id">
          </div>
          <div>
            <label for="artistIndexName">Name</label>
            <input id="artistIndexName" placeholder="Artist name">
          </div>
        </div>
        <div class="row">
          <div>
            <label for="artistIndexInstagram">Instagram</label>
            <input id="artistIndexInstagram" placeholder="https://instagram.com/...">
          </div>
          <div>
            <label for="artistIndexBluesky">Bluesky</label>
            <input id="artistIndexBluesky" placeholder="https://bsky.app/profile/...">
          </div>
          <div>
            <label for="artistIndexX">X / Twitter</label>
            <input id="artistIndexX" placeholder="https://x.com/...">
          </div>
          <div>
            <label for="artistIndexArtstation">ArtStation</label>
            <input id="artistIndexArtstation" placeholder="https://artstation.com/...">
          </div>
        </div>
        <div class="row">
          <div>
            <label for="artistIndexWebsite">Website</label>
            <input id="artistIndexWebsite" placeholder="https://...">
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="artistIndexSave">Save artist</button>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="artistIndexDelete">Delete artist</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal" id="calendarModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Gallery Calendar</div>
          <button class="btn-ghost" id="calendarClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="calendarMonth">Month</label>
            <select id="calendarMonth"></select>
          </div>
          <div>
            <label for="calendarTitle">Title</label>
            <input id="calendarTitle" placeholder="Optional title">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Artist</label>
            <div class="status" id="calendarArtist">Forest</div>
          </div>
        </div>
        <div class="row">
          <button class="btn-ghost" id="calendarPick">Pick from library</button>
          <button id="calendarSave">Save month</button>
          <button class="btn-ghost" id="calendarClear">Clear month</button>
          <button class="btn-ghost" id="calendarRefresh">Refresh</button>
        </div>
        <div class="row">
          <div>
            <label>Preview</label>
            <div class="preview-card" id="calendarPreview"></div>
          </div>
        </div>
        <div class="status" id="calendarStatus">Ready.</div>
      </div>
    </div>
    <div class="modal" id="galleryModal">
      <div class="modal-card modal-card--wide">
        <div class="modal-header">
          <div class="modal-title">Gallery Admin</div>
          <button class="btn-ghost" id="galleryClose">Close</button>
        </div>
        <h3>Upload Channel</h3>
        <div class="row">
          <div>
            <label for="galleryUploadChannel">Upload channel</label>
            <select id="galleryUploadChannel"></select>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="galleryChannelRefresh">Refresh channels</button>
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="galleryChannelSave">Save channel</button>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="galleryChannelName">Create channel name</label>
            <input id="galleryChannelName" placeholder="forest-gallery-uploads">
          </div>
          <div>
            <label for="galleryChannelCategory">Category ID</label>
            <input id="galleryChannelCategory" placeholder="1234567890">
          </div>
          <div>
            <label for="galleryChannelTemplate">Template channel</label>
            <select id="galleryChannelTemplate"></select>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="galleryChannelCreate">Create channel</button>
          </div>
        </div>
        <div class="status" id="galleryChannelStatus">Pick a channel to use for uploads.</div>
        <div class="section-divider"></div>
        <h3>Gallery Items</h3>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="galleryItemsRefresh">Refresh items</button>
          </div>
        </div>
        <div class="gallery-admin-list" id="galleryItemsList">No items loaded.</div>
        <div class="status" id="galleryItemsStatus">Ready.</div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="galleryImportOpen">Import from Discord channel</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal" id="galleryEditModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Edit Gallery Item</div>
          <button class="btn-ghost" id="galleryEditClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="galleryEditTitle">Title</label>
            <input id="galleryEditTitle" placeholder="Untitled Offering">
          </div>
          <div>
            <label for="galleryEditArtist">Artist</label>
            <select id="galleryEditArtist"></select>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="galleryEditArtistName">Artist name</label>
            <input id="galleryEditArtistName" placeholder="Display name">
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="galleryEditSave">Save</button>
          </div>
        </div>
        <div class="status" id="galleryEditStatus">Ready.</div>
      </div>
    </div>
    <div class="modal" id="galleryImportModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Import Gallery Images</div>
          <button class="btn-ghost" id="galleryImportClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label for="galleryImportChannel">Source channel</label>
            <select id="galleryImportChannel"></select>
          </div>
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="galleryImportRefresh">Refresh channels</button>
          </div>
        </div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button id="galleryImportRun">Import images</button>
          </div>
        </div>
        <div class="status" id="galleryImportStatus">Pick a channel to import.</div>
      </div>
    </div>
    <div class="modal" id="authRolesModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Auth Roles</div>
          <button class="btn-ghost" id="authRolesClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="authRolesRefresh">Refresh roles</button>
          </div>
          <div class="muted" style="align-self:center">Select scopes each role can reach via /auth.</div>
        </div>
        <div class="role-table-wrap" id="authRolesWrap">
          <div class="list" id="authRolesList">No roles loaded.</div>
        </div>
        <div class="row">
          <div>
            <label for="authRoleIds">Selected role IDs</label>
            <input id="authRoleIds" readonly>
          </div>
          <div>
            <label>&nbsp;</label>
            <button id="authRolesSave">Save</button>
          </div>
        </div>
        <div class="status" id="authRolesStatus">Ready.</div>
      </div>
    </div>
    <div class="modal" id="authTokensModal">
      <div class="modal-card">
        <div class="modal-header">
          <div class="modal-title">Auth Keys</div>
          <button class="btn-ghost" id="authTokensClose">Close</button>
        </div>
        <div class="row">
          <div>
            <label>&nbsp;</label>
            <button class="btn-ghost" id="authTokensRefresh">Refresh keys</button>
          </div>
          <div class="muted" style="align-self:center">Active web tokens and remaining lifetime.</div>
        </div>
        <div class="role-table-wrap" id="authTokensWrap">
          <div class="list" id="authTokensList">No keys loaded.</div>
        </div>
        <div class="status" id="authTokensStatus">Ready.</div>
      </div>
    </div>
    <script>
      const $ = (id) => document.getElementById(id);
      const statusEl = $("status");
      const loginStatusEl = $("loginStatus");
      const apiKeyEl = $("apiKeyLogin");
      const overlayToggle = $("overlayMode");
      const overlayToggleBtn = $("menuOverlayToggle");
      const storage = window.localStorage;
      const CONTEST_CATEGORY_ID = "1239558949351460904";
      let currentCard = null;
      let currentGame = null;
      let taSelectedCardId = "";
      let lastCalledCount = 0;
      let lastCalloutNumber = null;
      let activeGameId = "";
      let currentOwner = "";
      window.taArtists = [];
      let calendarData = [];
      let authUserScopes = new Set();
      let authUserIsElfmin = false;
      let authTokensCache = [];
      let calendarSelected = {
        month: 1,
        image: "",
        title: "",
        artist_id: null,
        artist_name: "Forest"
      };
      let bingoCreateBgUrl = "";
      let authRoleIds = new Set();
      let authRoleScopes = {};
      let authRolesCache = [];
      const authScopeOptions = [
        {id: "*", label: "All access"},
        {id: "bingo:admin", label: "Bingo admin"},
        {id: "tarot:admin", label: "Tarot admin"},
        {id: "tarot:control", label: "Tarot control"},
        {id: "admin:message", label: "Admin messages"},
        {id: "admin:announce", label: "Admin announce"},
        {id: "admin:web", label: "Admin web"},
        {id: "hunt:admin", label: "Hunt admin"}
      ];
      const SUIT_PRESETS = {
        forest: [
          {
            id: "Roots",
            name: "Roots",
            themes: {foundation: 3, memory: 2, stability: 3},
            keywords: ["home", "tradition", "endurance", "belonging"]
          },
          {
            id: "Canopy",
            name: "Canopy",
            themes: {growth: 3, connection: 3, hope: 2},
            keywords: ["healing", "community", "relationships", "renewal"]
          },
          {
            id: "Ember",
            name: "Ember",
            themes: {will: 3, conflict: 2, passion: 3},
            keywords: ["drive", "courage", "ambition", "trial"]
          },
          {
            id: "Whisper",
            name: "Whisper",
            themes: {secrets: 2, change: 3, curiosity: 3},
            keywords: ["insight", "illusion", "trickery", "exploration"]
          },
          {
            id: "Crown",
            name: "Crown of the Tree",
            themes: {fate: 3, cycles: 3, balance: 2},
            keywords: ["destiny", "turning point", "world forces"]
          }
        ],
        tarot: [
          {id: "Major", name: "Major", themes: {}, keywords: []},
          {id: "Wands", name: "Wands", themes: {}, keywords: []},
          {id: "Cups", name: "Cups", themes: {}, keywords: []},
          {id: "Swords", name: "Swords", themes: {}, keywords: []},
          {id: "Pentacles", name: "Pentacles", themes: {}, keywords: []}
        ],
        playing: [
          {id: "Hearts", name: "Hearts", themes: {}, keywords: []},
          {id: "Spades", name: "Spades", themes: {}, keywords: []},
          {id: "Clubs", name: "Clubs", themes: {}, keywords: []},
          {id: "Diamonds", name: "Diamonds", themes: {}, keywords: []}
        ]
      };

      function getBase(){
        return window.location.origin;
      }

      let librarySelectHandler = null;
      let libraryKind = "";
      let libraryUploadFile = null;
      let mediaUploadFile = null;
      let deckEditHadSuits = false;

      function setLibraryStatus(msg, kind){
        const el = $("uploadLibraryStatus");
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function setMediaUploadStatus(msg, kind){
        const el = $("mediaUploadStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function setMediaLibraryStatus(msg, kind){
        const el = $("mediaLibraryStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function updateUploadDropDisplay(file){
        const title = $("uploadLibraryDropTitle");
        const meta = $("uploadLibraryDropMeta");
        const cta = $("uploadLibraryDropCta");
        if (!title || !meta || !cta) return;
        if (file){
          title.textContent = `Selected: ${file.name}`;
          meta.textContent = `${Math.round(file.size / 1024)} KB`;
          cta.textContent = "Click to replace";
        }else{
          title.textContent = "Drag & drop an image";
          meta.textContent = "PNG, JPG, GIF, WEBP";
          cta.textContent = "or click to choose";
        }
      }

      function updateUploadState(){
        const file = libraryUploadFile || ($("uploadLibraryFile").files[0] || null);
        const title = $("uploadLibraryTitleInput").value.trim();
        const btn = $("uploadLibraryUpload");
        if (btn){
          btn.disabled = !(file && title);
        }
      }

      function formatSuitPresetJson(key){
        const preset = SUIT_PRESETS[key] || [];
        return JSON.stringify(preset, null, 2);
      }

      function parseSuitJson(raw){
        const text = (raw || "").trim();
        if (!text){
          return [];
        }
        const parsed = JSON.parse(text);
        if (!Array.isArray(parsed)){
          throw new Error("Suit definitions must be a JSON array.");
        }
        return parsed;
      }

      function updateMediaUploadDropDisplay(file){
        const title = $("mediaUploadDropTitle");
        const meta = $("mediaUploadDropMeta");
        const cta = $("mediaUploadDropCta");
        if (!title || !meta || !cta) return;
        if (file){
          title.textContent = `Selected: ${file.name}`;
          meta.textContent = `${Math.round(file.size / 1024)} KB`;
          cta.textContent = "Click to replace";
        }else{
          title.textContent = "Drag & drop an image";
          meta.textContent = "PNG, JPG, GIF, WEBP";
          cta.textContent = "or click to choose";
        }
      }

      function updateMediaUploadState(){
        const file = mediaUploadFile || ($("mediaUploadFile") ? $("mediaUploadFile").files[0] : null);
        const title = $("mediaUploadTitleInput") ? $("mediaUploadTitleInput").value.trim() : "";
        const btn = $("mediaUploadUpload");
        if (btn){
          btn.disabled = !(file && title);
        }
      }

      function showLibraryModal(show){
        $("uploadLibraryModal").classList.toggle("show", !!show);
        if (show){
          $("mediaModal").classList.remove("show");
          $("artistModal").classList.remove("show");
          $("calendarModal").classList.remove("show");
          updateUploadDropDisplay(libraryUploadFile);
          updateUploadState();
        }
      }

      async function loadLibrary(kind, opts){
        libraryKind = kind;
        const config = opts || {};
        const grid = config.grid || $("uploadLibraryGrid");
        const title = Object.prototype.hasOwnProperty.call(config, "title") ? config.title : $("uploadLibraryTitle");
        const setStatus = config.setStatus || setLibraryStatus;
        const onSelect = config.onSelect || librarySelectHandler;
        const showUse = Object.prototype.hasOwnProperty.call(config, "showUse") ? config.showUse : !!onSelect;
        const showCopy = !!config.showCopy;
        const closeOnUse = config.closeOnUse !== false;
        if (title){
          title.textContent = config.titleText || "Media Library";
        }
        if (!grid){
          return;
        }
        grid.innerHTML = "";
        setStatus("Loading...", "");
        const path = "/api/media/list";
        try{
          const res = await fetch(path, {headers: {"X-API-Key": apiKeyEl.value.trim()}});
          if (res.status === 401){
            handleUnauthorized();
            throw new Error("Unauthorized");
          }
          const data = await res.json();
          if (!data.ok) throw new Error(data.error || "Failed");
          const items = data.items || [];
          if (!items.length){
            setStatus("No images found.", "err");
            return;
          }
          items.forEach(item => {
            const card = document.createElement("div");
            card.className = "preview-card library-card";

            const img = document.createElement("img");
            img.src = item.url;
            img.alt = item.name || "image";
            if (item.fallback_url){
              img.dataset.fallback = item.fallback_url;
              img.addEventListener("error", () => {
                if (img.dataset.fallback && img.src !== img.dataset.fallback){
                  img.src = img.dataset.fallback;
                }
              });
            }

            const titleText = document.createElement("div");
            titleText.className = "library-card-title";
            titleText.textContent = item.title || item.name || "Untitled";

            const artist = document.createElement("div");
            artist.className = "library-card-artist";
            if (item.artist_id || item.artist_name){
              artist.textContent = "Artist: ";
              const artistBtn = document.createElement("button");
              artistBtn.type = "button";
              artistBtn.textContent = item.artist_name || item.artist_id || "Unknown";
              artistBtn.addEventListener("click", () => openArtistIndex(item.artist_id || "", setStatus));
              artist.appendChild(artistBtn);
            }else{
              artist.textContent = "Artist: Unassigned";
            }

            const badges = document.createElement("div");
            badges.className = "library-badges";
            const usedIn = Array.isArray(item.used_in) ? item.used_in : [];
            usedIn.forEach(label => {
              const badge = document.createElement("span");
              badge.className = "library-badge";
              badge.textContent = label;
              badges.appendChild(badge);
            });

            const actions = document.createElement("div");
            actions.className = "library-actions";
            if (showUse){
              const useBtn = document.createElement("button");
              useBtn.type = "button";
              useBtn.className = "btn-primary";
              useBtn.textContent = "Use";
              useBtn.addEventListener("click", () => {
                if (onSelect){
                  onSelect(item);
                }
                if (closeOnUse){
                  showLibraryModal(false);
                }
              });
              actions.appendChild(useBtn);
            }
            if (showCopy){
              const copyBtn = document.createElement("button");
              copyBtn.type = "button";
              copyBtn.className = "btn-ghost";
              copyBtn.textContent = "Copy URL";
              copyBtn.addEventListener("click", async () => {
                try{
                  await navigator.clipboard.writeText(item.url || "");
                  setStatus("Image URL copied.", "ok");
                }catch(err){
                  setStatus("Copy failed.", "err");
                }
              });
              actions.appendChild(copyBtn);
            }

            if (authUserIsElfmin && item.delete_url){
              const del = document.createElement("button");
              del.type = "button";
              del.className = "btn-ghost btn-danger";
              del.textContent = "Delete";
              del.addEventListener("click", async () => {
                const usage = usedIn.length ? `This image is used in: ${usedIn.join(", ")}.` : "";
                const prompt = usage
                  ? `${usage} This image may be used elsewhere. Continue?`
                  : "This image may be used elsewhere. Continue?";
                if (!confirm(prompt)) return;
                try{
                  const delUrl = item.delete_url || "";
                  if (!delUrl){
                    throw new Error("Delete not available");
                  }
                  const res = await fetch(delUrl, {method: "DELETE", headers: {"X-API-Key": apiKeyEl.value.trim()}});
                  const data = await res.json().catch(() => ({}));
                  if (!res.ok || data.ok === false){
                    throw new Error(data.error || "Delete failed");
                  }
                  await loadLibrary(libraryKind, config);
                }catch(err){
                  setStatus(err.message, "err");
                }
              });
              actions.appendChild(del);
            }

            card.appendChild(img);
            card.appendChild(titleText);
            card.appendChild(artist);
            if (usedIn.length){
              card.appendChild(badges);
            }
            card.appendChild(actions);
            grid.appendChild(card);
          });
          setStatus(showUse && onSelect ? "Pick an image." : "Library loaded.", "ok");
        }catch(err){
          setStatus(err.message, "err");
        }
      }

      async function openArtistIndex(artistId, statusFn){
        const notify = statusFn || setLibraryStatus;
        if (!artistId){
          notify("No artist assigned.", "alert");
          return;
        }
        $("artistModal").classList.add("show");
        await loadTarotArtists();
        const select = $("artistIndexSelect");
        if (select){
          select.value = artistId;
          select.dispatchEvent(new Event("change"));
        }
      }

      function setCalendarStatus(msg, kind){
        const el = $("calendarStatus");
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      async function loadMediaLibrary(){
        const grid = $("mediaLibraryGrid");
        if (!grid) return;
        await loadLibrary("media", {
          grid,
          title: null,
          setStatus: setMediaLibraryStatus,
          showUse: false,
          showCopy: true,
          closeOnUse: false,
          onSelect: null
        });
      }

      function setAuthRolesStatus(msg, kind){
        const el = $("authRolesStatus");
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function setAuthTokensStatus(msg, kind){
        const el = $("authTokensStatus");
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function computeElfminAccess(scopes, source){
        if (source === "api_key"){
          return true;
        }
        const set = new Set(Array.from(scopes || []).map(String));
        return set.has("*") || set.has("bingo:admin");
      }

      function applyElfminVisibility(){
        const isElfmin = !!authUserIsElfmin;
        const authRolesBtn = $("menuAuthRoles");
        const authKeysBtn = $("menuAuthKeys");
        const deckDeleteBtn = $("taDeleteDeck");
        if (authRolesBtn){
          authRolesBtn.classList.toggle("hidden", !isElfmin);
        }
        if (authKeysBtn){
          authKeysBtn.classList.toggle("hidden", !isElfmin);
        }
        if (deckDeleteBtn){
          deckDeleteBtn.classList.toggle("hidden", !isElfmin);
          deckDeleteBtn.disabled = !isElfmin;
        }
      }

      function updateAuthRoleIdsField(){
        authRoleIds = new Set(Object.keys(authRoleScopes || {}));
        $("authRoleIds").value = Array.from(authRoleIds).join(", ");
      }

      function normalizeAuthRoleScopes(map){
        const normalized = {};
        Object.entries(map || {}).forEach(([roleId, scopes]) => {
          const id = String(roleId).trim();
          if (!id) return;
          let list = [];
          if (Array.isArray(scopes)){
            list = scopes.map(s => String(s).trim()).filter(Boolean);
          } else if (typeof scopes === "string"){
            list = scopes.split(",").map(s => s.trim()).filter(Boolean);
          }
          if (list.includes("*")) list = ["*"];
          if (list.length){
            normalized[id] = list;
          }
        });
        return normalized;
      }

      function renderAuthRolesList(roles){
        if (!roles.length){
          $("authRolesList").textContent = "No roles found.";
          updateAuthRoleIdsField();
          return;
        }
        const headerCells = authScopeOptions.map(scope => `<th>${scope.label}</th>`).join("");
        const rows = roles.map(role => {
          const roleId = String(role.id);
          const roleName = role.name || roleId;
          const scopes = new Set((authRoleScopes[roleId] || []).map(String));
          const cells = authScopeOptions.map(scope => {
            const checked = scopes.has(scope.id) ? "checked" : "";
            const disabled = scopes.has("*") && scope.id !== "*" ? "disabled" : "";
            return `<td class="role-scope-cell"><input type="checkbox" data-role="${roleId}" data-scope="${scope.id}" ${checked} ${disabled}></td>`;
          }).join("");
          return `<tr><td class="role-name">${roleName}</td>${cells}</tr>`;
        }).join("");
        $("authRolesList").innerHTML = `<table class="role-table"><thead><tr><th>Role</th>${headerCells}</tr></thead><tbody>${rows}</tbody></table>`;
        updateAuthRoleIdsField();
      }

      async function loadAuthRoles(){
        setAuthRolesStatus("Loading roles...", "");
        $("authRolesList").textContent = "Loading...";
        try{
          const current = await jsonFetch("/api/auth/roles", {method:"GET"});
          authRoleScopes = normalizeAuthRoleScopes(current.role_scopes || {});
          if (!current.role_scopes_configured && !Object.keys(authRoleScopes).length && (current.role_ids || []).length){
            const legacy = {};
            (current.role_ids || []).forEach(id => {
              legacy[String(id)] = ["*"];
            });
            authRoleScopes = legacy;
          }
          const res = await jsonFetch("/discord/roles", {method:"GET"});
          const roles = res.roles || [];
          authRolesCache = roles;
          renderAuthRolesList(roles);
          setAuthRolesStatus("Ready.", "ok");
        }catch(err){
          setAuthRolesStatus(err.message, "err");
          $("authRolesList").textContent = "Failed to load roles.";
        }
      }

      function formatAuthTokenDuration(seconds){
        const total = Math.max(0, Number(seconds) || 0);
        if (!total) return "Expired";
        const hours = Math.floor(total / 3600);
        const minutes = Math.floor((total % 3600) / 60);
        const secs = total % 60;
        if (hours > 0){
          return `${hours}h ${minutes}m`;
        }
        if (minutes > 0){
          return `${minutes}m ${secs}s`;
        }
        return `${secs}s`;
      }

      function formatAuthTokenExpiry(token){
        const duration = formatAuthTokenDuration(token.expires_in);
        if (!token.expires_at){
          return duration;
        }
        const stamp = new Date(Number(token.expires_at) * 1000);
        return `${duration} (${stamp.toLocaleString()})`;
      }

      function renderAuthTokensList(tokens){
        const list = $("authTokensList");
        list.innerHTML = "";
        if (!tokens || !tokens.length){
          list.textContent = "No keys loaded.";
          return;
        }
        const table = document.createElement("table");
        table.className = "role-table";
        const thead = document.createElement("thead");
        const headRow = document.createElement("tr");
        ["User", "Token", "Scopes", "Expires", "Actions"].forEach(label => {
          const th = document.createElement("th");
          th.textContent = label;
          headRow.appendChild(th);
        });
        thead.appendChild(headRow);
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        tokens.forEach(token => {
          const tr = document.createElement("tr");
          const userCell = document.createElement("td");
          userCell.textContent = token.user_name || token.user_id || "Unknown";
          const tokenCell = document.createElement("td");
          const code = document.createElement("code");
          code.className = "token-code";
          code.textContent = token.token || "";
          tokenCell.appendChild(code);
          const tokenMeta = document.createElement("div");
          tokenMeta.className = "token-actions";
          const copyBtn = document.createElement("button");
          copyBtn.className = "btn-ghost";
          copyBtn.textContent = "Copy";
          copyBtn.addEventListener("click", async () => {
            try{
              await navigator.clipboard.writeText(token.token || "");
              setAuthTokensStatus("Copied token.", "ok");
            }catch(err){
              setAuthTokensStatus("Copy failed.", "err");
            }
          });
          tokenMeta.appendChild(copyBtn);
          tokenCell.appendChild(tokenMeta);
          const scopeCell = document.createElement("td");
          scopeCell.textContent = (token.scopes || []).join(", ");
          const expiresCell = document.createElement("td");
          expiresCell.textContent = formatAuthTokenExpiry(token);
          const actionsCell = document.createElement("td");
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "btn-ghost";
          deleteBtn.textContent = "Delete";
          deleteBtn.addEventListener("click", async () => {
            if (!confirm("Delete this auth key? This will revoke access.")){
              return;
            }
            try{
              const res = await fetch("/api/auth/tokens/" + encodeURIComponent(token.token || ""), {
                method: "DELETE",
                headers: {"X-API-Key": apiKeyEl.value.trim()}
              });
              const data = await res.json().catch(() => ({}));
              if (!res.ok || data.ok === false){
                throw new Error(data.error || "Delete failed");
              }
              await loadAuthTokens();
              setAuthTokensStatus("Auth key deleted.", "ok");
            }catch(err){
              setAuthTokensStatus(err.message, "err");
            }
          });
          actionsCell.appendChild(deleteBtn);
          tr.appendChild(userCell);
          tr.appendChild(tokenCell);
          tr.appendChild(scopeCell);
          tr.appendChild(expiresCell);
          tr.appendChild(actionsCell);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        list.appendChild(table);
      }

      async function loadAuthTokens(){
        setAuthTokensStatus("Loading keys...", "");
        $("authTokensList").textContent = "Loading...";
        try{
          const res = await fetch("/api/auth/tokens", {headers: {"X-API-Key": apiKeyEl.value.trim()}});
          if (res.status === 401){
            handleUnauthorized();
            throw new Error("Unauthorized");
          }
          const data = await res.json();
          if (!data.ok) throw new Error(data.error || "Failed");
          authTokensCache = data.tokens || [];
          renderAuthTokensList(authTokensCache);
          setAuthTokensStatus("Ready.", "ok");
        }catch(err){
          setAuthTokensStatus(err.message, "err");
          $("authTokensList").textContent = "Failed to load keys.";
        }
      }

      function renderCalendarPreview(){
        const preview = `${emoji} | ${name}`;
        preview.innerHTML = "";
        if (!calendarSelected.image){
          preview.textContent = "No image selected.";
          return;
        }
        const img = document.createElement("img");
        img.src = calendarSelected.image;
        img.alt = calendarSelected.title || "calendar";
        preview.appendChild(img);
      }

      function applyCalendarSelection(entry){
        calendarSelected = {
          month: entry.month,
          image: entry.image || "",
          title: entry.title || "",
          artist_id: (entry.artist && entry.artist.artist_id) || null,
          artist_name: (entry.artist && entry.artist.name) || "Forest"
        };
        $("calendarTitle").value = calendarSelected.title;
        $("calendarArtist").textContent = calendarSelected.artist_name || "Forest";
        renderCalendarPreview();
      }

      function populateCalendarMonths(){
        const select = $("calendarMonth");
        select.innerHTML = "";
        calendarData.forEach(entry => {
          const opt = document.createElement("option");
          opt.value = entry.month;
          opt.textContent = entry.month_name || `Month ${entry.month}`;
          select.appendChild(opt);
        });
        const current = calendarSelected.month || 1;
        select.value = String(current);
      }

      async function loadCalendarAdmin(){
        setCalendarStatus("Loading...", "");
        try{
          const res = await fetch("/api/gallery/calendar", {headers: {"X-API-Key": apiKeyEl.value.trim()}});
          if (res.status === 401){
            handleUnauthorized();
            throw new Error("Unauthorized");
          }
          const data = await res.json();
          if (!data.ok) throw new Error(data.error || "Failed");
          calendarData = data.months || [];
          if (!calendarData.length){
            calendarData = [];
            setCalendarStatus("No calendar data.", "err");
            return;
          }
          populateCalendarMonths();
          const entry = calendarData.find(e => e.month === (calendarSelected.month || 1)) || calendarData[0];
          applyCalendarSelection(entry);
          setCalendarStatus("Ready.", "ok");
        }catch(err){
          setCalendarStatus(err.message, "err");
        }
      }

      function getGameId(){
        return ($("bGameId").dataset.gameId || "").trim();
      }

      function setGameId(id){
        const gid = (id || "").trim();
        $("bGameId").dataset.gameId = gid;
        $("bGameId").textContent = gid ? gid : "No game selected.";
      }

      function setStatus(msg, kind){
        const textEl = $("statusText");
        const timeEl = $("statusTime");
        if (textEl){
          textEl.textContent = msg;
        }else{
          statusEl.textContent = msg;
        }
        if (timeEl){
          const now = new Date();
          timeEl.textContent = now.toLocaleTimeString([], {hour: "2-digit", minute: "2-digit"});
        }
        statusEl.className = "status-bar status" + (kind ? " " + kind : "");
      }

      function setBingoStatus(msg, kind){
        const el = $("bingoStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function applyTheme(color){
        const panel = $("bingoPanel");
        if (!panel){
          return;
        }
        if (!color){
          panel.style.removeProperty("--accent");
          panel.style.removeProperty("--accent-2");
          panel.style.removeProperty("--line");
          panel.style.removeProperty("--panel");
          return;
        }
        const hex = color.startsWith("#") ? color.slice(1) : color;
        if (hex.length !== 6) return;
        const r = parseInt(hex.slice(0,2), 16);
        const g = parseInt(hex.slice(2,4), 16);
        const b = parseInt(hex.slice(4,6), 16);
        const mix = (c, t, p) => Math.round(c + (t - c) * p);
        const toHex = (v) => v.toString(16).padStart(2, "0");
        const dark = `#${toHex(mix(r, 0, 0.6))}${toHex(mix(g, 0, 0.6))}${toHex(mix(b, 0, 0.6))}`;
        const darker = `#${toHex(mix(r, 0, 0.8))}${toHex(mix(g, 0, 0.8))}${toHex(mix(b, 0, 0.8))}`;
        const light = `#${toHex(mix(r, 255, 0.35))}${toHex(mix(g, 255, 0.35))}${toHex(mix(b, 255, 0.35))}`;
        panel.style.setProperty("--accent", light);
        panel.style.setProperty("--accent-2", `#${hex}`);
        panel.style.setProperty("--line", dark);
        panel.style.setProperty("--panel", darker);
      }

      function loadSettings(){
        apiKeyEl.value = storage.getItem("bt_api_key") || "";
        overlayToggle.checked = storage.getItem("bt_overlay") === "1";
        if (overlayToggle.checked) document.body.classList.add("overlay");
        overlayToggleBtn.classList.toggle("active", overlayToggle.checked);
      }

      function saveSettings(){
        storage.setItem("bt_api_key", apiKeyEl.value.trim());
        storage.setItem("bt_overlay", overlayToggle.checked ? "1" : "0");
      }

      function apiFetch(path, opts, withKey = true){
        const base = getBase();
        const url = new URL(path, base).toString();
        const options = opts || {};
        options.headers = options.headers || {};
        if (withKey){
          const key = apiKeyEl.value.trim();
          if (key) options.headers["X-API-Key"] = key;
        }
        return fetch(url, options);
      }

      async function jsonFetch(path, opts, withKey = true){
        const res = await apiFetch(path, opts, withKey);
        if (res.status === 401){
          handleUnauthorized();
          throw new Error("Unauthorized");
        }
        const data = await res.json().catch(() => ({}));
        if (!res.ok){
          throw new Error(data.error || "Request failed");
        }
        return data;
      }

      function handleUnauthorized(){
        apiKeyEl.value = "";
        document.getElementById("appView").classList.add("hidden");
        document.getElementById("loginView").classList.remove("hidden");
        loginStatusEl.textContent = "Unauthorized. Please log in again.";
        loginStatusEl.className = "status err";
        overlayToggle.checked = false;
        document.body.classList.remove("overlay");
        saveSettings();
        const brandUser = $("brandUser");
        const brandUserName = $("brandUserName");
        const brandUserIcon = $("brandUserIcon");
        const brandUserFallback = $("brandUserFallback");
        if (brandUser){
          if (brandUserName){
            brandUserName.textContent = "";
          }
          if (brandUserIcon){
            brandUserIcon.src = "";
            brandUserIcon.classList.add("hidden");
          }
          if (brandUserFallback){
            brandUserFallback.classList.remove("hidden");
          }
          brandUser.classList.add("hidden");
        }
      }

      async function loadAuthUser(){
        const brandUser = $("brandUser");
        const brandUserName = $("brandUserName");
        const brandUserIcon = $("brandUserIcon");
        const brandUserFallback = $("brandUserFallback");
        if (!brandUser || !brandUserName || !brandUserIcon || !brandUserFallback){
          return;
        }
        try{
          const data = await jsonFetch("/api/auth/me", {method:"GET"}, true);
          const name = data.user_name || data.user_id || "";
          const icon = data.user_icon || "";
          const userId = data.user_id || "";
          authUserScopes = new Set((data.scopes || []).map(String));
          authUserIsElfmin = computeElfminAccess(authUserScopes, data.source);
          applyElfminVisibility();
          const createdBy = $("bCreatedBy");
          if (createdBy){
            createdBy.value = userId ? String(userId) : "";
          }
          updateBingoCreatePayload();
          if (name){
            brandUserName.textContent = name;
            brandUser.classList.remove("hidden");
            if (icon){
              brandUserIcon.src = icon;
              brandUserIcon.classList.remove("hidden");
              brandUserFallback.classList.add("hidden");
            }else{
              brandUserIcon.src = "";
              brandUserIcon.classList.add("hidden");
              brandUserFallback.classList.remove("hidden");
            }
          }else{
            brandUserName.textContent = "";
            brandUser.classList.add("hidden");
          }
        }catch(err){
          brandUserName.textContent = "";
          brandUserIcon.src = "";
          brandUserIcon.classList.add("hidden");
          brandUserFallback.classList.remove("hidden");
          brandUser.classList.add("hidden");
          authUserScopes = new Set();
          authUserIsElfmin = false;
          applyElfminVisibility();
          const createdBy = $("bCreatedBy");
          if (createdBy){
            createdBy.value = "";
          }
          updateBingoCreatePayload();
        }
      }

      function showList(el, data){
        if (data && Array.isArray(data.cards)){
          if (!data.cards.length){
            el.textContent = "No cards loaded.";
            if (el.id === "taDeckList"){
              window.taDeckData = data;
              const deckLabel = (data.deck && (data.deck.name || data.deck.deck_id)) || "Deck";
              setTarotStatus(`Deck loaded: ${deckLabel} (0 cards)`, "ok");
              taUpdateContext(null);
              taDirty = false;
            }
            return;
          }
          const deckLabel = (data.deck && (data.deck.name || data.deck.deck_id)) || "";
          const header = deckLabel ? `<div class="list-header">Deck: ${deckLabel}</div>` : "";
          const items = data.cards.map(c => {
            const name = c.name || c.card_id || "Untitled";
            const id = c.card_id ? ` (${c.card_id})` : "";
            const suit = c.suit || "";
            const suitLower = suit.toLowerCase();
            const suitMap = {
              wands: "Clubs",
              cups: "Hearts",
              swords: "Spades",
              pentacles: "Diamonds",
              clubs: "Clubs",
              hearts: "Hearts",
              spades: "Spades",
              diamonds: "Diamonds"
            };
            const playingSuit = suitLower === "major" ? "" : (suitMap[suitLower] || "");
            const playingLabel = playingSuit && playingSuit.toLowerCase() !== suitLower ? playingSuit : "";
            const suitMeta = suit || playingLabel
              ? `<div class="muted">${suit || "-"}${playingLabel ? ` · ${playingLabel}` : ""}</div>`
              : "";
            return `<div class="list-card clickable" data-card-id="${c.card_id || ""}"><strong>${name}</strong><span class="muted">${id}</span>${suitMeta}</div>`;
          }).join("");
          el.innerHTML = header + items;
          if (el.id === "taDeckList"){
            window.taDeckData = data;
            taSyncCardSelection();
            const deckName = deckLabel || (data.deck && data.deck.deck_id) || "Deck";
            setTarotStatus(`Deck loaded: ${deckName} (${data.cards.length} cards)`, "ok");
            taUpdateContext(null);
            taDirty = false;
          }
          return;
        }
        el.textContent = JSON.stringify(data, null, 2);
      }

      function renderBingoState(data){
        const game = (data && data.game) || {};
        currentGame = game;
        applyTheme(game.theme_color || null);
        const gid = getGameId();
        if (gid !== activeGameId){
          activeGameId = gid;
          lastCalledCount = 0;
          lastCalloutNumber = null;
        }
        $("bTitleVal").textContent = game.title || "No title";
        $("bHeaderVal").textContent = game.header_text || game.header || "No header";
        $("bStageVal").textContent = game.stage || "No stage";
        $("bPotVal").textContent = (game.pot != null ? `${formatGil(game.pot)} ${game.currency || ""}` : "No pot");
        const announceToggle = $("bAnnounceToggle");
        if (announceToggle){
          announceToggle.checked = !!game.announce_calls;
        }
        const announceBadge = $("bAnnounceBadge");
        if (announceBadge){
          announceBadge.textContent = announceToggle && announceToggle.checked ? "On" : "Off";
          announceBadge.className = "status-badge" + (announceToggle && announceToggle.checked ? " good" : "");
        }
        const statusBadge = $("bGameStatus");
        if (statusBadge){
          let label = "No game";
          let cls = "status-badge";
          if (game && game.game_id){
            if (game.active === false){
              label = "Closed";
              cls += " bad";
            } else if (game.started){
              label = "Running";
              cls += " good";
            } else {
              label = "Paused";
              cls += " warn";
            }
          }
          statusBadge.textContent = label;
          statusBadge.className = cls;
        }
        const contextPath = $("bContextPath");
        const contextMeta = $("bContextMeta");
        const contextTitle = $("bContextTitle");
        if (contextPath){
          const label = game.title || "No game selected";
          contextPath.textContent = `Bingo / Manager / ${label}`;
        }
        if (contextMeta){
          contextMeta.textContent = game.game_id ? `Managing ${game.game_id}` : "Pick a game to manage.";
        }
        if (contextTitle){
          contextTitle.textContent = game.game_id ? `${game.title || "Untitled"} (${game.game_id})` : "";
        }
        const called = Array.isArray(game.called) ? game.called : [];
        $("bCalled").textContent = called.length ? ("Called numbers: " + called.join(", ")) : "No numbers called yet.";
        const buyBtn = $("bBuy");
        if (buyBtn){
          buyBtn.disabled = !(game.game_id && game.active !== false && !game.started && called.length === 0);
        }
        const startBtn = $("bStart");
        if (startBtn){
          startBtn.disabled = !(game.active !== false && !game.started);
        }
        const rollBtn = $("bRoll");
        if (rollBtn){
          rollBtn.disabled = !(game.active !== false && game.started);
        }
        const refreshBtn = $("bRefresh");
        if (refreshBtn){
          refreshBtn.disabled = !game.game_id;
        }
        const closeBtn = $("bCloseGame");
        if (closeBtn){
          closeBtn.disabled = !game.game_id;
        }
        const advanceBtn = $("bAdvanceStage");
        if (advanceBtn){
          advanceBtn.disabled = !game.game_id || game.active === false;
        }
        renderCalledGrid(called);
        const bgPath = game.background ? new URL(game.background, getBase()).toString() : "";
        const cardWrap = $("bCard");
        cardWrap.style.backgroundImage = bgPath ? `linear-gradient(180deg, rgba(6,10,18,.85), rgba(6,10,18,.6)), url('${bgPath}')` : "";
        const last = game.last_called != null ? game.last_called : (called.length ? called[called.length - 1] : null);
        if (last != null && last !== lastCalloutNumber){
          showCallout(`Called ${last}`);
          lastCalloutNumber = last;
          setBingoStatus(`Number called: ${last}`, "ok");
        }
        if (!game.game_id){
          setBingoStatus("No game selected.", "alert");
        }
        lastCalledCount = called.length;
        renderClaims(game);
      }

      function renderClaims(game){
        const el = $("bClaims");
        const claims = (game && Array.isArray(game.claims)) ? game.claims : [];
        if (!claims.length){
          el.innerHTML = "<div class=\"muted\">No claims yet.</div>";
          return;
        }
        el.innerHTML = "";
        claims.slice().reverse().forEach(c => {
          const row = document.createElement("div");
          row.style.padding = "8px 6px";
          row.style.borderBottom = "1px solid rgba(255,255,255,0.06)";
          const status = c.pending ? "pending" : (c.denied ? "denied" : "approved");
          const label = `${c.owner_name || "Unknown"} - ${c.card_id || ""} - ${c.stage || ""} - ${status}`;
          const wrap = document.createElement("div");
          wrap.style.display = "flex";
          wrap.style.alignItems = "center";
          wrap.style.justifyContent = "space-between";
          wrap.style.gap = "10px";
          const text = document.createElement("div");
          text.textContent = label;
          wrap.appendChild(text);
          if (c.pending){
            const btnWrap = document.createElement("div");
            btnWrap.style.display = "flex";
            btnWrap.style.gap = "8px";
            const btn = document.createElement("button");
            btn.textContent = "Confirm + Advance";
            btn.className = "btn-primary";
            btn.style.maxWidth = "160px";
            btn.onclick = async () => {
              try{
                await jsonFetch("/bingo/claim-approve", {
                  method:"POST",
                  headers: {"Content-Type": "application/json"},
                  body: JSON.stringify({game_id: game.game_id, card_id: c.card_id})
                });
                const adv = await jsonFetch("/bingo/advance-stage", {
                  method:"POST",
                  headers: {"Content-Type": "application/json"},
                  body: JSON.stringify({game_id: game.game_id})
                });
                setBingoStatus(adv.ended ? "Claim approved. Game ended." : "Claim approved. Stage advanced.", "ok");
                await refreshBingo();
              }catch(err){
                setBingoStatus(err.message, "err");
              }
            };
            const deny = document.createElement("button");
            deny.textContent = "Deny";
            deny.className = "btn-ghost";
            deny.style.maxWidth = "90px";
            deny.onclick = async () => {
              try{
                await jsonFetch("/bingo/claim-deny", {
                  method:"POST",
                  headers: {"Content-Type": "application/json"},
                  body: JSON.stringify({game_id: game.game_id, card_id: c.card_id})
                });
                setBingoStatus("Claim denied.", "ok");
                await refreshBingo();
              }catch(err){
                setBingoStatus(err.message, "err");
              }
            };
            btnWrap.appendChild(btn);
            btnWrap.appendChild(deny);
            wrap.appendChild(btnWrap);
          }
          row.appendChild(wrap);
          el.appendChild(row);
        });
      }

      function formatGil(value){
        const raw = Number(value);
        if (!Number.isFinite(raw)) return String(value ?? "");
        return raw.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
      }

      function renderCard(card, called, header){
        currentCard = card;
        const headerEl = $("bCardHeader");
        const gridEl = $("bCardGrid");
        headerEl.innerHTML = "";
        gridEl.innerHTML = "";
        const letters = (header || "BING").slice(0,4).split("");
        while (letters.length < 4) letters.push(" ");
        letters.forEach(l => {
          const h = document.createElement("div");
          h.textContent = l;
          headerEl.appendChild(h);
        });
        if (!card || !Array.isArray(card.numbers)){
          gridEl.innerHTML = "<div style='grid-column:1/-1;color:var(--muted)'>No card loaded.</div>";
          return;
        }
        const calledSet = new Set(Array.isArray(called) ? called : []);
        const nums = card.numbers || [];
        const marks = card.marks || [];
        for (let r = 0; r < nums.length; r++){
          for (let c = 0; c < nums[r].length; c++){
            const cell = document.createElement("div");
            cell.className = "bingo-cell";
            const value = nums[r][c];
            const marked = (marks[r] && marks[r][c]) || calledSet.has(value);
            if (marked) cell.classList.add("marked");
            cell.textContent = value;
            gridEl.appendChild(cell);
          }
        }
      }

      function renderCalledGrid(called){
        const grid = $("bCalledGrid");
        grid.innerHTML = "";
        const calledSet = new Set(Array.isArray(called) ? called : []);
        if (!calledSet.size){
          const empty = document.createElement("div");
          empty.className = "bingo-called-empty";
          empty.textContent = "No numbers have been called.";
          grid.appendChild(empty);
          return;
        }
        const last = called && called.length ? called[called.length - 1] : null;
        for (let i = 1; i <= 40; i++){
          const btn = document.createElement("button");
          btn.className = "bingo-call-btn" + (calledSet.has(i) ? " active" : "");
          if (calledSet.has(i) && last === i){
            btn.classList.add("recent");
          }
          btn.textContent = i;
          btn.disabled = !calledSet.has(i);
          btn.onclick = () => markNumber(i);
          grid.appendChild(btn);
        }
      }

      function showCallout(text){
        let el = document.getElementById("bCallout");
        if (!el){
          el = document.createElement("div");
          el.id = "bCallout";
          el.className = "bingo-callout";
          document.body.appendChild(el);
        }
        el.textContent = text;
        el.classList.add("show");
        setTimeout(() => el.classList.remove("show"), 2200);
      }

      async function markNumber(num){
        const gid = getGameId();
        if (!gid || !currentCard || !Array.isArray(currentCard.numbers)){
          setBingoStatus("Load a card first.", "err");
          return;
        }
        const marks = [];
        for (let r = 0; r < currentCard.numbers.length; r++){
          for (let c = 0; c < currentCard.numbers[r].length; c++){
            if (currentCard.numbers[r][c] === num){
              marks.push({row: r, col: c});
            }
          }
        }
        if (marks.length === 0){
          setBingoStatus("Number not on this card.", "err");
          return;
        }
        try{
          for (const m of marks){
            await jsonFetch("/bingo/mark", {
              method:"POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({game_id: gid, card_id: currentCard.card_id, row: m.row, col: m.col})
            });
            if (currentCard.marks && currentCard.marks[m.row]){
              currentCard.marks[m.row][m.col] = true;
            }
          }
          renderCard(currentCard, currentGame && currentGame.called, currentGame && currentGame.header);
          setBingoStatus("Marked card.", "ok");
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      }

      function renderGamesList(games){
        const el = $("bGames");
        if (!el){
          return;
        }
        if (!Array.isArray(games) || games.length === 0){
          el.textContent = "No active games. Create one in Discord.";
          return;
        }
        el.innerHTML = "";
        games.forEach(g => {
          const item = document.createElement("div");
          item.style.padding = "8px 6px";
          item.style.borderBottom = "1px solid rgba(255,255,255,0.06)";
          const title = g.title || "Bingo";
          const created = g.created_at ? new Date(g.created_at * 1000).toLocaleString() : "Unknown date";
          const status = g.active ? "active" : "ended";
          const deleteBtn = !g.active ? `<button data-delete="${g.game_id}" class="btn-ghost" style="max-width:90px">Delete</button>` : "";
          item.innerHTML = `\n            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">\n              <div><strong>${title}</strong> - ${created} <span class="muted">(${status})</span></div>\n              ${deleteBtn}\n            </div>`;
          item.style.cursor = "pointer";
          item.onclick = () => {
            setGameId(g.game_id || "");
            refreshBingo();
            loadOwnersForGame();
            loadGamesMenu();
          };
          const del = item.querySelector("button[data-delete]");
          if (del){
            del.addEventListener("click", async (ev) => {
              ev.stopPropagation();
              if (!confirm("Delete this game? This cannot be undone.")){
                return;
              }
              try{
                await jsonFetch("/bingo/" + encodeURIComponent(g.game_id), {method:"DELETE"});
                setStatus("Game deleted.", "ok");
                await loadGamesMenu();
              }catch(err){
                setStatus(err.message, "err");
              }
            });
          }
          el.appendChild(item);
        });
      }

      function loadGamesMenu(){
        jsonFetch("/bingo/games", {method:"GET"})
          .then(data => {
            const list = (data.games || []).filter(g => g.active !== false);
            renderGamesList(data.games || []);
            const menu = $("menuGames");
            const menuParent = $("menuBingo");
            menu.innerHTML = "";
            let hasActive = false;
            list.forEach(g => {
              const row = document.createElement("div");
              row.className = "menu-game";
              row.tabIndex = 0;
              const created = g.created_at ? new Date(g.created_at * 1000).toLocaleString() : "Unknown date";
              row.innerHTML = `
                <span class="menu-game-title">${g.title ? g.title : "Untitled"}</span>
                <span class="menu-game-meta">${created}</span>
              `;
              row.onclick = () => {
                setGameId(g.game_id || "");
                showPanel("bingo");
                refreshBingo();
                loadOwnersForGame();
              // Selected game is indicated by menu highlight.
              };
              row.addEventListener("keydown", (ev) => {
                if (ev.key === "Enter" || ev.key === " "){
                  ev.preventDefault();
                  row.click();
                }
              });
              menu.appendChild(row);
              if (g.game_id && g.game_id === getGameId()){
                row.classList.add("active");
                hasActive = true;
              }
            });
            if (!list.length){
              menu.textContent = "No active games.";
            }
            if (menuParent){
              menuParent.classList.toggle("has-active", hasActive);
            }
            // Selected game is indicated by menu highlight.
          })
          .catch(() => {});
      }

      async function loadDiscordChannels(){
        const select = $("bChannelSelect");
        if (!select){
          return;
        }
        select.innerHTML = `<option value="">Loading...</option>`;
        try{
          const data = await jsonFetch("/discord/channels", {method:"GET"}, true);
          const channels = data.channels || [];
          select.innerHTML = "";
          if (!channels.length){
            select.innerHTML = `<option value="">No channels available</option>`;
            return;
          }
          let botlogsId = "";
          channels.forEach(ch => {
            const opt = document.createElement("option");
            opt.value = String(ch.id || "");
            const guild = ch.guild_name || ch.guild_id || "Guild";
            const category = ch.category ? ` / ${ch.category}` : "";
            const name = ch.name ? `#${ch.name}` : String(ch.id || "");
            opt.textContent = `${guild}${category} - ${name}`;
            select.appendChild(opt);
            if (!botlogsId && String(ch.name || "").toLowerCase() === "bot-logs"){
              botlogsId = opt.value;
            }
          });
          const current = $("bChannel").value.trim();
          if (current){
            select.value = current;
          }
          if (!select.value && select.options.length){
            select.value = botlogsId || select.options[0].value;
          }
          if (select.value){
            $("bChannel").value = select.value;
          }
          updateBingoCreatePayload();
        }catch(err){
          select.innerHTML = `<option value="">Failed to load</option>`;
          setStatus(err.message, "err");
        }
      }

      function showPanel(which){
        if (!suppressPanelSave){
          try{
            localStorage.setItem("overlay_panel", which);
          }catch(err){}
        }
        $("menuDashboard").classList.toggle("active", which === "dashboard");
        $("menuBingo").classList.toggle("active", which === "bingo");
        $("menuTarotLinks").classList.toggle("active", which === "tarotLinks");
        $("menuTarotDecks").classList.toggle("active", which === "tarotDecks");
        $("menuContests").classList.toggle("active", which === "contests");
        $("menuMedia").classList.toggle("active", which === "media");
        $("dashboardPanel").classList.toggle("hidden", which !== "dashboard");
        $("bingoPanel").classList.toggle("hidden", which !== "bingo");
        $("tarotLinksPanel").classList.toggle("hidden", which !== "tarotLinks");
        $("tarotDecksPanel").classList.toggle("hidden", which !== "tarotDecks");
        $("contestPanel").classList.toggle("hidden", which !== "contests");
        $("mediaPanel").classList.toggle("hidden", which !== "media");
        if (which === "media"){
          loadMediaLibrary();
          loadTarotArtists();
          updateMediaUploadDropDisplay(mediaUploadFile);
          updateMediaUploadState();
        }
      }

      function getSavedPanel(){
        try{
          return localStorage.getItem("overlay_panel") || "";
        }catch(err){
          return "";
        }
      }

      function getSeenDashboard(){
        try{
          return localStorage.getItem("overlay_seen_dashboard") === "1";
        }catch(err){
          return false;
        }
      }

      function setSeenDashboard(){
        try{
          localStorage.setItem("overlay_seen_dashboard", "1");
        }catch(err){}
      }

      let suppressPanelSave = false;

      function showPanelOnce(which){
        suppressPanelSave = true;
        showPanel(which);
        suppressPanelSave = false;
      }

      $("menuDashboard").addEventListener("click", () => showPanel("dashboard"));
      $("menuBingo").addEventListener("click", () => showPanel("bingo"));
      $("menuBingoRefresh").addEventListener("click", (ev) => {
        ev.stopPropagation();
        loadGamesMenu();
      });
      $("bChannelRefresh").addEventListener("click", () => loadDiscordChannels());
      $("bChannelSelect").addEventListener("change", (ev) => {
        const pick = ev.target.value || "";
        if (pick){
          $("bChannel").value = pick;
        }
        updateBingoCreatePayload();
      });
      $("menuCreateGame").addEventListener("click", (ev) => {
        ev.stopPropagation();
        $("bCreateModal").classList.add("show");
        $("bTitle").focus();
        $("bChannel").value = "";
        $("bChannelSelect").value = "";
        $("bAnnounceCalls").checked = false;
        bingoCreateBgUrl = "";
        $("bCreateBgStatus").textContent = "No background selected.";
        loadDiscordChannels();
        updateBingoCreatePayload();
      });
      $("menuTarotLinks").addEventListener("click", () => showPanel("tarotLinks"));
      $("menuTarotDecks").addEventListener("click", () => showPanel("tarotDecks"));
      $("menuContests").addEventListener("click", () => {
        showPanel("contests");
        loadContestManagement();
        loadContestChannels();
        loadTarotClaimsDecks();
        loadTarotClaimsChannels();
      });
      function bindMenuKey(id){
        const el = $(id);
        if (!el) return;
        el.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter" || ev.key === " "){
            ev.preventDefault();
            el.click();
          }
        });
      }
      bindMenuKey("menuDashboard");
      bindMenuKey("menuBingo");
      bindMenuKey("menuTarotLinks");
      bindMenuKey("menuTarotDecks");
      bindMenuKey("menuContests");
      bindMenuKey("menuMedia");
      $("bAnnounceToggle").addEventListener("change", async (ev) => {
        const gid = getGameId();
        if (!gid){
          setBingoStatus("Select a game first.", "err");
          ev.target.checked = false;
          return;
        }
        try{
          await jsonFetch("/bingo/" + encodeURIComponent(gid), {
            method:"PATCH",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({announce_calls: ev.target.checked})
          });
          const badge = $("bAnnounceBadge");
          if (badge){
            badge.textContent = ev.target.checked ? "On" : "Off";
            badge.className = "status-badge" + (ev.target.checked ? " good" : "");
          }
          setBingoStatus("Announce calls updated.", "ok");
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      });
      $("menuMedia").addEventListener("click", () => {
        showPanel("media");
      });
      $("menuArtists").addEventListener("click", () => {
        $("artistModal").classList.add("show");
        loadTarotArtists();
      });
      $("menuCalendar").addEventListener("click", () => {
        $("calendarModal").classList.add("show");
        loadCalendarAdmin();
      });
      $("menuGallery").addEventListener("click", () => {
        $("galleryModal").classList.add("show");
        loadGalleryChannels();
        loadGallerySettings();
        loadGalleryItems();
        loadTarotArtists();
      });
      $("menuAuthRoles").addEventListener("click", () => {
        if (!authUserIsElfmin){
          setStatus("Only elfministrators can manage auth roles.", "err");
          return;
        }
        $("authRolesModal").classList.add("show");
        loadAuthRoles();
      });
      $("menuAuthKeys").addEventListener("click", () => {
        if (!authUserIsElfmin){
          setStatus("Only elfministrators can manage auth keys.", "err");
          return;
        }
        $("authTokensModal").classList.add("show");
        loadAuthTokens();
      });
      $("contestRefresh").addEventListener("click", () => loadContestManagement());
      $("contestChannelRefresh").addEventListener("click", () => loadContestChannels());
      $("contestCreate").addEventListener("click", () => createContest());
      $("contestEmojiSelect").addEventListener("change", () => updateContestChannelPreview());
      $("contestChannelName").addEventListener("input", () => updateContestChannelPreview());
      $("contestCreateChannelOpen").addEventListener("click", () => {
        $("contestChannelModal").classList.add("show");
        loadContestChannels();
      });
      $("contestChannelClose").addEventListener("click", () => {
        $("contestChannelModal").classList.remove("show");
      });
      $("contestChannelModal").addEventListener("click", (event) => {
        if (event.target === $("contestChannelModal")){
          $("contestChannelModal").classList.remove("show");
        }
      });
      $("contestPanel").addEventListener("click", (event) => {
        const btn = event.target.closest(".contest-init");
        if (!btn) return;
        const channelId = btn.dataset.channel || "";
        if (channelId){
          $("contestChannel").value = channelId;
          setContestCreateStatus("Channel selected. Fill out details and create.", "ok");
        }
      });
      $("tarotClaimsRefresh").addEventListener("click", () => {
        loadTarotClaimsDecks();
        loadTarotClaimsChannels();
      });
      $("tarotClaimsPost").addEventListener("click", () => postTarotClaims());
      $("contestChannelCreate").addEventListener("click", async () => {
        try{
          const channelId = await createContestChannel();
          if (channelId){
            $("contestChannel").value = channelId;
          }
          $("contestChannelModal").classList.remove("show");
          await loadContestManagement();
        }catch(err){
          // status already handled
        }
      });

      let bingoRefreshTimer = null;
      function ensureBingoPolling(){
        if (bingoRefreshTimer){
          return;
        }
        bingoRefreshTimer = setInterval(() => {
          const gid = getGameId();
          if (!gid){
            return;
          }
          if ($("bingoPanel").classList.contains("hidden")){
            return;
          }
          refreshBingo();
        }, 3000);
      }

      function contestStatus(meta){
        if (!meta){
          return "unknown";
        }
        const raw = (meta.status || meta.state || meta.phase || "").toString().toLowerCase();
        if (["ended","closed","finished","complete","archived"].includes(raw)){
          return "ended";
        }
        if (["active","open","running","live","ongoing"].includes(raw)){
          return "active";
        }
        if (meta.ended === true || meta.closed === true || meta.finished === true){
          return "ended";
        }
        if (meta.active === false || meta.is_active === false || meta.open === false){
          return "ended";
        }
        return "active";
      }

      function setContestChannelStatus(msg, kind){
        const el = $("contestChannelStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function sanitizeChannelLabel(value){
        return String(value || "")
          .trim()
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^a-z0-9\-]/g, "");
      }

      function updateContestChannelPreview(){
        const emoji = ($("contestEmojiSelect") && $("contestEmojiSelect").value) || "*";
        const name = sanitizeChannelLabel($("contestChannelName").value || "elfoween") || "elfoween";
        const preview = `${emoji} | ${name}`;
        const el = $("contestChannelPreview");
        if (el){
          el.textContent = preview;
        }
        return preview;
      }

      function setContestCreateStatus(msg, kind){
        const el = $("contestCreateStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function setTarotClaimsStatus(msg, kind){
        const el = $("tarotClaimsStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      async function loadTarotClaimsDecks(){
        const select = $("tarotClaimsDeck");
        if (!select) return;
        select.innerHTML = `<option value="">Loading...</option>`;
        try{
          const data = await jsonFetch("/api/tarot/decks", {method:"GET"}, true);
          const decks = data.decks || [];
          select.innerHTML = "";
          decks.forEach(d => {
            const opt = document.createElement("option");
            opt.value = d.deck_id;
            opt.textContent = d.name ? `${d.name} (${d.deck_id})` : d.deck_id;
            select.appendChild(opt);
          });
          if (!decks.length){
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "No decks found.";
            select.appendChild(opt);
          }
        }catch(err){
          select.innerHTML = `<option value="">Failed to load decks</option>`;
          setTarotClaimsStatus(err.message, "err");
        }
      }

      async function loadTarotClaimsChannels(){
        const select = $("tarotClaimsChannel");
        if (!select) return;
        select.innerHTML = `<option value="">Loading...</option>`;
        try{
          const data = await jsonFetch("/discord/channels", {method:"GET"}, true);
          const channels = data.channels || [];
          select.innerHTML = "";
          channels.forEach(c => {
            const opt = document.createElement("option");
            opt.value = c.id;
            const parts = [];
            if (c.guild_name) parts.push(c.guild_name);
            if (c.category) parts.push(c.category);
            const label = parts.length ? `${parts.join(" / ")} / #${c.name}` : `#${c.name}`;
            opt.textContent = label;
            select.appendChild(opt);
          });
          if (!channels.length){
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "No channels found.";
            select.appendChild(opt);
          }
        }catch(err){
          select.innerHTML = `<option value="">Failed to load channels</option>`;
          setTarotClaimsStatus(err.message, "err");
        }
      }

      async function postTarotClaims(){
        const deckId = $("tarotClaimsDeck").value || "";
        const channelId = $("tarotClaimsChannel").value || "";
        const claimLimit = Number($("tarotClaimsLimit").value || 2);
        if (!deckId){
          setTarotClaimsStatus("Pick a deck first.", "err");
          return;
        }
        if (!channelId){
          setTarotClaimsStatus("Pick a channel first.", "err");
          return;
        }
        setTarotClaimsStatus("Posting TarotCards board...", "");
        try{
          await jsonFetch("/api/tarot/decks/" + encodeURIComponent(deckId) + "/claims/post", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({channel_id: channelId, claim_limit: claimLimit})
          }, true);
          setTarotClaimsStatus("TarotCards board posted.", "ok");
        }catch(err){
          setTarotClaimsStatus(err.message, "err");
        }
      }

      async function loadContestChannels(){
        const select = $("contestChannel");
        const templateSelect = $("contestTemplateChannel");
        if (!select) return;
        select.innerHTML = `<option value="">Loading...</option>`;
        if (templateSelect){
          templateSelect.innerHTML = `<option value="">Loading...</option>`;
        }
        try{
          const data = await jsonFetch("/discord/channels", {method:"GET"}, true);
          const channels = data.channels || [];
          select.innerHTML = "";
          if (templateSelect){
            templateSelect.innerHTML = "";
            const none = document.createElement("option");
            none.value = "";
            none.textContent = "(no template)";
            templateSelect.appendChild(none);
          }
          channels.forEach(c => {
            const opt = document.createElement("option");
            opt.value = c.id;
            const parts = [];
            if (c.guild_name) parts.push(c.guild_name);
            if (c.category) parts.push(c.category);
            const label = parts.length ? `${parts.join(" / ")} / #${c.name}` : `#${c.name}`;
            opt.textContent = label;
            select.appendChild(opt);
            if (templateSelect){
              const clone = document.createElement("option");
              clone.value = c.id;
              clone.textContent = label;
              templateSelect.appendChild(clone);
            }
          });
          if (!channels.length){
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "No channels found.";
            select.appendChild(opt);
            if (templateSelect){
              const opt2 = document.createElement("option");
              opt2.value = "";
              opt2.textContent = "No channels found.";
              templateSelect.appendChild(opt2);
            }
          }
        }catch(err){
          select.innerHTML = `<option value="">Failed to load channels</option>`;
          if (templateSelect){
            templateSelect.innerHTML = `<option value="">Failed to load channels</option>`;
          }
          setContestCreateStatus(err.message, "err");
        }
      }

      async function createContestChannel(){
        const name = updateContestChannelPreview();
        const templateId = $("contestTemplateChannel").value || "";
        setContestChannelStatus("Creating channel...", "");
        try{
          const data = await jsonFetch("/api/contests/channel", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
              name,
              category_id: CONTEST_CATEGORY_ID,
              template_channel_id: templateId || undefined
            })
          }, true);
          setContestChannelStatus(`Channel created: ${data.name}`, "ok");
          await loadContestChannels();
          $("contestChannel").value = String(data.channel_id || "");
          return String(data.channel_id || "");
        }catch(err){
          setContestChannelStatus(err.message, "err");
          throw err;
        }
      }

      let galleryItemsCache = [];
      let galleryEditItem = null;
      let ownerFilter = "all";
      let ownerFilterData = {owner: "", cards: [], called: [], header: ""};

      async function loadGallerySettings(){
        try{
          const data = await jsonFetch("/api/gallery/settings", {method:"GET"}, true);
          const channelId = data.upload_channel_id ? String(data.upload_channel_id) : "";
          const select = $("galleryUploadChannel");
          if (select && channelId){
            select.value = channelId;
          }
          setGalleryChannelStatus(channelId ? "Upload channel set." : "Pick a channel to use for uploads.", channelId ? "ok" : "");
        }catch(err){
          setGalleryChannelStatus(err.message, "err");
        }
      }

      async function loadGalleryChannels(){
        const select = $("galleryUploadChannel");
        const templateSelect = $("galleryChannelTemplate");
        const importSelect = $("galleryImportChannel");
        if (!select) return;
        select.innerHTML = `<option value="">Loading...</option>`;
        if (templateSelect){
          templateSelect.innerHTML = `<option value="">Loading...</option>`;
        }
        if (importSelect){
          importSelect.innerHTML = `<option value="">Loading...</option>`;
        }
        try{
          const data = await jsonFetch("/discord/channels", {method:"GET"}, true);
          const channels = data.channels || [];
          select.innerHTML = "";
          if (templateSelect){
            templateSelect.innerHTML = "";
            const none = document.createElement("option");
            none.value = "";
            none.textContent = "(no template)";
            templateSelect.appendChild(none);
          }
          if (importSelect){
            importSelect.innerHTML = "";
            const none = document.createElement("option");
            none.value = "";
            none.textContent = "(select channel)";
            importSelect.appendChild(none);
          }
          channels.forEach(c => {
            const opt = document.createElement("option");
            opt.value = c.id;
            const parts = [];
            if (c.guild_name) parts.push(c.guild_name);
            if (c.category) parts.push(c.category);
            const label = parts.length ? `${parts.join(" / ")} / #${c.name}` : `#${c.name}`;
            opt.textContent = label;
            select.appendChild(opt);
            if (templateSelect){
              const clone = document.createElement("option");
              clone.value = c.id;
              clone.textContent = label;
              templateSelect.appendChild(clone);
            }
            if (importSelect){
              const clone = document.createElement("option");
              clone.value = c.id;
              clone.textContent = label;
              importSelect.appendChild(clone);
            }
          });
          if (!channels.length){
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "No channels found.";
            select.appendChild(opt);
            if (templateSelect){
              const opt2 = document.createElement("option");
              opt2.value = "";
              opt2.textContent = "No channels found.";
              templateSelect.appendChild(opt2);
            }
            if (importSelect){
              const opt3 = document.createElement("option");
              opt3.value = "";
              opt3.textContent = "No channels found.";
              importSelect.appendChild(opt3);
            }
          }
        }catch(err){
          select.innerHTML = `<option value="">Failed to load channels</option>`;
          if (templateSelect){
            templateSelect.innerHTML = `<option value="">Failed to load channels</option>`;
          }
          if (importSelect){
            importSelect.innerHTML = `<option value="">Failed to load channels</option>`;
          }
          setGalleryChannelStatus(err.message, "err");
        }
      }

      function setGalleryChannelStatus(msg, kind){
        const el = $("galleryChannelStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function setGalleryItemsStatus(msg, kind){
        const el = $("galleryItemsStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function setGalleryImportStatus(msg, kind){
        const el = $("galleryImportStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function renderGalleryItems(items){
        const list = $("galleryItemsList");
        if (!list) return;
        galleryItemsCache = items || [];
        if (!galleryItemsCache.length){
          list.textContent = "No items found.";
          return;
        }
        list.innerHTML = "";
        galleryItemsCache.forEach(item => {
          const row = document.createElement("div");
          row.className = "gallery-admin-row";
          const thumb = document.createElement(item.url ? "img" : "div");
          thumb.className = "gallery-thumb";
          if (item.url){
            thumb.src = item.url;
            thumb.alt = item.title || "Gallery item";
            if (item.fallback_url){
              thumb.dataset.fallback = item.fallback_url;
              thumb.addEventListener("error", () => {
                if (thumb.dataset.fallback && thumb.src !== thumb.dataset.fallback){
                  thumb.src = thumb.dataset.fallback;
                }
              });
            }
          }
          const meta = document.createElement("div");
          meta.className = "gallery-meta";
          const title = document.createElement("div");
          title.className = "gallery-title";
          title.textContent = item.title || item.url || "Untitled";
          const sub = document.createElement("div");
          sub.className = "gallery-sub";
          const artistName = (item.artist && item.artist.name) ? item.artist.name : "Forest";
          const source = item.source || item.type || "gallery";
          sub.textContent = `${artistName} - ${source}`;
          meta.appendChild(title);
          meta.appendChild(sub);
          const actions = document.createElement("div");
          actions.className = "gallery-actions";
          const toggle = document.createElement("button");
          toggle.className = "btn-ghost";
          toggle.textContent = item.hidden ? "Show" : "Hide";
          toggle.addEventListener("click", async () => {
            try{
              await jsonFetch("/api/gallery/hidden", {
                method:"POST",
                headers: {"Content-Type":"application/json"},
                body: JSON.stringify({item_id: item.item_id, hidden: !item.hidden})
              }, true);
              await loadGalleryItems();
            }catch(err){
              setGalleryItemsStatus(err.message, "err");
            }
          });
          const canEdit = String(item.item_id || "").startsWith("media:");
          const edit = document.createElement("button");
          edit.className = "btn-ghost";
          edit.textContent = "Edit";
          edit.disabled = !canEdit;
          edit.addEventListener("click", () => openGalleryEdit(item));
          actions.appendChild(toggle);
          actions.appendChild(edit);
          row.appendChild(thumb);
          row.appendChild(meta);
          row.appendChild(actions);
          list.appendChild(row);
        });
      }

      async function loadGalleryItems(){
        setGalleryItemsStatus("Loading items...", "");
        try{
          const data = await jsonFetch("/api/gallery/admin/items", {method:"GET"}, true);
          renderGalleryItems(data.items || []);
          setGalleryItemsStatus("Ready.", "ok");
        }catch(err){
          setGalleryItemsStatus(err.message, "err");
        }
      }

      function openGalleryEdit(item){
        galleryEditItem = item;
        $("galleryEditTitle").value = item.title || "";
        const artist = item.artist || {};
        $("galleryEditArtist").value = artist.artist_id || "";
        $("galleryEditArtistName").value = artist.name || "";
        $("galleryEditStatus").textContent = "Ready.";
        $("galleryEditModal").classList.add("show");
      }

      async function createContest(){
        let channelId = $("contestChannel").value;
        if (!channelId){
          setContestCreateStatus("Pick a channel first.", "err");
          return;
        }
        const body = {
          channel_id: channelId,
          title: $("contestTitle").value.trim(),
          description: $("contestDescription").value.trim(),
          rules: $("contestRules").value.trim(),
          deadline: $("contestDeadline").value.trim(),
          vote_emoji: $("contestEmoji").value.trim()
        };
        setContestCreateStatus("Creating contest...", "");
        try{
          const res = await jsonFetch("/api/contests/create", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(body)
          }, true);
          setContestCreateStatus(`Contest created in channel ${res.channel_id}.`, "ok");
          await loadContestManagement();
        }catch(err){
          setContestCreateStatus(err.message, "err");
        }
      }

      async function loadContestManagement(){
        const allEl = $("contestAllList");
        const endedEl = $("contestEndedList");
        allEl.textContent = "Loading contests...";
        endedEl.textContent = "Loading contests...";
        try{
          const list = await jsonFetch("/contests", {method:"GET"}, true);
          const channels = list.channels || [];
          if (!channels.length){
            allEl.textContent = "No contests yet.";
            endedEl.textContent = "No ended contests yet.";
            return;
          }
          const details = await Promise.all(channels.map(async (id) => {
            try{
              return await jsonFetch("/contests/" + encodeURIComponent(id), {method:"GET"}, true);
            }catch(err){
              return {channel_id: id, error: err.message, exists: false};
            }
          }));
          const allCards = [];
          const endedCards = [];
          details.forEach(info => {
            const channelId = info.channel_id || info.channel || "";
            const meta = info.meta || null;
            const counts = info.counts || {};
            const status = contestStatus(meta);
            const name = meta ? (meta.name || meta.title || meta.contest_name || meta.label || "") : "";
            const channelName = meta ? (meta.channel_name || meta.channel || meta.channel_title || "") : "";
            const label = name || channelName ? (name || channelName) : `Contest ${channelId}`;
            const entries = counts.entries !== undefined ? `${counts.entries} entries` : "entries unknown";
            const statusLabel = status === "ended" ? "Ended" : status === "active" ? "Active" : "Unknown";
            const error = info.exists === false ? (info.error || "contest db missing") : info.error;
            const deadline = meta ? (meta.deadline || meta.ends_at || meta.end || "") : "";
            const deadlineLine = deadline ? `<div class=\"muted\">Deadline: ${deadline}</div>` : "";
            let errorLine = "";
            if (error){
              const hint = error.includes("contest db") ? "Contest database missing. Initialize to create metadata." : error;
              const action = channelId ? `<button class=\"btn-ghost contest-init\" data-channel=\"${channelId}\">Initialize</button>` : "";
              const actionLine = action ? `<div class=\"contest-actions\">${action}</div>` : "";
              errorLine = `<div class=\"status alert\">${hint}</div>${actionLine}`;
            }
            const card = `<div class=\"list-card\"><strong>${label}</strong><div class=\"muted\">${statusLabel} - ${entries}</div>${deadlineLine}${errorLine}</div>`;
            if (status === "ended"){
              endedCards.push(card);
            } else {
              allCards.push(card);
            }
          });
          allEl.innerHTML = allCards.length ? allCards.join("") : "No active contests.";
          endedEl.innerHTML = endedCards.length ? endedCards.join("") : "No ended contests yet.";
        }catch(err){
          allEl.textContent = "Failed to load contests.";
          endedEl.textContent = "Failed to load contests.";
          setStatus(err.message, "err");
        }
      }

      function updateBingoCreatePayload(){
        const el = $("bCreatePayload");
        if (!el){
          return;
        }
        const channelId = $("bChannelSelect").value || $("bChannel").value || "?";
        const createdBy = $("bCreatedBy").value || "?";
        const channelLabel = $("bChannelSelect").selectedOptions.length
          ? $("bChannelSelect").selectedOptions[0].textContent
          : "";
        const label = channelLabel ? ` (${channelLabel})` : "";
        el.textContent = `Payload preview: channel_id=${channelId}${label}, created_by=${createdBy}`;
      }

      function renderOwnersList(owners){
        const el = $("bOwners");
        const empty = $("bOwnersEmpty");
        if (!Array.isArray(owners) || owners.length === 0){
          el.textContent = "";
          if (empty) empty.style.display = "flex";
          return;
        }
        if (empty) empty.style.display = "none";
        el.innerHTML = "";
        owners.forEach(o => {
          const item = document.createElement("div");
          item.className = "owner-row";
          item.style.cursor = "pointer";
          const token = o.token || "";
          const link = token ? `${getBase()}/bingo/owner?token=${encodeURIComponent(token)}` : "";
          const linkHtml = link ? `<a href="${link}" class="owner-link" target="_blank" rel="noreferrer">Open</a>` : "";
          const copyBtn = link ? `<button data-copy="${link}" class="owner-copy-icon" title="Copy link" aria-label="Copy link"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M16 1H6a2 2 0 0 0-2 2v12h2V3h10V1zm3 4H10a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2zm0 16H10V7h9v14z"/></svg></button>` : "";
          item.innerHTML = `\n            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">\n              <div><strong>${o.owner_name}</strong></div>\n              <div class="owner-meta">\n                <span class="pill owner-cards">${o.cards} cards</span>\n                ${linkHtml}\n                ${copyBtn}\n              </div>\n            </div>`;
          item.onclick = () => {
            $("bOwner").value = o.owner_name || "";
            loadOwnerCards(o.owner_name || "");
            $("bOwnerModal").classList.add("show");
          };
          const linkEl = item.querySelector("a");
          if (linkEl){
            linkEl.addEventListener("click", (ev) => ev.stopPropagation());
          }
          const copy = item.querySelector("button[data-copy]");
          if (copy){
            copy.addEventListener("click", (ev) => {
              ev.stopPropagation();
              try{
                navigator.clipboard.writeText(copy.getAttribute("data-copy") || "");
                setStatus("Link copied.", "ok");
              }catch(err){
                setStatus("Copy failed.", "err");
              }
            });
          }
          el.appendChild(item);
        });
      }

      async function loadOwnersForGame(){
        const gid = getGameId();
        $("bOwnerCards").textContent = "No tickets loaded.";
        if (!gid){
          $("bOwners").textContent = "";
          const empty = $("bOwnersEmpty");
          if (empty) empty.style.display = "flex";
          return;
        }
        try{
          const data = await jsonFetch("/bingo/" + encodeURIComponent(gid) + "/owners", {method:"GET"});
          renderOwnersList(data.owners || []);
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      }

      function renderOwnerCards(owner, cards, called, header){
        const el = $("bOwnerCards");
        const summary = $("bOwnerSummary");
        ownerFilterData = {owner, cards, called, header};
        if (summary){
          const path = summary.querySelector(".context-path");
          const meta = summary.querySelector(".context-meta");
          if (path) path.textContent = `Viewing cards for: ${owner || "-"}`;
          if (meta) meta.textContent = `Total cards: ${Array.isArray(cards) ? cards.length : 0}`;
        }
        let totalCalledCells = 0;
        let totalCells = 0;
        if (!Array.isArray(cards) || cards.length === 0){
          el.textContent = "No tickets for this player.";
          return;
        }
        el.innerHTML = "";
        const calledSet = new Set(Array.isArray(called) ? called : []);
        const headerText = (header || "BING").slice(0, 4).split("");
        while (headerText.length < 4) headerText.push(" ");
        cards.forEach((card, index) => {
          const wrap = document.createElement("div");
          wrap.className = "owner-card";
          wrap.classList.add("collapsed");
          const headerRow = document.createElement("div");
          headerRow.className = "owner-card-header";
          const titleWrap = document.createElement("div");
          const title = document.createElement("div");
          title.className = "owner-card-title";
          title.textContent = `Card ${index + 1}`;
          const id = document.createElement("div");
          id.className = "owner-card-id";
          const cardId = String(card.card_id || "");
          const suffix = cardId.length > 4 ? cardId.slice(-4) : cardId;
          id.textContent = suffix ? `...${suffix}` : "-";
          if (cardId){
            id.title = cardId;
          }
          titleWrap.appendChild(title);
          titleWrap.appendChild(id);
          const summaryWrap = document.createElement("div");
          summaryWrap.className = "owner-card-summary";
          const countEl = document.createElement("div");
          countEl.className = "owner-card-count";
          let numbers = card.numbers;
          if (typeof numbers === "string"){
            try{
              numbers = JSON.parse(numbers);
            }catch(err){
              numbers = null;
            }
          }
          if (!Array.isArray(numbers)){
            numbers = Array.isArray(card.grid)
              ? card.grid
              : (Array.isArray(card.card) ? card.card : []);
          }
          let cardCalled = 0;
          let cardTotal = 0;
          numbers.forEach((row) => {
            (row || []).forEach((value) => {
              cardTotal += 1;
              if (calledSet.has(value)){
                cardCalled += 1;
              }
            });
          });
          totalCells += cardTotal;
          totalCalledCells += cardCalled;
          countEl.textContent = `${cardCalled} / ${cardTotal || 0} called`;
          const progress = document.createElement("div");
          progress.className = "owner-card-progress";
          const fill = document.createElement("div");
          fill.className = "owner-card-progress-fill";
          const ratio = cardTotal ? (cardCalled / cardTotal) : 0;
          fill.style.width = `${Math.round(ratio * 100)}%`;
          progress.appendChild(fill);
          summaryWrap.appendChild(countEl);
          summaryWrap.appendChild(progress);
          if (cardTotal && cardCalled === cardTotal){
            const flag = document.createElement("span");
            flag.className = "owner-card-flag complete";
            flag.textContent = "Complete";
            summaryWrap.appendChild(flag);
          }else if (cardTotal && ratio >= 0.75){
            const flag = document.createElement("span");
            flag.className = "owner-card-flag near";
            flag.textContent = "Near-win";
            summaryWrap.appendChild(flag);
          }
          const toggle = document.createElement("button");
          toggle.type = "button";
          toggle.className = "owner-card-toggle";
          toggle.setAttribute("aria-label", "Collapse card");
          toggle.innerHTML = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M7 10l5 5 5-5z"/></svg>';
          headerRow.appendChild(titleWrap);
          headerRow.appendChild(summaryWrap);
          headerRow.appendChild(toggle);
          const body = document.createElement("div");
          body.className = "owner-card-body";
          const cardHeader = document.createElement("div");
          cardHeader.className = "bingo-header";
          headerText.forEach((h, idx) => {
            const label = document.createElement("div");
            label.textContent = h;
            if (idx > 0){
              label.style.borderLeft = "1px solid rgba(255,255,255,.08)";
            }
            cardHeader.appendChild(label);
          });
          body.appendChild(cardHeader);
          const grid = document.createElement("div");
          grid.className = "bingo-grid";
          if (!numbers.length){
            const empty = document.createElement("div");
            empty.className = "status";
            empty.textContent = "No numbers available for this card.";
            body.appendChild(empty);
          }
          numbers.forEach((row, r) => {
            (row || []).forEach((value, c) => {
              const cell = document.createElement("div");
              cell.className = "bingo-cell";
              const isCalled = calledSet.has(value);
              const marked = (card.marks && card.marks[r] && card.marks[r][c]) || isCalled;
              if (marked) cell.classList.add("marked");
              if (isCalled) cell.classList.add("called");
              if (ownerFilter === "called" && !isCalled){
                cell.classList.add("filtered-out");
              }
              if (ownerFilter === "uncalled" && isCalled){
                cell.classList.add("filtered-out");
              }
              if (c > 0){
                cell.style.borderLeft = "1px solid rgba(255,255,255,.08)";
              }
              cell.textContent = value;
              if (isCalled){
                const mark = document.createElement("span");
                mark.className = "cell-mark";
                mark.textContent = "x";
                cell.appendChild(mark);
              }
              cell.onclick = () => {
                renderCard(card, called, header);
              };
              grid.appendChild(cell);
            });
          });
          if (numbers.length){
            body.appendChild(grid);
          }
          headerRow.addEventListener("click", () => {
            const isCollapsed = wrap.classList.contains("collapsed");
            const cardsEls = el.querySelectorAll(".owner-card");
            cardsEls.forEach((cardEl) => {
              cardEl.classList.add("collapsed");
            });
            if (isCollapsed){
              wrap.classList.remove("collapsed");
            }
          });
          toggle.addEventListener("click", (ev) => {
            ev.stopPropagation();
            const isCollapsed = wrap.classList.contains("collapsed");
            const cardsEls = el.querySelectorAll(".owner-card");
            cardsEls.forEach((cardEl) => {
              cardEl.classList.add("collapsed");
            });
            if (isCollapsed){
              wrap.classList.remove("collapsed");
            }
          });
          wrap.appendChild(headerRow);
          wrap.appendChild(body);
          el.appendChild(wrap);
        });
        const calledBtn = $("bOwnerFilterCalled");
        const uncalledBtn = $("bOwnerFilterUncalled");
        if (calledBtn && uncalledBtn){
          calledBtn.textContent = `Called (${totalCalledCells})`;
          uncalledBtn.textContent = `Uncalled (${Math.max(0, totalCells - totalCalledCells)})`;
          calledBtn.classList.toggle("active", ownerFilter === "called");
          uncalledBtn.classList.toggle("active", ownerFilter === "uncalled");
        }
        el.dataset.filter = ownerFilter;
      }
      async function loadOwnerCards(ownerName){
        const gid = getGameId();
        if (!gid || !ownerName){
          setBingoStatus("Enter game id and owner name.", "err");
          return;
        }
        ownerFilter = "all";
        try{
          const state = await jsonFetch("/bingo/" + encodeURIComponent(gid), {method:"GET"}, false);
          const data = await jsonFetch("/bingo/" + encodeURIComponent(gid) + "/owner/" + encodeURIComponent(ownerName) + "/cards", {method:"GET"}, false);
          renderBingoState(state);
          renderOwnerCards(ownerName, data.cards || [], state.game && state.game.called, state.game && state.game.header);
          setBingoStatus("Tickets loaded.", "ok");
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      }

      // owner list loads automatically when selecting a game

      $("bCloseCreate").addEventListener("click", () => {
        $("bCreateModal").classList.remove("show");
      });
      $("deckCreateClose").addEventListener("click", () => {
        $("deckCreateModal").classList.remove("show");
      });
      $("mediaClose").addEventListener("click", () => {
        $("mediaModal").classList.remove("show");
      });
      $("artistClose").addEventListener("click", () => {
        $("artistModal").classList.remove("show");
      });
      $("calendarClose").addEventListener("click", () => {
        $("calendarModal").classList.remove("show");
      });
      $("galleryClose").addEventListener("click", () => {
        $("galleryModal").classList.remove("show");
      });
      $("galleryModal").addEventListener("click", (event) => {
        if (event.target === $("galleryModal")){
          $("galleryModal").classList.remove("show");
        }
      });
      $("galleryEditClose").addEventListener("click", () => {
        $("galleryEditModal").classList.remove("show");
      });
      $("galleryEditModal").addEventListener("click", (event) => {
        if (event.target === $("galleryEditModal")){
          $("galleryEditModal").classList.remove("show");
        }
      });
      $("galleryImportOpen").addEventListener("click", () => {
        $("galleryImportModal").classList.add("show");
        setGalleryImportStatus("Pick a channel to import.", "");
        loadGalleryChannels();
      });
      $("galleryImportClose").addEventListener("click", () => {
        $("galleryImportModal").classList.remove("show");
      });
      $("galleryImportModal").addEventListener("click", (event) => {
        if (event.target === $("galleryImportModal")){
          $("galleryImportModal").classList.remove("show");
        }
      });
      $("galleryImportRefresh").addEventListener("click", () => loadGalleryChannels());
      $("galleryImportRun").addEventListener("click", async () => {
        const channelId = $("galleryImportChannel").value || "";
        if (!channelId){
          setGalleryImportStatus("Pick a channel first.", "err");
          return;
        }
        setGalleryImportStatus("Importing...", "");
        try{
          const res = await jsonFetch("/api/gallery/import-channel", {
            method:"POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({channel_id: channelId})
          }, true);
          const imported = res.imported || 0;
          const skipped = res.skipped || 0;
          setGalleryImportStatus(`Imported ${imported}. Skipped ${skipped}.`, "ok");
          await loadGalleryItems();
        }catch(err){
          setGalleryImportStatus(err.message, "err");
        }
      });
      $("bOwnerFilterCalled").addEventListener("click", () => {
        ownerFilter = ownerFilter === "called" ? "all" : "called";
        renderOwnerCards(
          ownerFilterData.owner,
          ownerFilterData.cards,
          ownerFilterData.called,
          ownerFilterData.header
        );
      });
      $("bOwnerFilterUncalled").addEventListener("click", () => {
        ownerFilter = ownerFilter === "uncalled" ? "all" : "uncalled";
        renderOwnerCards(
          ownerFilterData.owner,
          ownerFilterData.cards,
          ownerFilterData.called,
          ownerFilterData.header
        );
      });
      $("galleryChannelRefresh").addEventListener("click", () => loadGalleryChannels());
      $("galleryItemsRefresh").addEventListener("click", () => loadGalleryItems());
      $("galleryChannelSave").addEventListener("click", async () => {
        const channelId = $("galleryUploadChannel").value || "";
        try{
          await jsonFetch("/api/gallery/settings", {
            method:"POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({upload_channel_id: channelId || null})
          }, true);
          setGalleryChannelStatus("Upload channel saved.", "ok");
        }catch(err){
          setGalleryChannelStatus(err.message, "err");
        }
      });
      $("galleryChannelCreate").addEventListener("click", async () => {
        const name = $("galleryChannelName").value.trim();
        const categoryId = $("galleryChannelCategory").value.trim();
        const templateId = $("galleryChannelTemplate").value || "";
        if (!name){
          setGalleryChannelStatus("Enter a channel name.", "err");
          return;
        }
        if (!categoryId){
          setGalleryChannelStatus("Enter a category ID.", "err");
          return;
        }
        setGalleryChannelStatus("Creating channel...", "");
        try{
          const data = await jsonFetch("/api/gallery/upload-channel", {
            method:"POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
              name,
              category_id: categoryId,
              template_channel_id: templateId || undefined
            })
          }, true);
          setGalleryChannelStatus(`Channel created: ${data.name}`, "ok");
          await loadGalleryChannels();
          $("galleryUploadChannel").value = String(data.channel_id || "");
        }catch(err){
          setGalleryChannelStatus(err.message, "err");
        }
      });
      $("galleryEditArtist").addEventListener("change", (ev) => {
        const pick = (window.taArtists || []).find(a => a.artist_id === ev.target.value);
        if (pick && $("galleryEditArtistName")){
          $("galleryEditArtistName").value = pick.name || "";
        }
      });
      $("galleryEditSave").addEventListener("click", async () => {
        if (!galleryEditItem){
          return;
        }
        try{
          await jsonFetch("/api/gallery/media/update", {
            method:"POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
              item_id: galleryEditItem.item_id,
              title: $("galleryEditTitle").value.trim(),
              artist_id: $("galleryEditArtist").value.trim() || undefined,
              artist_name: $("galleryEditArtistName").value.trim()
            })
          }, true);
          $("galleryEditModal").classList.remove("show");
          await loadGalleryItems();
          setGalleryItemsStatus("Item updated.", "ok");
        }catch(err){
          $("galleryEditStatus").textContent = err.message;
          $("galleryEditStatus").className = "status err";
        }
      });
      $("calendarRefresh").addEventListener("click", () => loadCalendarAdmin());
      $("calendarMonth").addEventListener("change", (ev) => {
        const month = parseInt(ev.target.value || "1", 10);
        const entry = calendarData.find(e => e.month === month) || calendarData[0];
        if (entry){
          applyCalendarSelection(entry);
        }
      });
      $("calendarPick").addEventListener("click", () => {
        librarySelectHandler = (item) => {
          calendarSelected.image = item.url || "";
          calendarSelected.title = item.title || item.name || "";
          calendarSelected.artist_id = item.artist_id || null;
          calendarSelected.artist_name = item.artist_name || "Forest";
          $("calendarTitle").value = calendarSelected.title;
          $("calendarArtist").textContent = calendarSelected.artist_name || "Forest";
          renderCalendarPreview();
        };
        showLibraryModal(true);
        loadLibrary("media");
      });
      $("calendarSave").addEventListener("click", async () => {
        const month = parseInt($("calendarMonth").value || "1", 10);
        const title = $("calendarTitle").value.trim();
        const payload = {
          month: month,
          image: calendarSelected.image || "",
          title: title,
          artist_id: calendarSelected.artist_id || ""
        };
        if (!payload.image){
          setCalendarStatus("Pick an image first.", "err");
          return;
        }
        try{
          await jsonFetch("/api/gallery/calendar", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(payload)
          });
          setCalendarStatus("Saved.", "ok");
          await loadCalendarAdmin();
        }catch(err){
          setCalendarStatus(err.message, "err");
        }
      });
      $("calendarClear").addEventListener("click", async () => {
        const month = parseInt($("calendarMonth").value || "1", 10);
        try{
          await jsonFetch("/api/gallery/calendar", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({month: month, image: ""})
          });
          calendarSelected.image = "";
          calendarSelected.title = "";
          calendarSelected.artist_id = null;
          calendarSelected.artist_name = "Forest";
          $("calendarTitle").value = "";
          $("calendarArtist").textContent = "Forest";
          renderCalendarPreview();
          setCalendarStatus("Cleared.", "ok");
          await loadCalendarAdmin();
        }catch(err){
          setCalendarStatus(err.message, "err");
        }
      });
      $("authRolesClose").addEventListener("click", () => {
        $("authRolesModal").classList.remove("show");
      });
      $("authRolesRefresh").addEventListener("click", () => loadAuthRoles());
      $("authTokensClose").addEventListener("click", () => {
        $("authTokensModal").classList.remove("show");
      });
      $("authTokensRefresh").addEventListener("click", () => loadAuthTokens());
      $("authRolesList").addEventListener("change", (ev) => {
        const input = ev.target;
        if (!input || input.tagName !== "INPUT") return;
        const roleId = input.getAttribute("data-role");
        const scope = input.getAttribute("data-scope");
        if (!roleId || !scope) return;
        const current = new Set((authRoleScopes[roleId] || []).map(String));
        if (input.checked){
          if (scope === "*"){
            current.clear();
            current.add("*");
          } else {
            current.delete("*");
            current.add(scope);
          }
        } else {
          current.delete(scope);
        }
        if (current.size){
          authRoleScopes[roleId] = Array.from(current);
        } else {
          delete authRoleScopes[roleId];
        }
        updateAuthRoleIdsField();
        renderAuthRolesList(authRolesCache || []);
      });
      $("authRolesSave").addEventListener("click", async () => {
        try{
          await jsonFetch("/api/auth/roles", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({role_scopes: authRoleScopes})
          });
          setAuthRolesStatus("Saved.", "ok");
        }catch(err){
          setAuthRolesStatus(err.message, "err");
        }
      });
      $("bOwnerClose").addEventListener("click", () => {
        $("bOwnerModal").classList.remove("show");
      });
      $("bPurchaseClose").addEventListener("click", () => {
        $("bPurchaseModal").classList.remove("show");
      });
      $("bPurchaseCopy").addEventListener("click", () => {
        const link = $("bPurchaseLink").value || "";
        if (!link){
          return;
        }
        try{
          navigator.clipboard.writeText(link);
          $("bPurchaseStatus").textContent = "Link copied.";
        }catch(err){
          $("bPurchaseStatus").textContent = "Copy failed.";
        }
      });

      $("loginBtn").addEventListener("click", () => {
        if (!apiKeyEl.value.trim()){
          loginStatusEl.textContent = "Enter your API key.";
          loginStatusEl.className = "status err";
          return;
        }
        saveSettings();
        document.getElementById("loginView").classList.add("hidden");
        document.getElementById("appView").classList.remove("hidden");
        setStatus("Welcome to Bingo Control.", "ok");
        loadAuthUser();
        loadGamesMenu();
        loadTarotDeckList();
        loadTarotSessionDecks();
        loadTarotSessions();
        loadTarotNumbers();
        const saved = getSavedPanel();
        if (!getSeenDashboard()){
          showPanelOnce("dashboard");
          setSeenDashboard();
        } else {
          showPanel(saved || "bingo");
        }
        ensureBingoPolling();
      });
      overlayToggle.addEventListener("change", () => {
        document.body.classList.toggle("overlay", overlayToggle.checked);
        overlayToggleBtn.classList.toggle("active", overlayToggle.checked);
        saveSettings();
      });
      overlayToggleBtn.addEventListener("click", () => {
        overlayToggle.checked = !overlayToggle.checked;
        overlayToggle.dispatchEvent(new Event("change"));
      });
      $("overlayExit").addEventListener("click", () => {
        overlayToggle.checked = false;
        document.body.classList.remove("overlay");
        saveSettings();
      });
      $("uploadLibraryClose").addEventListener("click", () => showLibraryModal(false));
      $("uploadLibraryRefresh").addEventListener("click", () => loadLibrary(libraryKind));

      $("deckCreateBackPick").addEventListener("click", () => {
        librarySelectHandler = (item) => {
          $("deckCreateBackPick").dataset.backUrl = item.url || "";
          $("deckCreateBackPick").dataset.artistId = item.artist_id || "";
          const preview = $("deckCreateBackPreview");
          if (preview){
            preview.innerHTML = '<span class="preview-label">Back</span>';
            if (item.url){
              const img = document.createElement("img");
              img.src = item.url;
              preview.appendChild(img);
            }
          }
          setTarotStatus(item.url ? "Deck back selected." : "Pick a deck back.", "ok");
        };
        showLibraryModal(true);
        loadLibrary("media");
      });

      $("deckCreateSuitPreset").addEventListener("change", (ev) => {
        const value = ev.target.value || "custom";
        if (value === "custom"){
          return;
        }
        $("deckCreateSuitJson").value = formatSuitPresetJson(value);
      });
      $("deckCreateSuitJson").addEventListener("input", () => {
        if ($("deckCreateSuitPreset").value !== "custom"){
          $("deckCreateSuitPreset").value = "custom";
        }
      });
      $("deckEditSuitPreset").addEventListener("change", (ev) => {
        const value = ev.target.value || "custom";
        if (value === "custom"){
          return;
        }
        $("deckEditSuitJson").value = formatSuitPresetJson(value);
      });
      $("deckEditSuitJson").addEventListener("input", () => {
        if ($("deckEditSuitPreset").value !== "custom"){
          $("deckEditSuitPreset").value = "custom";
        }
      });

      $("deckCreateSubmit").addEventListener("click", async () => {
        const id = $("deckCreateId").value.trim();
        if (!id){
          setTarotStatus("Deck id is required.", "err");
          return;
        }
        const backUrl = $("deckCreateBackPick").dataset.backUrl || "";
        if (!backUrl){
          setTarotStatus("Pick a deck back before creating the deck.", "err");
          return;
        }
        const name = $("deckCreateName").value.trim();
        const theme = $("deckCreateTheme").value || "classic";
        const seedChoice = $("deckCreateSeed").value || "none";
        const perHouse = Number($("deckCreatePerHouse").value || 0);
        const crownCount = Number($("deckCreateCrown").value || 0);
        const artistId = $("deckCreateBackPick").dataset.artistId || "";
        let suits = null;
        try{
          suits = parseSuitJson($("deckCreateSuitJson").value);
        }catch(err){
          setTarotStatus(err.message, "err");
          return;
        }
        try{
          await jsonFetch("/api/tarot/decks", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
              deck_id: id,
              name: name || undefined,
              theme,
              suits: suits && suits.length ? suits : []
            })
          }, true);
          await jsonFetch("/api/tarot/decks/" + encodeURIComponent(id) + "/back", {
            method:"PUT",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({back_image: backUrl, artist_id: artistId || undefined})
          }, true);
          if (seedChoice === "dummy"){
            await jsonFetch("/api/tarot/decks/" + encodeURIComponent(id) + "/seed", {
              method: "POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({per_house: perHouse, crown_count: crownCount})
            }, true);
          } else if (seedChoice === "default"){
            await jsonFetch("/api/tarot/decks/" + encodeURIComponent(id) + "/seed-template", {
              method: "POST",
              headers: {"Content-Type": "application/json"}
            }, true);
          }
          await loadTarotDeckList(id);
          $("deckCreateModal").classList.remove("show");
          setTarotStatus("Deck created.", "ok");
          await loadTarotDeck();
        }catch(err){
          setTarotStatus(err.message, "err");
        }
      });

      $("taCardLibrary").addEventListener("click", () => {
        librarySelectHandler = (item) => {
          window.taUploadedImageUrl = item.url || "";
          $("taCardArtist").value = item.artist_id || "";
          if (window.taDeckData && window.taDeckData.cards){
            const card = window.taDeckData.cards.find(c => c.card_id === taSelectedCardId);
            if (card){
              card.image = window.taUploadedImageUrl;
              taRenderPreviews(card);
            }
          }
          taSetDirty(true);
          setTarotStatus("Card image selected from library.", "ok");
        };
        showLibraryModal(true);
        loadLibrary("media");
      });

      $("bCreateBgLibrary").addEventListener("click", () => {
        librarySelectHandler = async (item) => {
          const gid = getGameId();
          if (!gid){
            bingoCreateBgUrl = item.url || "";
            $("bCreateBgStatus").textContent = bingoCreateBgUrl
              ? "Background selected for new game."
              : "No background selected.";
            return;
          }
          try{
            await jsonFetch("/bingo/" + encodeURIComponent(gid) + "/background-from-media", {
              method:"POST",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({url: item.url})
            }, true);
            setStatus("Background applied from library.", "ok");
            await refreshBingo();
          }catch(err){
            setStatus(err.message, "err");
          }
        };
        showLibraryModal(true);
        loadLibrary("media");
      });

      $("bCreate").addEventListener("click", async () => {
        try{
          updateBingoCreatePayload();
          const body = {
            title: $("bTitle").value,
            header_text: $("bHeader").value,
            price: Number($("bPrice").value || 0),
            currency: $("bCurrency").value || "gil",
            max_cards_per_player: Number($("bMaxCards").value || 10),
            channel_id: $("bChannelSelect").value || $("bChannel").value || "",
            created_by: $("bCreatedBy").value || "",
            announce_calls: $("bAnnounceCalls").checked,
            theme_color: $("bTheme").value || ""
          };
          const data = await jsonFetch("/bingo/create", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(body)
          });
          setGameId(data.game.game_id || "");
          if (bingoCreateBgUrl){
            try{
              await jsonFetch("/bingo/" + encodeURIComponent(data.game.game_id || "") + "/background-from-media", {
                method:"POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({url: bingoCreateBgUrl})
              }, true);
              setStatus("Background applied from library.", "ok");
            }catch(err){
              setStatus(err.message, "err");
            }
            bingoCreateBgUrl = "";
            $("bCreateBgStatus").textContent = "No background selected.";
          }
          $("bCreateModal").classList.remove("show");
          setStatus("Bingo game created.", "ok");
          renderBingoState({game: data.game});
          loadGamesMenu();
          loadOwnersForGame();
        }catch(err){
          setStatus(err.message, "err");
        }
      });

      async function refreshBingo(){
        const gid = getGameId();
        if (!gid){
          setBingoStatus("Select a game first.", "err");
          return;
        }
        try{
          const data = await jsonFetch("/bingo/" + encodeURIComponent(gid), {method:"GET"}, false);
          renderBingoState(data);
          setBingoStatus("Game refreshed.", "ok");
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      }

      $("bRefresh").addEventListener("click", refreshBingo);
      $("bOwnersRefresh").addEventListener("click", () => loadOwnersForGame());

      $("bAdvanceStage").addEventListener("click", async () => {
        try{
          const data = await jsonFetch("/bingo/advance-stage", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({game_id: getGameId()})
          });
          setBingoStatus(data.ended ? "Game closed." : "Stage advanced.", "ok");
          await refreshBingo();
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      });

      $("bStart").addEventListener("click", async () => {
        try{
          const gid = getGameId();
          if (!gid){
            setBingoStatus("Select a game first.", "err");
            return;
          }
          await jsonFetch("/bingo/start", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({game_id: gid})
          });
          setBingoStatus("Game started.", "ok");
          if (currentGame && currentGame.game_id === gid){
            currentGame.started = true;
            renderBingoState({game: currentGame});
          }
          await refreshBingo();
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      });


      $("bRoll").addEventListener("click", async () => {
        try{
          await jsonFetch("/bingo/roll", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({game_id: getGameId()})
          });
          setBingoStatus("Pulled random number.", "ok");
          await refreshBingo();
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      });

      $("bCloseGame").addEventListener("click", async () => {
        const gid = getGameId();
        if (!gid){
          setBingoStatus("Select a game first.", "err");
          return;
        }
        if (!confirm("This will end the game and lock all cards. Continue?")){
          return;
        }
        try{
          await jsonFetch("/bingo/" + encodeURIComponent(gid), {method:"DELETE"});
          setGameId("");
          currentGame = null;
          $("bOwners").textContent = "";
          const ownersEmpty = $("bOwnersEmpty");
          if (ownersEmpty) ownersEmpty.style.display = "flex";
          $("bClaims").textContent = "No claims yet.";
          $("bTitleVal").textContent = "No title";
          $("bHeaderVal").textContent = "No header";
          $("bStageVal").textContent = "No stage";
          $("bPotVal").textContent = "No pot";
          $("bCalled").textContent = "No numbers called yet.";
          $("bCalledGrid").innerHTML = "";
          $("bCardHeader").innerHTML = "";
          $("bCardGrid").innerHTML = "";
          setBingoStatus("Game closed.", "ok");
          await loadGamesMenu();
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      });


      $("bBuy").addEventListener("click", async () => {
        try{
          const gid = getGameId();
          const ownerName = $("bOwner").value.trim();
          const qty = Number($("bQty").value || 1);
          if (!ownerName){
            setBingoStatus("Owner name is required.", "err");
            return;
          }
          if (!Number.isFinite(qty) || qty < 1){
            setBingoStatus("Quantity must be at least 1.", "err");
            return;
          }
          const body = {
            game_id: gid,
            owner_name: ownerName,
            owner_user_id: $("bOwnerId").value.trim() || null,
            quantity: qty
          };
          await jsonFetch("/bingo/buy", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(body)
          });
          setBingoStatus("Cards bought.", "ok");
          await loadOwnersForGame();
          if (gid && ownerName){
            const data = await jsonFetch("/bingo/" + encodeURIComponent(gid) + "/owner/" + encodeURIComponent(ownerName) + "/token", {method:"GET"});
            const base = getBase();
            const url = new URL("/bingo/owner?token=" + encodeURIComponent(data.token || ""), base).toString();
            $("bPurchaseLink").value = url;
            $("bPurchaseStatus").textContent = "Share this link with the player.";
            $("bPurchaseModal").classList.add("show");
          }
        }catch(err){
          setBingoStatus(err.message, "err");
        }
      });

      $("bViewOwner").addEventListener("click", () => {
        const gid = getGameId();
        const owner = $("bOwner").value.trim();
        if (!gid || !owner){
          setBingoStatus("Enter game id and owner name.", "err");
          return;
        }
        currentOwner = owner;
        jsonFetch("/bingo/" + encodeURIComponent(gid) + "/owner/" + encodeURIComponent(owner) + "/token", {method:"GET"})
          .then(data => {
            const base = getBase();
            const url = new URL("/bingo/owner?token=" + encodeURIComponent(data.token || ""), base).toString();
            window.open(url, "_blank");
          })
          .catch(err => setStatus(err.message, "err"));
      });

      function getOverlayUrl(code){
        const base = getBase();
        return new URL("/overlay/session/" + encodeURIComponent(code), base).toString();
      }

      function getPlayerUrl(code){
        const base = getBase();
        return new URL("/tarot/session/" + encodeURIComponent(code) + "?view=player", base).toString();
      }

      function getPriestessUrl(code, token){
        const base = getBase();
        const url = new URL("/tarot/session/" + encodeURIComponent(code), base);
        url.searchParams.set("view", "priestess");
        if (token) url.searchParams.set("token", token);
        return url.toString();
      }

      function renderLinks(code, token){
        const links = [];
        if (code){
          links.push(`<a href="${getPlayerUrl(code)}" target="_blank" rel="noreferrer">Player</a>`);
          links.push(`<a href="${getPriestessUrl(code, token)}" target="_blank" rel="noreferrer">Priestess</a>`);
          links.push(`<a href="${getOverlayUrl(code)}" target="_blank" rel="noreferrer">Overlay</a>`);
        }
        $("tLink").innerHTML = links.length ? links.join(" | ") : "No join code entered.";
      }

      async function loadTarotSessionDecks(selectValue){
        try{
          const data = await jsonFetch("/api/tarot/decks", {method:"GET"}, true);
          const decks = data.decks || [];
          const modalSelect = $("sessionCreateDeck");
          modalSelect.innerHTML = "";
          decks.forEach(d => {
            const opt2 = document.createElement("option");
            opt2.value = d.deck_id;
            opt2.textContent = d.name ? `${d.name} (${d.deck_id})` : d.deck_id;
            modalSelect.appendChild(opt2);
          });
          modalSelect.value = selectValue || (decks[0] ? decks[0].deck_id : "elf-classic");
        }catch(err){
          setStatus(err.message, "err");
        }
      }

      $("tCreateSession").addEventListener("click", () => {
        $("sessionCreateModal").classList.add("show");
      });
      $("sessionCreateClose").addEventListener("click", () => {
        $("sessionCreateModal").classList.remove("show");
      });
      $("sessionCreateSubmit").addEventListener("click", async () => {
        try{
          const deck = $("sessionCreateDeck").value.trim() || "elf-classic";
          const spread = $("sessionCreateSpread").value.trim() || "single";
          const data = await jsonFetch("/api/tarot/sessions", {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({deck_id: deck, spread_id: spread})
          }, true);
          $("tJoinCode").value = data.joinCode || "";
          $("tPriestessToken").value = data.priestessToken || "";
          renderLinks(data.joinCode || "", data.priestessToken || "");
          setStatus("Session created.", "ok");
          await loadTarotSessions(data.joinCode || "");
          $("sessionCreateModal").classList.remove("show");
          if (data.joinCode){
            window.open(getPriestessUrl(data.joinCode, data.priestessToken || ""), "_blank");
          }
        }catch(err){
          setStatus(err.message, "err");
        }
      });

      async function loadTarotSessions(selectJoin){
        try{
          const data = await jsonFetch("/api/tarot/sessions", {method:"GET"}, true);
          const select = $("tSessionSelect");
          select.innerHTML = "";
          const sessions = data.sessions || [];
          sessions.forEach(s => {
            const opt = document.createElement("option");
            opt.value = s.join_code || "";
            const created = s.created_at ? new Date(s.created_at * 1000).toLocaleString() : "unknown";
            opt.textContent = `${s.join_code || "-"} | ${s.deck_id || "-"} | ${s.spread_id || "-"} | ${s.status || "-"} | ${created}`;
            opt.dataset.token = s.priestess_token || "";
            select.appendChild(opt);
          });
          if (selectJoin){
            select.value = selectJoin;
          }
        }catch(err){
          setStatus(err.message, "err");
        }
      }

      $("tSessionRefresh").addEventListener("click", () => loadTarotSessions());
      $("tSessionSelect").addEventListener("change", (ev) => {
        const join = ev.target.value || "";
        const token = ev.target.selectedOptions.length ? (ev.target.selectedOptions[0].dataset.token || "") : "";
        $("tJoinCode").value = join;
        $("tPriestessToken").value = token;
        renderLinks(join, token);
      });

      $("tOpenOverlay").addEventListener("click", () => {
        const code = $("tJoinCode").value.trim();
        if (!code){
          setStatus("Enter a join code.", "err");
          return;
        }
        const url = getOverlayUrl(code);
        renderLinks(code, $("tPriestessToken").value.trim());
        window.open(url, "_blank");
      });

      $("tOpenPlayer").addEventListener("click", () => {
        const code = $("tJoinCode").value.trim();
        if (!code){
          setStatus("Enter a join code.", "err");
          return;
        }
        const url = getPlayerUrl(code);
        renderLinks(code, $("tPriestessToken").value.trim());
        window.open(url, "_blank");
      });

      $("tOpenPriestess").addEventListener("click", () => {
        const code = $("tJoinCode").value.trim();
        if (!code){
          setStatus("Enter a join code.", "err");
          return;
        }
        const token = $("tPriestessToken").value.trim();
        const url = getPriestessUrl(code, token);
        renderLinks(code, token);
        window.open(url, "_blank");
      });

      $("tCloseSession").addEventListener("click", async () => {
        const join = $("tJoinCode").value.trim();
        const token = $("tPriestessToken").value.trim();
        if (!join || !token){
          setStatus("Join code and priestess token required.", "err");
          return;
        }
        if (!confirm("Close this session? It will be removed from the list.")){
          return;
        }
        try{
          const state = await jsonFetch("/api/tarot/sessions/" + encodeURIComponent(join) + "/state?view=priestess", {method:"GET"}, true);
          const sessionId = state.state && state.state.session ? state.state.session.session_id : "";
          if (!sessionId){
            throw new Error("Session not found.");
          }
          await jsonFetch("/api/tarot/sessions/" + encodeURIComponent(sessionId), {
            method: "DELETE",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({token})
          });
          setStatus("Session closed.", "ok");
          await loadTarotSessions();
        }catch(err){
          setStatus(err.message, "err");
        }
      });

      let taNumbers = [];
      let taSuitDefs = [];
      let taSuitLookup = {};

      function taThemeLabel(theme){
        return (theme || "").replace(/_/g, " ");
      }

      function taNormalizeSuitKey(value){
        return String(value || "").trim().toLowerCase();
      }

      function taSetSuitDefinitions(defs){
        taSuitDefs = Array.isArray(defs) ? defs : [];
        taSuitLookup = {};
        taSuitDefs.forEach(def => {
          if (!def) return;
          const id = taNormalizeSuitKey(def.id);
          const name = taNormalizeSuitKey(def.name);
          if (id) taSuitLookup[id] = def;
          if (name) taSuitLookup[name] = def;
        });
        taUpdateSuitList();
      }

      function taUpdateSuitList(){
        const list = $("taSuitList");
        if (!list) return;
        const defaults = ["Major", "Wands", "Cups", "Swords", "Pentacles", "Hearts", "Spades", "Clubs", "Diamonds"];
        const extra = taSuitDefs.map(def => def && (def.name || def.id)).filter(Boolean);
        const combined = Array.from(new Set(defaults.concat(extra)));
        list.innerHTML = combined.map(value => `<option value="${value}"></option>`).join("");
      }

      function taFindSuitDef(value){
        const key = taNormalizeSuitKey(value);
        if (!key) return null;
        return taSuitLookup[key] || null;
      }

      function taParseRoman(value){
        const roman = String(value || "").trim().toUpperCase();
        if (!roman) return NaN;
        const map = {I:1, V:5, X:10, L:50, C:100, D:500, M:1000};
        let total = 0;
        let prev = 0;
        for (let i = roman.length - 1; i >= 0; i -= 1){
          const num = map[roman[i]];
          if (!num) return NaN;
          if (num < prev){
            total -= num;
          } else {
            total += num;
            prev = num;
          }
        }
        return total;
      }

      function taParseCardNumber(value){
        const text = String(value).trim();
        if (!text) return NaN;
        if (/^\d+$/.test(text)) return parseInt(text, 10);
        return taParseRoman(text);
      }

      function taToRoman(num){
        const n = Number(num);
        if (!Number.isFinite(n) || n <= 0) return "";
        const map = [
          [1000, "M"], [900, "CM"], [500, "D"], [400, "CD"],
          [100, "C"], [90, "XC"], [50, "L"], [40, "XL"],
          [10, "X"], [9, "IX"], [5, "V"], [4, "IV"], [1, "I"]
        ];
        let out = "";
        let remaining = Math.floor(n);
        map.forEach(([val, sym]) => {
          while (remaining >= val){
            out += sym;
            remaining -= val;
          }
        });
        return out;
      }

      function taFormatCardNumber(value){
        if (String(value || "").trim() === "0") return "0";
        const num = taParseCardNumber(value);
        if (num === 0) return "0";
        return num ? taToRoman(num) || String(value || "") : "";
      }

      let taDirty = false;
      let taSuppressDirty = false;

      function setTarotStatus(msg, kind){
        const el = $("taDeckStatus");
        if (!el) return;
        el.textContent = msg;
        el.className = "status" + (kind ? " " + kind : "");
      }

      function taSetDirty(state){
        if (taSuppressDirty) return;
        taDirty = !!state;
        if (taDirty){
          setTarotStatus("Unsaved changes", "alert");
        }
      }

      function taUpdateThemeRow(row, value){
        const fill = row.querySelector(".theme-fill");
        const valueEl = row.querySelector(".theme-value");
        const weight = Math.max(0, Math.min(5, parseInt(value, 10) || 0));
        if (fill){
          fill.style.width = `${(weight / 5) * 100}%`;
        }
        if (valueEl){
          valueEl.textContent = `${weight} / 5`;
        }
      }

      function taSnippet(text, limit = 120){
        const clean = String(text || "").trim();
        if (!clean) return "";
        if (clean.length <= limit) return clean;
        return clean.slice(0, limit - 3) + "...";
      }

      function taUpdateContext(card){
        const deckName = window.taDeckData && window.taDeckData.deck
          ? (window.taDeckData.deck.name || window.taDeckData.deck.deck_id || "")
          : "";
        const deckId = window.taDeckData && window.taDeckData.deck ? window.taDeckData.deck.deck_id : "";
        const cardLabel = card && (card.name || card.card_id) ? (card.name || card.card_id) : "No card selected";
        const path = $("taContextPath");
        const meta = $("taContextMeta");
        const deckMeta = $("taContextDeck");
        if (path){
          path.textContent = `Deck Editor / Forest / ${cardLabel}`;
        }
        if (meta){
          meta.textContent = card ? `Editing ${cardLabel}` : "Pick a card to edit.";
        }
        if (deckMeta){
          deckMeta.textContent = deckId ? `${deckName} (${deckId})` : "";
        }
      }

      function taRenderThemeWeights(weights, suitValue){
        const grid = $("taCardThemes");
        const hint = $("taCardThemesHint");
        if (!grid) return;
        grid.innerHTML = "";
        const suitDef = taFindSuitDef(suitValue);
        const themes = suitDef && suitDef.themes ? Object.keys(suitDef.themes) : [];
        if (!suitValue){
          if (hint) hint.textContent = "Select a suit to see theme weights.";
          return;
        }
        if (!suitDef){
          if (hint) hint.textContent = "Suit not defined for this deck.";
          return;
        }
        if (!themes.length){
          if (hint) hint.textContent = "No theme weights available for this suit.";
          return;
        }
        if (hint) hint.textContent = "Adjust theme weights for this card.";
        themes.forEach(theme => {
          const row = document.createElement("div");
          row.className = "theme-weight";
          row.dataset.theme = theme;
          const label = document.createElement("label");
          label.textContent = taThemeLabel(theme);
          const bar = document.createElement("div");
          bar.className = "theme-bar";
          const fill = document.createElement("div");
          fill.className = "theme-fill";
          bar.appendChild(fill);
          const input = document.createElement("input");
          input.type = "range";
          input.min = "0";
          input.max = "5";
          input.step = "1";
          input.value = weights && weights[theme] ? weights[theme] : 0;
          const value = document.createElement("div");
          value.className = "theme-value";
          row.appendChild(label);
          row.appendChild(bar);
          row.appendChild(input);
          row.appendChild(value);
          taUpdateThemeRow(row, input.value);
          input.addEventListener("input", () => {
            taUpdateThemeRow(row, input.value);
            taSetDirty(true);
          });
          grid.appendChild(row);
        });
      }

      function taSetCardThemeWeights(weights){
        const grid = $("taCardThemes");
        if (!grid){
          return;
        }
        if (!grid.children.length){
          taRenderThemeWeights(weights || {}, $("taCardSuit").value.trim());
          return;
        }
        grid.querySelectorAll(".theme-weight").forEach(row => {
          const theme = row.dataset.theme;
          const input = row.querySelector("input");
          if (!input) return;
          input.value = weights && weights[theme] ? weights[theme] : 0;
          taUpdateThemeRow(row, input.value);
        });
      }

      function taGetCardThemeWeights(){
        const grid = $("taCardThemes");
        const out = {};
        if (!grid) return out;
        grid.querySelectorAll(".theme-weight").forEach(row => {
          const theme = row.dataset.theme;
          const input = row.querySelector("input");
          if (!input) return;
          const value = parseInt(input.value, 10);
          if (Number.isFinite(value) && value > 0){
            out[theme] = value;
          }
        });
        return out;
      }

      function taApplySuitThemeDefaults(suitValue){
        if (!suitValue) return;
        const current = taGetCardThemeWeights();
        if (Object.keys(current).length){
          return;
        }
        const suitDef = taFindSuitDef(suitValue);
        if (!suitDef || !suitDef.themes) return;
        taSetCardThemeWeights(suitDef.themes);
      }

      function taRenderSuitInfo(value){
        const box = $("taSuitInfo");
        if (!box) return;
        const suitDef = taFindSuitDef(value);
        if (!suitDef){
          box.textContent = value ? "Suit not defined for this deck." : "Pick a suit to see details.";
          return;
        }
        const themes = Object.entries(suitDef.themes || {}).map(([k, v]) => `${k} (${v})`).join(", ");
        const keywords = (suitDef.keywords || []).join(", ");
        const upright = keywords ? `Upright: ${keywords}.` : "Upright: -";
        const reversed = keywords ? `Reversed: blocked or twisted ${keywords}.` : "Reversed: -";
        const title = suitDef.name || suitDef.id || "Suit";
        box.innerHTML = `<strong>${title}</strong><br><span class="muted">${themes || "No themes set."}</span><br><span class="muted">${keywords || "No keywords set."}</span><br>${upright}<br>${reversed}`;
      }

      function taRenderNumberInfo(value){
        const box = $("taNumberInfo");
        if (!box) return;
        const num = taParseCardNumber(value);
        if (!Number.isFinite(num)){
          box.textContent = "Pick a number to see details.";
          return;
        }
        const digits = String(num).split("").map(d => parseInt(d, 10));
        let sum = digits.reduce((acc, d) => acc + d, 0);
        while (sum > 10){
          sum = String(sum).split("").reduce((acc, d) => acc + parseInt(d, 10), 0);
        }
        const picks = [];
        digits.forEach(d => { if (!picks.includes(d)) picks.push(d); });
        if (sum > 0 && !picks.includes(sum)) picks.push(sum);
        if (num === 0 && !picks.includes(0)) picks.push(0);
        const rows = picks.map(pick => {
          const entry = taNumbers.find(n => Number(n.number) === pick);
          const label = entry && entry.label ? ` - ${entry.label}` : "";
          const meaning = entry && entry.meaning ? entry.meaning : "";
          return `<div><strong>${pick}${label}</strong><br>${meaning}</div>`;
        }).join("<div style=\"height:6px\"></div>");
        box.innerHTML = rows || "No number details found.";
      }

      function taRenderPreviews(card){
        const front = $("taFrontPreview");
        const back = $("taBackPreview");
        const backUrl = window.taDeckData && window.taDeckData.deck ? window.taDeckData.deck.back_image : "";
        const theme = (window.taDeckData && window.taDeckData.deck && window.taDeckData.deck.theme) || "classic";
        front.dataset.cardTheme = theme;
        front.classList.add("card-object", "hover-flip");
        back.classList.add("card-object");
        front.innerHTML = '<span class="preview-label">Front</span>';
        back.innerHTML = '<span class="preview-label">Back</span>';
        if (card && card.image){
          const img = document.createElement("img");
          img.src = card.image;
          front.appendChild(img);
        }
        if (card && card.number !== undefined && card.number !== null){
          const number = document.createElement("div");
          number.className = "card-number";
          number.textContent = taFormatCardNumber(card.number);
          front.appendChild(number);
        }
        if (card && card.name){
          const title = document.createElement("div");
          title.className = "card-title";
          title.textContent = card.name;
          front.appendChild(title);
        }
        if (card && (card.upright || card.reversed)){
          const meaning = document.createElement("div");
          meaning.className = "card-meaning";
          const up = document.createElement("div");
          up.className = "meaning-line upright";
          up.textContent = "Upright: " + taSnippet(card.upright || "", 120);
          const rev = document.createElement("div");
          rev.className = "meaning-line reversed";
          rev.textContent = "Reversed: " + taSnippet(card.reversed || "", 120);
          meaning.appendChild(up);
          meaning.appendChild(rev);
          front.appendChild(meaning);
        }
        if (backUrl){
          const img = document.createElement("img");
          img.src = backUrl;
          back.appendChild(img);
        }
      }

      function taLoadCard(card){
        if (!card) return;
        taSuppressDirty = true;
        taSelectedCardId = card.card_id || "";
        $("taCardId").value = card.card_id || "";
        $("taCardName").value = card.name || "";
        $("taCardSuit").value = card.suit || "";
        $("taCardNumber").value = (card.number !== undefined && card.number !== null) ? card.number : "";
        $("taCardTags").value = (card.tags || []).join(", ");
        $("taCardFlavor").value = card.flavor_text || "";
        $("taCardUpright").value = card.upright || "";
        $("taCardReversed").value = card.reversed || "";
        $("taCardArtist").value = card.artist_id || "";
        window.taUploadedImageUrl = card.image || "";
        taRenderThemeWeights(card.themes || {}, card.suit || "");
        taRenderSuitInfo(card.suit || "");
        taRenderNumberInfo($("taCardNumber").value);
        taApplySuitThemeDefaults(card.suit || "");
        taRenderPreviews(card);
        taSyncCardSelection();
        taUpdateContext(card);
        taDirty = false;
        taSuppressDirty = false;
      }

      function taSyncCardSelection(){
        const list = $("taDeckList");
        if (!list) return;
        list.querySelectorAll(".list-card").forEach(el => {
          const active = taSelectedCardId && el.dataset.cardId === taSelectedCardId;
          el.classList.toggle("active", active);
        });
        if (window.taDeckData && window.taDeckData.cards && taSelectedCardId){
          const match = window.taDeckData.cards.find(c => c.card_id === taSelectedCardId);
          if (match){
            taRenderPreviews(match);
          }
        } else {
          taUpdateContext(null);
        }
      }

      async function loadTarotNumbers(){
        try{
          const data = await jsonFetch("/api/tarot/numbers", {method:"GET"}, true);
          taNumbers = data.numbers || [];
          const input = $("taCardNumber");
          const current = input.value || "";
          const list = $("taNumberList");
          list.innerHTML = "";
          taNumbers.forEach(n => {
            const opt = document.createElement("option");
            opt.value = n.number;
            opt.textContent = n.label ? `${n.number} - ${n.label}` : String(n.number);
            list.appendChild(opt);
          });
          input.value = current;
          taRenderNumberInfo(input.value);
        }catch(err){
          setTarotStatus("Failed to load numbers.", "err");
        }
      }

      async function loadTarotArtists(){
        try{
          const data = await jsonFetch("/api/tarot/artists", {method:"GET"}, true);
          const artists = data.artists || [];
          window.taArtists = artists;
        const selects = ["uploadLibraryArtist", "mediaUploadArtist", "artistIndexSelect", "galleryEditArtist"];
          selects.forEach(id => {
            const sel = $(id);
            if (!sel) return;
            sel.innerHTML = "";
            const none = document.createElement("option");
            none.value = "";
            none.textContent = "(none)";
            sel.appendChild(none);
            artists.forEach(a => {
              const opt = document.createElement("option");
              opt.value = a.artist_id || "";
              opt.textContent = a.name ? `${a.name} (${a.artist_id})` : (a.artist_id || "");
              sel.appendChild(opt);
            });
          });
        }catch(err){
          window.taArtists = [];
          setStatus("Failed to load artists.", "err");
        }
      }

      $("artistIndexRefresh").addEventListener("click", () => loadTarotArtists());
      $("artistIndexSelect").addEventListener("change", (ev) => {
        const pick = (window.taArtists || []).find(a => a.artist_id === ev.target.value);
        if (!pick){
          $("artistIndexId").value = "";
          $("artistIndexName").value = "";
          $("artistIndexInstagram").value = "";
          $("artistIndexBluesky").value = "";
          $("artistIndexX").value = "";
          $("artistIndexArtstation").value = "";
          $("artistIndexWebsite").value = "";
          return;
        }
        $("artistIndexId").value = pick.artist_id || "";
        $("artistIndexName").value = pick.name || "";
        const links = pick.links || {};
        $("artistIndexInstagram").value = links.instagram || "";
        $("artistIndexBluesky").value = links.bluesky || "";
        $("artistIndexX").value = links.x || "";
        $("artistIndexArtstation").value = links.artstation || "";
        $("artistIndexWebsite").value = links.website || "";
      });
      $("artistIndexSave").addEventListener("click", async () => {
        try{
          const body = {
            artist_id: $("artistIndexId").value.trim() || undefined,
            name: $("artistIndexName").value.trim(),
            links: {
              instagram: $("artistIndexInstagram").value.trim(),
              bluesky: $("artistIndexBluesky").value.trim(),
              x: $("artistIndexX").value.trim(),
              artstation: $("artistIndexArtstation").value.trim(),
              website: $("artistIndexWebsite").value.trim()
            }
          };
          const res = await fetch("/api/tarot/artists", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-API-Key": apiKeyEl.value.trim()
            },
            body: JSON.stringify(body)
          });
          const data = await res.json();
          if (!data.ok) throw new Error(data.error || "Failed");
          await loadTarotArtists();
          setStatus("Artist saved.", "ok");
        }catch(err){
          setStatus(err.message, "err");
        }
      });
      $("artistIndexDelete").addEventListener("click", async () => {
        const artistId = $("artistIndexId").value.trim();
        if (!artistId){
          setStatus("Select an artist to delete.", "err");
          return;
        }
        if (!confirm("Delete this artist? Cards will keep the artist_id but links will no longer resolve.")){
          return;
        }
        try{
          const res = await fetch("/api/tarot/artists/" + encodeURIComponent(artistId), {
            method: "DELETE",
            headers: {"X-API-Key": apiKeyEl.value.trim()}
          });
          const data = await res.json();
          if (!data.ok) throw new Error(data.error || "Failed");
          $("artistIndexId").value = "";
          $("artistIndexName").value = "";
          $("artistIndexInstagram").value = "";
          $("artistIndexBluesky").value = "";
          $("artistIndexX").value = "";
          $("artistIndexArtstation").value = "";
          $("artistIndexWebsite").value = "";
          await loadTarotArtists();
          setStatus("Artist deleted.", "ok");
        }catch(err){
          setStatus(err.message, "err");
        }
      });

      $("mediaLibraryOpen").addEventListener("click", () => {
        librarySelectHandler = null;
        showLibraryModal(true);
        loadLibrary("media");
        loadTarotArtists();
      });

      $("mediaLibraryRefresh").addEventListener("click", () => loadMediaLibrary());
      $("mediaUploadFile").addEventListener("change", (ev) => {
        const file = ev.target.files[0] || null;
        mediaUploadFile = file;
        updateMediaUploadDropDisplay(file);
        updateMediaUploadState();
      });
      $("mediaUploadTitleInput").addEventListener("input", () => updateMediaUploadState());

      const mediaDrop = $("mediaUploadDrop");
      if (mediaDrop){
        mediaDrop.addEventListener("click", () => $("mediaUploadFile").click());
        mediaDrop.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter" || ev.key === " "){
            ev.preventDefault();
            $("mediaUploadFile").click();
          }
        });
        mediaDrop.addEventListener("dragover", (ev) => {
          ev.preventDefault();
          mediaDrop.classList.add("dragover");
        });
        mediaDrop.addEventListener("dragleave", () => mediaDrop.classList.remove("dragover"));
        mediaDrop.addEventListener("drop", (ev) => {
          ev.preventDefault();
          mediaDrop.classList.remove("dragover");
          const file = ev.dataTransfer && ev.dataTransfer.files ? ev.dataTransfer.files[0] : null;
          if (file){
            mediaUploadFile = file;
            updateMediaUploadDropDisplay(file);
            updateMediaUploadState();
          }
        });
      }

      $("mediaUploadUpload").addEventListener("click", async () => {
        const file = mediaUploadFile || ($("mediaUploadFile").files[0] || null);
        if (!file){
          setMediaUploadStatus("Select an image to upload.", "err");
          return;
        }
        const title = $("mediaUploadTitleInput").value.trim();
        if (!title){
          setMediaUploadStatus("Enter a title before uploading.", "err");
          return;
        }
        try{
          $("mediaUploadUpload").disabled = true;
          setMediaUploadStatus("Uploading...", "");
          const fd = new FormData();
          fd.append("file", file);
          fd.append("title", title);
          const artistId = $("mediaUploadArtist").value.trim();
          if (artistId) fd.append("artist_id", artistId);
          const res = await fetch("/api/media/upload", {
            method: "POST",
            headers: {"X-API-Key": apiKeyEl.value.trim()},
            body: fd
          });
          const data = await res.json();
          if (!data.ok) throw new Error(data.error || "Failed");
          $("mediaUploadFile").value = "";
          $("mediaUploadTitleInput").value = "";
          mediaUploadFile = null;
          updateMediaUploadDropDisplay(null);
          setMediaUploadStatus("Upload complete.", "ok");
          await loadMediaLibrary();
        }catch(err){
          setMediaUploadStatus(err.message, "err");
        }finally{
          updateMediaUploadState();
        }
      });

      $("uploadLibraryFile").addEventListener("change", (ev) => {
        const file = ev.target.files[0] || null;
        libraryUploadFile = file;
        updateUploadDropDisplay(file);
        updateUploadState();
      });
      $("uploadLibraryTitleInput").addEventListener("input", () => updateUploadState());

      const uploadDrop = $("uploadLibraryDrop");
      if (uploadDrop){
        uploadDrop.addEventListener("click", () => $("uploadLibraryFile").click());
        uploadDrop.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter" || ev.key === " "){
            ev.preventDefault();
            $("uploadLibraryFile").click();
          }
        });
        uploadDrop.addEventListener("dragover", (ev) => {
          ev.preventDefault();
          uploadDrop.classList.add("dragover");
        });
        uploadDrop.addEventListener("dragleave", () => uploadDrop.classList.remove("dragover"));
        uploadDrop.addEventListener("drop", (ev) => {
          ev.preventDefault();
          uploadDrop.classList.remove("dragover");
          const file = ev.dataTransfer && ev.dataTransfer.files ? ev.dataTransfer.files[0] : null;
          if (file){
            libraryUploadFile = file;
            updateUploadDropDisplay(file);
            updateUploadState();
          }
        });
      }

      $("uploadLibraryUpload").addEventListener("click", async () => {
        const file = libraryUploadFile || $("uploadLibraryFile").files[0];
        if (!file){
          setLibraryStatus("Select an image to upload.", "err");
          return;
        }
        const title = $("uploadLibraryTitleInput").value.trim();
        if (!title){
          setLibraryStatus("Enter a title before uploading.", "err");
          return;
        }
        try{
          $("uploadLibraryUpload").disabled = true;
          setLibraryStatus("Uploading...", "");
          const fd = new FormData();
          fd.append("file", file);
          fd.append("title", title);
          const artistId = $("uploadLibraryArtist").value.trim();
          if (artistId) fd.append("artist_id", artistId);
          const res = await fetch("/api/media/upload", {
            method: "POST",
            headers: {"X-API-Key": apiKeyEl.value.trim()},
            body: fd
          });
          const data = await res.json();
          if (!data.ok) throw new Error(data.error || "Failed");
          $("uploadLibraryFile").value = "";
          $("uploadLibraryTitleInput").value = "";
          libraryUploadFile = null;
          updateUploadDropDisplay(null);
          setLibraryStatus("Upload complete.", "ok");
          await loadLibrary("media");
        }catch(err){
          setLibraryStatus(err.message, "err");
        }finally{
          updateUploadState();
        }
      });

      $("taCardSuit").addEventListener("input", () => {
        const suitValue = $("taCardSuit").value.trim();
        taRenderSuitInfo(suitValue);
        taRenderThemeWeights({}, suitValue);
        taApplySuitThemeDefaults(suitValue);
        taSetDirty(true);
      });
      $("taCardNumber").addEventListener("input", (ev) => {
        taRenderNumberInfo(ev.target.value);
        taRenderPreviews({
          name: $("taCardName").value.trim(),
          number: ev.target.value,
          image: window.taUploadedImageUrl || ""
        });
        taSetDirty(true);
      });
      ["taCardId", "taCardName", "taCardTags", "taCardFlavor", "taCardUpright", "taCardReversed"].forEach((id) => {
        const el = $(id);
        if (!el) return;
        el.addEventListener("input", () => {
          taSetDirty(true);
          if (id === "taCardName"){
            taRenderPreviews({
              name: $("taCardName").value.trim(),
              number: $("taCardNumber").value.trim(),
              image: window.taUploadedImageUrl || ""
            });
          }
        });
      });
      $("taDeckList").addEventListener("click", (ev) => {
        const target = ev.target.closest(".list-card");
        if (!target || !target.dataset.cardId || !window.taDeckData) return;
        const card = (window.taDeckData.cards || []).find(c => c.card_id === target.dataset.cardId);
        if (card){
          taLoadCard(card);
        }
      });
      async function loadTarotDeck(){
        try{
          const deck = $("taDeck").value.trim() || "elf-classic";
          const data = await jsonFetch("/api/tarot/decks/" + encodeURIComponent(deck), {method:"GET"}, true);
          showList($("taDeckList"), data);
          taSetSuitDefinitions(data.deck && Array.isArray(data.deck.suits) ? data.deck.suits : []);
          taRenderPreviews(null);
          const deckName = (data.deck && (data.deck.name || data.deck.deck_id)) || deck;
          const count = Array.isArray(data.cards) ? data.cards.length : 0;
          setTarotStatus(`Deck loaded: ${deckName} (${count} cards)`, "ok");
          taUpdateContext(null);
          taDirty = false;
        }catch(err){
          setTarotStatus(err.message, "err");
        }
      }

      $("taDeck").addEventListener("change", async () => {
        await loadTarotDeck();
      });

      $("taAddDeck").addEventListener("click", () => {
        $("deckCreateId").value = "";
        $("deckCreateName").value = "";
        $("deckCreateTheme").value = "classic";
        $("deckCreateSeed").value = "none";
        $("deckCreatePerHouse").value = "4";
        $("deckCreateCrown").value = "1";
        $("deckCreateSuitPreset").value = "forest";
        $("deckCreateSuitJson").value = formatSuitPresetJson("forest");
        $("deckCreateBackPick").dataset.backUrl = "";
        $("deckCreateBackPick").dataset.artistId = "";
        $("deckCreateBackPreview").innerHTML = '<span class="preview-label">Back</span>';
        $("deckCreateModal").classList.add("show");
      });

      $("taEditDeck").addEventListener("click", async () => {
        const deck = $("taDeck").value.trim();
        if (!deck){
          setTarotStatus("Pick a deck to edit.", "err");
          return;
        }
        try{
          if (!window.taDeckData || !window.taDeckData.deck || window.taDeckData.deck.deck_id !== deck){
            const data = await jsonFetch("/api/tarot/decks/" + encodeURIComponent(deck), {method:"GET"}, true);
            showList($("taDeckList"), data);
          }
          const deckData = window.taDeckData && window.taDeckData.deck ? window.taDeckData.deck : {};
          $("deckEditName").value = deckData.name || "";
          $("deckEditTheme").value = deckData.theme || "classic";
          const suits = Array.isArray(deckData.suits) ? deckData.suits : [];
          deckEditHadSuits = suits.length > 0;
          if (suits.length){
            $("deckEditSuitPreset").value = "custom";
            $("deckEditSuitJson").value = JSON.stringify(suits, null, 2);
          }else{
            $("deckEditSuitPreset").value = "forest";
            $("deckEditSuitJson").value = formatSuitPresetJson("forest");
          }
          const backUrl = deckData.back_image || "";
          const preview = $("deckEditBackPreview");
          if (preview){
            preview.innerHTML = '<span class="preview-label">Back</span>';
            if (backUrl){
              const img = document.createElement("img");
              img.src = backUrl;
              preview.appendChild(img);
            }
          }
          $("deckEditBackPick").dataset.backUrl = backUrl;
          $("deckEditBackPick").dataset.artistId = deckData.back_artist_id || "";
          $("deckEditModal").classList.add("show");
        }catch(err){
          setTarotStatus(err.message, "err");
        }
      });

      $("deckEditClose").addEventListener("click", () => {
        $("deckEditModal").classList.remove("show");
      });
      $("deckEditModal").addEventListener("click", (event) => {
        if (event.target === $("deckEditModal")){
          $("deckEditModal").classList.remove("show");
        }
      });
      $("deckEditBackPick").addEventListener("click", () => {
        librarySelectHandler = (item) => {
          $("deckEditBackPick").dataset.backUrl = item.url || "";
          $("deckEditBackPick").dataset.artistId = item.artist_id || "";
          const preview = $("deckEditBackPreview");
          if (preview){
            preview.innerHTML = '<span class="preview-label">Back</span>';
            if (item.url){
              const img = document.createElement("img");
              img.src = item.url;
              preview.appendChild(img);
            }
          }
          setTarotStatus(item.url ? "Deck back selected." : "Pick a deck back.", "ok");
        };
        showLibraryModal(true);
        loadLibrary("media");
      });

      $("deckEditTheme").addEventListener("change", (ev) => {
        const theme = ev.target.value || "classic";
        if (!window.taDeckData) window.taDeckData = {};
        window.taDeckData.deck = window.taDeckData.deck || {};
        window.taDeckData.deck.theme = theme;
        taRenderPreviews({
          name: $("taCardName").value.trim(),
          number: $("taCardNumber").value.trim(),
          image: window.taUploadedImageUrl || ""
        });
      });

      $("deckEditSubmit").addEventListener("click", async () => {
        const deck = $("taDeck").value.trim();
        if (!deck){
          setTarotStatus("Pick a deck to edit.", "err");
          return;
        }
        const name = $("deckEditName").value.trim();
        const theme = $("deckEditTheme").value || "classic";
        const backUrl = $("deckEditBackPick").dataset.backUrl || "";
        const artistId = $("deckEditBackPick").dataset.artistId || "";
        let suits = null;
        try{
          suits = parseSuitJson($("deckEditSuitJson").value);
        }catch(err){
          setTarotStatus(err.message, "err");
          return;
        }
        if (!deckEditHadSuits && (!suits || !suits.length)){
          setTarotStatus("Choose a suit preset to migrate this deck.", "err");
          return;
        }
        try{
          await jsonFetch("/api/tarot/decks/" + encodeURIComponent(deck), {
            method:"PUT",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
              name: name || undefined,
              theme,
              suits: suits && suits.length ? suits : []
            })
          }, true);
          if (backUrl){
            await jsonFetch("/api/tarot/decks/" + encodeURIComponent(deck) + "/back", {
              method:"PUT",
              headers: {"Content-Type": "application/json"},
              body: JSON.stringify({back_image: backUrl, artist_id: artistId || undefined})
            }, true);
          }
          $("deckEditModal").classList.remove("show");
          await loadTarotDeck();
          setTarotStatus("Deck updated.", "ok");
        }catch(err){
          setTarotStatus(err.message, "err");
        }
      });

      $("taDeleteDeck").addEventListener("click", async () => {
        if (!authUserIsElfmin){
          setTarotStatus("Only elfministrators can delete decks.", "err");
          return;
        }
        const deck = $("taDeck").value.trim();
        if (!deck){
          setTarotStatus("Pick a deck to delete.", "err");
          return;
        }
        if (!confirm("This deck will fall from the forest. Continue?")){
          return;
        }
        try{
          await jsonFetch("/api/tarot/decks/" + encodeURIComponent(deck), {method:"DELETE"}, true);
          setTarotStatus("Deck deleted.", "ok");
          await loadTarotDeckList();
          $("taDeckList").textContent = "No deck loaded.";
          taSelectedCardId = "";
          taRenderPreviews(null);
        }catch(err){
          setTarotStatus(err.message, "err");
        }
      });

      $("taSaveCard").addEventListener("click", async () => {
        try{
          const deck = $("taDeck").value.trim() || "elf-classic";
          const tags = $("taCardTags").value.split(",").map(t => t.trim()).filter(Boolean);
          const body = {
            card_id: $("taCardId").value.trim() || undefined,
            name: $("taCardName").value.trim(),
            suit: $("taCardSuit").value.trim(),
            number: $("taCardNumber").value.trim() || undefined,
            image: window.taUploadedImageUrl || undefined,
            artist_id: $("taCardArtist").value.trim() || undefined,
            tags,
            flavor_text: $("taCardFlavor").value.trim() || undefined,
            upright: $("taCardUpright").value.trim(),
            reversed: $("taCardReversed").value.trim(),
            themes: taGetCardThemeWeights(),
            artist_links: undefined
          };
          await jsonFetch("/api/tarot/decks/" + encodeURIComponent(deck) + "/cards", {
            method:"POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(body)
          });
          $("taCardId").value = "";
          $("taCardName").value = "";
          $("taCardSuit").value = "";
          $("taCardNumber").value = "";
          window.taUploadedImageUrl = "";
          $("taCardTags").value = "";
          $("taCardFlavor").value = "";
          $("taCardUpright").value = "";
          $("taCardReversed").value = "";
          $("taCardArtist").value = "";
          taRenderNumberInfo("");
          taSetCardThemeWeights({});
          taSelectedCardId = body.card_id || "";
          taDirty = false;
          await loadTarotDeck();
          setTarotStatus("Saved", "ok");
        }catch(err){
          setTarotStatus(err.message, "err");
        }
      });

      async function loadTarotDeckList(selectValue, autoLoad = true){
        try{
          const data = await jsonFetch("/api/tarot/decks", {method:"GET"}, true);
          const decks = data.decks || [];
          const select = $("taDeck");
          select.innerHTML = "";
          decks.forEach(d => {
            const opt = document.createElement("option");
            opt.value = d.deck_id;
            opt.textContent = d.name ? `${d.name} (${d.deck_id})` : d.deck_id;
            select.appendChild(opt);
          });
          select.value = selectValue || "elf-classic";
          if (autoLoad && select.value){
            await loadTarotDeck();
          }
        }catch(err){
          setStatus(err.message, "err");
        }
      }

      loadSettings();
      if (apiKeyEl.value.trim()){
        document.getElementById("loginView").classList.add("hidden");
        document.getElementById("appView").classList.remove("hidden");
        loadAuthUser();
        const contestCategoryStatus = $("contestCategoryStatus");
        if (contestCategoryStatus){
          contestCategoryStatus.textContent = CONTEST_CATEGORY_ID;
        }
        if ($("contestChannelName") && !$("contestChannelName").value.trim()){
          $("contestChannelName").value = "elfoween";
        }
        updateContestChannelPreview();
        loadGamesMenu();
        const saved = getSavedPanel();
        if (!getSeenDashboard()){
          showPanelOnce("dashboard");
          setSeenDashboard();
        } else {
          showPanel(saved || "bingo");
        }
        ensureBingoPolling();
        loadTarotDeckList();
        loadTarotSessionDecks();
        loadTarotSessions();
        loadTarotNumbers();
        loadTarotArtists();
      }
      renderCard(null, [], "BING");
    </script>
  </body>
</html>
































